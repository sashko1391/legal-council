═══════════════════════════════════════════════════════════════════════
  AGENTIS LEGAL COUNCIL — COMPLETE PROJECT CODE
═══════════════════════════════════════════════════════════════════════

Generated: 2026-02-14 14:36:51

Backend: 8 AI agents, 2 orchestrators, services, RAG
Frontend: Next.js 14, React, Zustand, Tailwind CSS
Law Base: 1,620 articles ЦКУ + КЗпП via Pinecone
LLM: Anthropic Claude, OpenAI GPT, Google Gemini

═══════════════════════════════════════════════════════════════════════

════════════════════════════════════════════════════════════════
FILE: packages/core/orchestrator/types.ts
════════════════════════════════════════════════════════════════

/**
 * Core Types for Legal Council Orchestration
 * 
 * FIX #10: 'gen-validator' role
 * FIX #17 (Feb 13, 2026): Updated MODEL_PRICING to actual current prices
 */

// ==========================================
// AGENT TYPES
// ==========================================

export type AgentRole = 
  | 'expert' | 'provocateur' | 'validator' | 'synthesizer'
  | 'analyzer' | 'drafter' | 'gen-validator' | 'polisher';

export type ModelProvider = 'anthropic' | 'openai' | 'google';

export interface AgentConfig {
  id: string;
  role: AgentRole;
  model: string;
  provider: ModelProvider;
  priority: number;
  temperature: number;
  maxTokens: number;
}

// ==========================================
// AGENT OUTPUTS
// ==========================================

export interface BaseAgentOutput {
  agentId: string;
  role: AgentRole;
  confidence: number;
  timestamp: string;
  tokensUsed: { input: number; output: number };
  latencyMs: number;
}

export interface AgentError {
  agentId: string;
  error: string;
  timestamp: string;
  retryable: boolean;
}

// ==========================================
// ORCHESTRATOR TYPES
// ==========================================

export interface StopCriteria {
  maxRounds: number;
  maxSeverity: number;
  minConfidence: number;
  convergenceThreshold: number;
}

export interface OrchestratorConfig {
  agents: AgentConfig[];
  stopCriteria: StopCriteria;
  conflictResolution: 'priority' | 'weighted' | 'voting';
  enableAuditTrail: boolean;
}

export interface Round {
  roundNumber: number;
  outputs: BaseAgentOutput[];
  conflicts: Conflict[];
  convergence: number;
  shouldContinue: boolean;
}

export interface Conflict {
  agentA: string;
  agentB: string;
  issue: string;
  severity: number;
  resolution: string;
}

// ==========================================
// FINAL RESPONSE
// ==========================================

export interface CouncilResponse<T = any> {
  finalOutput: T;
  confidence: number;
  totalRounds: number;
  totalCost: number;
  totalLatencyMs: number;
  auditTrail: AuditTrail;
  metadata: {
    stopReason: 'max_rounds' | 'consensus' | 'high_confidence' | 'convergence';
    model: string;
  };
}

export interface AuditTrail {
  rounds: Round[];
  allOutputs: BaseAgentOutput[];
  conflicts: Conflict[];
  decisions: Decision[];
}

export interface Decision {
  timestamp: string;
  type: 'continue_round' | 'stop' | 'conflict_resolution';
  reason: string;
  data: any;
}

// ==========================================
// COST TRACKING
// ==========================================

export interface CostCalculation {
  inputTokens: number;
  outputTokens: number;
  inputCost: number;
  outputCost: number;
  totalCost: number;
  model: string;
}

/**
 * FIX #17: Updated to actual prices (Feb 2026).
 * Source: https://docs.anthropic.com/en/docs/about-claude/models
 *         https://openai.com/pricing
 *         https://ai.google.dev/pricing
 * 
 * Prices in USD per 1M tokens.
 */
export const MODEL_PRICING: Record<string, { input: number; output: number }> = {
  // Anthropic
  'claude-opus-4-5-20251101': { input: 15, output: 75 },
  'claude-sonnet-4-5-20250929': { input: 3, output: 15 },
  'claude-haiku-4-5-20251001': { input: 0.80, output: 4 },

  // OpenAI
  'gpt-4-turbo-2024-04-09': { input: 10, output: 30 },
  'gpt-4o': { input: 2.50, output: 10 },
  'gpt-4o-mini': { input: 0.15, output: 0.60 },

  // Google — free tier (rate limited)
  'gemini-2.5-flash-lite': { input: 0, output: 0 },
  'gemini-1.5-flash': { input: 0, output: 0 },
  'gemini-2.0-flash-thinking-exp-01-21': { input: 0, output: 0 },
};

export function calculateCost(
  model: string,
  inputTokens: number,
  outputTokens: number
): CostCalculation {
  const pricing = MODEL_PRICING[model] || { input: 0, output: 0 };
  const inputCost = (inputTokens / 1_000_000) * pricing.input;
  const outputCost = (outputTokens / 1_000_000) * pricing.output;
  return { inputTokens, outputTokens, inputCost, outputCost, totalCost: inputCost + outputCost, model };
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/base-agent.ts
════════════════════════════════════════════════════════════════

/**
 * Base Agent - Foundation for all Legal Council agents
 * 
 * FIXES Applied:
 * - #4: Rate limit (429) and server error (500, 503) retries
 * - #6: Per-request client creation (no singletons)
 * - #7: Gemini systemInstruction parameter
 * - #8: Retry logic for Google Gemini
 * - #9: Accurate token counts via usageMetadata (Ukrainian text)
 * - #12: AbortController timeout (120s) for all API calls
 * - #13: JSON repair fallback (trailing commas, single quotes, unescaped newlines)
 * - #16: Proper logger instead of console.log (no contract text leak in production)
 * - C3 (Feb 14, 2026): AbortSignal actually passed to all SDK calls
 * - H3 (Feb 14, 2026): Apostrophe-safe JSON repair (Ukrainian об'єкт, обов'язок)
 */

import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { AgentConfig, BaseAgentOutput } from '../../core/orchestrator/types';
import { calculateCost } from '../../core/orchestrator/types';
import { createAgentLogger, logger } from '../utils/logger';

// ==========================================================================
// CONSTANTS
// ==========================================================================

/** Timeout for any single LLM API call (2 minutes) */
const API_TIMEOUT_MS = 120_000;

/** Maximum retry attempts */
const MAX_RETRIES = 3;

// ==========================================================================
// FIX #6: Per-request client factories
// ==========================================================================

function createAnthropicClient(): Anthropic {
  const apiKey = process.env.ANTHROPIC_API_KEY;
  if (!apiKey) throw new Error('ANTHROPIC_API_KEY not found in environment variables');
  return new Anthropic({ apiKey });
}

function createOpenAIClient(): OpenAI {
  const apiKey = process.env.OPENAI_API_KEY;
  if (!apiKey) throw new Error('OPENAI_API_KEY not found in environment variables');
  return new OpenAI({ apiKey });
}

function createGoogleClient(): GoogleGenerativeAI {
  const apiKey = process.env.GOOGLE_API_KEY;
  if (!apiKey) throw new Error('GOOGLE_API_KEY not found in environment variables');
  return new GoogleGenerativeAI(apiKey);
}

// ==========================================================================
// FIX #4: Retryable error detection
// ==========================================================================

function isRetryableError(error: any): boolean {
  // Network errors
  if (
    error.code === 'EAI_AGAIN' || error.code === 'ENOTFOUND' ||
    error.code === 'ETIMEDOUT' || error.code === 'ECONNRESET' ||
    error.message?.includes('Connection error') ||
    error.message?.includes('network')
  ) return true;

  // FIX #12: Timeout abort
  if (error.name === 'AbortError' || error.message?.includes('aborted')) return true;

  // HTTP status-based (rate limit, server errors)
  const status = error.status || error.statusCode || error.response?.status;
  if (status === 429 || status === 500 || status === 503) return true;

  // Provider-specific
  if (error.type === 'rate_limit_error' || error.error?.type === 'rate_limit_error') return true;
  if (error.code === 'rate_limit_exceeded') return true;

  // Message-based
  if (
    error.message?.includes('rate limit') || error.message?.includes('Rate limit') ||
    error.message?.includes('overloaded') || error.message?.includes('Overloaded') ||
    error.message?.includes('Too Many Requests') || error.message?.includes('Service Unavailable')
  ) return true;

  return false;
}

function isAuthError(error: any): boolean {
  if (error.message?.includes('Invalid API key') || error.message?.includes('not found')) return true;
  const status = error.status || error.statusCode || error.response?.status;
  return status === 401 || status === 403;
}

function getRetryDelay(attempt: number, error?: any): number {
  const retryAfter = error?.headers?.['retry-after'] || error?.response?.headers?.['retry-after'];
  if (retryAfter) {
    const ms = parseInt(retryAfter, 10) * 1000;
    if (!isNaN(ms) && ms > 0) return Math.min(ms, 60_000);
  }
  const base = 1000 * Math.pow(2, attempt - 1);
  return Math.min(base + Math.random() * 500, 30_000);
}

// ==========================================================================
// FIX #12: Timeout helper
// ==========================================================================

function createTimeout(): { signal: AbortSignal; clear: () => void } {
  const controller = new AbortController();
  const timer = setTimeout(() => controller.abort(), API_TIMEOUT_MS);
  return {
    signal: controller.signal,
    clear: () => clearTimeout(timer),
  };
}

// ==========================================================================
// BASE AGENT
// ==========================================================================

export abstract class BaseAgent<TOutput extends BaseAgentOutput = BaseAgentOutput> {
  protected config: AgentConfig;
  protected systemPrompt: string;
  private log: ReturnType<typeof createAgentLogger>;

  constructor(config: AgentConfig, systemPrompt: string) {
    this.config = config;
    this.systemPrompt = systemPrompt;
    this.log = createAgentLogger(config.id);
  }

  async call(userPrompt: string): Promise<TOutput> {
    const startTime = Date.now();

    try {
      let response: string;
      let tokensUsed: { input: number; output: number };

      switch (this.config.provider) {
        case 'anthropic':
          ({ response, tokensUsed } = await this.callAnthropic(userPrompt));
          break;
        case 'openai':
          ({ response, tokensUsed } = await this.callOpenAI(userPrompt));
          break;
        case 'google':
          ({ response, tokensUsed } = await this.callGoogle(userPrompt));
          break;
        default:
          throw new Error(`Unknown provider: ${this.config.provider}`);
      }

      const latencyMs = Date.now() - startTime;

      // FIX #16: debug level — suppressed in production (no contract text leak)
      this.log.debug(`Raw LLM Response (first 500 chars):\n${response.substring(0, 500)}`);
      this.log.debug(`Response total length: ${response.length} chars`);

      const parsed = this.parseResponse(response);

      const baseOutput: BaseAgentOutput = {
        agentId: this.config.id,
        role: this.config.role,
        confidence: parsed.confidence || 0.8,
        timestamp: new Date().toISOString(),
        tokensUsed,
        latencyMs,
      };

      return { ...baseOutput, ...parsed } as TOutput;
    } catch (error) {
      this.log.error(`Agent failed:`, error);
      throw error;
    }
  }

  // ==========================================================================
  // ANTHROPIC — FIX C3: signal passed to SDK
  // ==========================================================================

  private async callAnthropic(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = createAnthropicClient();
    let lastError: any;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      const timeout = createTimeout();
      try {
        // FIX C3: Pass AbortSignal as second argument (request options)
        const message = await client.messages.create(
          {
            model: this.config.model,
            max_tokens: this.config.maxTokens,
            temperature: this.config.temperature,
            system: this.systemPrompt,
            messages: [{ role: 'user', content: userPrompt }],
          },
          { signal: timeout.signal }
        );
        timeout.clear();

        const textContent = message.content.find((c) => c.type === 'text');
        if (!textContent || textContent.type !== 'text') {
          throw new Error('No text content in Anthropic response');
        }

        return {
          response: textContent.text,
          tokensUsed: { input: message.usage.input_tokens, output: message.usage.output_tokens },
        };
      } catch (error: any) {
        timeout.clear();
        lastError = error;
        if (isAuthError(error) || !isRetryableError(error)) throw error;
        if (attempt === MAX_RETRIES) { this.log.error(`All ${MAX_RETRIES} attempts failed`); throw error; }
        const delay = getRetryDelay(attempt, error);
        this.log.warn(`Retryable error (attempt ${attempt}/${MAX_RETRIES}), retrying in ${delay}ms: ${error.status || error.code} - ${error.message}`);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    throw lastError;
  }

  // ==========================================================================
  // OPENAI — FIX C3: signal passed to SDK
  // ==========================================================================

  private async callOpenAI(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = createOpenAIClient();
    let lastError: any;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      const timeout = createTimeout();
      try {
        // FIX C3: Pass AbortSignal as second argument (request options)
        const completion = await client.chat.completions.create(
          {
            model: this.config.model,
            max_tokens: this.config.maxTokens,
            temperature: this.config.temperature,
            messages: [
              { role: 'system', content: this.systemPrompt },
              { role: 'user', content: userPrompt },
            ],
          },
          { signal: timeout.signal }
        );
        timeout.clear();

        const choice = completion.choices[0];
        if (!choice?.message?.content) throw new Error('No content in OpenAI response');

        return {
          response: choice.message.content,
          tokensUsed: { input: completion.usage?.prompt_tokens || 0, output: completion.usage?.completion_tokens || 0 },
        };
      } catch (error: any) {
        timeout.clear();
        lastError = error;
        if (isAuthError(error) || !isRetryableError(error) || attempt === MAX_RETRIES) throw error;
        const delay = getRetryDelay(attempt, error);
        this.log.warn(`Retryable error (attempt ${attempt}/${MAX_RETRIES}), retrying in ${delay}ms: ${error.status || error.code} - ${error.message}`);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    throw lastError;
  }

  // ==========================================================================
  // GOOGLE GEMINI (#7, #8, #9) — FIX C3: timeout via requestOptions
  // ==========================================================================

  private async callGoogle(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = createGoogleClient();
    // FIX C3: Gemini SDK doesn't support AbortSignal on generateContent,
    // so we use requestOptions.timeout on the model itself
    const model = client.getGenerativeModel(
      {
        model: this.config.model,
        systemInstruction: this.systemPrompt, // FIX #7
      },
      { timeout: API_TIMEOUT_MS } // FIX C3: request-level timeout
    );

    let lastError: any;

    for (let attempt = 1; attempt <= MAX_RETRIES; attempt++) {
      const timeout = createTimeout();
      try {
        const result = await model.generateContent(userPrompt);
        timeout.clear();
        const response = result.response.text();

        // FIX #9: Real token counts from API (fallback /3 for Ukrainian text)
        const usage = result.response.usageMetadata;
        const inputTokens = usage?.promptTokenCount || Math.ceil(userPrompt.length / 3);
        const outputTokens = usage?.candidatesTokenCount || Math.ceil(response.length / 3);

        return { response, tokensUsed: { input: inputTokens, output: outputTokens } };
      } catch (error: any) {
        timeout.clear();
        lastError = error;
        if (isAuthError(error) || !isRetryableError(error) || attempt === MAX_RETRIES) throw error;
        const delay = getRetryDelay(attempt, error);
        this.log.warn(`Google API error (attempt ${attempt}/${MAX_RETRIES}), retrying in ${delay}ms: ${error.status || error.code} - ${error.message}`);
        await new Promise(r => setTimeout(r, delay));
      }
    }
    throw lastError;
  }

  // ==========================================================================
  // FIX #13: JSON Parsing with repair fallback
  // ==========================================================================

  protected parseResponse(response: string): any {
    const originalResponse = response;

    try {
      // Strategy 1: Clean markdown fences
      let cleaned = response.trim();
      if (cleaned.startsWith('```json')) {
        cleaned = cleaned.replace(/^```json\s*/, '').replace(/```\s*$/, '');
      } else if (cleaned.startsWith('```')) {
        cleaned = cleaned.replace(/^```\s*/, '').replace(/```\s*$/, '');
      }

      // Strategy 2: Extract JSON object
      const firstBrace = cleaned.indexOf('{');
      const lastBrace = cleaned.lastIndexOf('}');
      if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
        cleaned = cleaned.substring(firstBrace, lastBrace + 1);
      }

      // Strategy 3: Try direct parse
      try {
        const parsed = JSON.parse(cleaned);
        this.log.info('Successfully parsed JSON');
        return parsed;
      } catch (directError) {
        // Strategy 4: Repair common LLM JSON issues
        this.log.debug('Direct JSON parse failed, attempting repair...');
        const repaired = this.repairJson(cleaned);
        const parsed = JSON.parse(repaired);
        this.log.info('Successfully parsed JSON after repair');
        return parsed;
      }

    } catch (error) {
      // FIX #16: Error details only in debug (production: no contract text in logs)
      this.log.error(`JSON Parsing Failed!`);
      this.log.debug(`Original Response (full):\n${originalResponse}`);
      this.log.debug(`Response Length: ${originalResponse.length} characters`);
      this.log.debug(`First 200 chars: ${originalResponse.substring(0, 200)}`);
      this.log.debug(`Last 200 chars: ${originalResponse.substring(Math.max(0, originalResponse.length - 200))}`);

      if (!originalResponse.includes('{')) {
        this.log.error('Response does not contain any JSON object');
      }
      if (originalResponse.includes("I'm sorry") || originalResponse.includes('I cannot')) {
        this.log.error('LLM appears to have refused the request');
      }

      throw new Error(`Invalid JSON response from ${this.config.id}: ${error}\nSee logs for details.`);
    }
  }

  /**
   * FIX #13 + H3: Attempt to repair common JSON issues from LLM output
   * 
   * H3: Apostrophe-safe — Ukrainian text uses ' inside words (об'єкт, обов'язок).
   * Old code replaced ALL single quotes, corrupting Ukrainian text.
   * New code only replaces single quotes used as JSON delimiters.
   */
  private repairJson(json: string): string {
    let repaired = json;

    // Fix 1: Remove trailing commas before } or ]
    // e.g., {"a": 1, "b": 2,} → {"a": 1, "b": 2}
    repaired = repaired.replace(/,\s*([\]}])/g, '$1');

    // Fix 2: Replace single-quoted JSON delimiters (NOT Ukrainian apostrophes)
    // Ukrainian: об'єкт, обов'язок, з'єднання — apostrophe INSIDE a word
    // JSON delimiters: {'key': 'value'} — apostrophe AROUND keys/values
    // Strategy: replace ' only when it appears as a string delimiter
    //   - After : , [ { (opening a value)
    //   - Before : ] } , (closing a value/key)
    repaired = repaired.replace(/([:,\[{])\s*'([^']*?)'\s*(?=[,\]}:])/g, '$1"$2"');
    // Catch remaining key patterns: 'key':
    repaired = repaired.replace(/'([^']*?)'(\s*:)/g, '"$1"$2');

    // Fix 3: Fix unescaped newlines inside strings
    repaired = repaired.replace(/"([^"]*?)"/g, (match) => {
      return match
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\t/g, '\\t');
    });

    // Fix 4: Remove JavaScript-style comments
    repaired = repaired.replace(/\/\/.*$/gm, '');
    repaired = repaired.replace(/\/\*[\s\S]*?\*\//g, '');

    // Fix 5: Fix unquoted keys (simple cases)
    // e.g., {key: "value"} → {"key": "value"}
    repaired = repaired.replace(/(\{|,)\s*([a-zA-Z_]\w*)\s*:/g, '$1"$2":');

    return repaired;
  }

  calculateCost(tokensUsed: { input: number; output: number }): number {
    const costCalc = calculateCost(this.config.model, tokensUsed.input, tokensUsed.output);
    return costCalc.totalCost;
  }

  protected logMessage(message: string, data?: any): void {
    this.log.info(message, data);
  }
}

// ==========================================
// ERROR HANDLING
// ==========================================

export class AgentError extends Error {
  constructor(
    public agentId: string,
    public originalError: Error,
    public retryable: boolean = true
  ) {
    super(`Agent ${agentId} failed: ${originalError.message}`);
    this.name = 'AgentError';
  }
}

export async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;
      if (isAuthError(error)) throw error;
      if (i < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, i);
        logger.info(`Retry ${i + 1}/${maxRetries} after ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }
  throw lastError!;
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/generation/analyzer.ts
════════════════════════════════════════════════════════════════

/**
 * Analyzer Agent (Document Generation)
 * Parses user requirements into structured specifications
 */

import { BaseAgent } from '../base-agent';
import { buildAnalyzerPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  AnalyzerOutput,
  DocumentGenerationRequest,
} from '../../types/generation-types';

export class AnalyzerAgent extends BaseAgent<AnalyzerOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const analyzerConfig = configs.find((c) => c.role === 'analyzer')!;

    super(analyzerConfig, '');
  }

  /**
   * Analyze user requirements and structure them
   */
  async analyze(request: DocumentGenerationRequest): Promise<AnalyzerOutput> {
    this.systemPrompt = await buildAnalyzerPrompt(request.documentType);

    const userPrompt = this.buildUserPrompt(request);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(request: DocumentGenerationRequest): string {
    let prompt = '# USER REQUIREMENTS\n\n';
    prompt += request.requirements;
    prompt += '\n\n# DOCUMENT TYPE\n\n';
    prompt += `${request.documentType}\n\n`;

    if (request.jurisdiction) {
      prompt += `# JURISDICTION\n\n${request.jurisdiction}\n\n`;
    }

    if (request.parties && request.parties.length > 0) {
      prompt += '# PARTIES\n\n';
      request.parties.forEach((p) => {
        prompt += `- ${p.role}: ${p.name || '[to be filled]'}\n`;
      });
      prompt += '\n';
    }

    if (request.specificClauses && request.specificClauses.length > 0) {
      prompt += '# SPECIFIC CLAUSES REQUESTED\n\n';
      request.specificClauses.forEach((c) => {
        prompt += `- ${c.type} (${c.priority}): ${c.requirements}\n`;
      });
      prompt += '\n';
    }

    prompt += '# YOUR TASK\n\n';
    prompt += 'Parse these requirements into structured JSON format.\n';
    prompt += 'Make smart assumptions where info is missing.\n';
    prompt += 'Suggest additional clauses that are essential for this document type.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.analysis || !output.analysis.structuredRequirements) {
      throw new Error('Analyzer output missing structuredRequirements');
    }

    const req = output.analysis.structuredRequirements;
    if (!req.documentType || !req.parties || !req.mustHaveClauses) {
      console.warn('⚠️ Analyzer output missing key fields');
    }
  }
}

export async function analyzeRequirements(
  request: DocumentGenerationRequest
): Promise<AnalyzerOutput> {
  const analyzer = new AnalyzerAgent();
  return analyzer.analyze(request);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/generation/drafter.ts
════════════════════════════════════════════════════════════════

/**
 * Drafter Agent (Document Generation)
 * Generates ДСТУ-compliant Ukrainian contracts
 */

import { BaseAgent } from '../base-agent';
import { buildDrafterPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type { DrafterOutput, AnalyzerOutput, DocumentType } from '../../types/generation-types';

export class DrafterAgent extends BaseAgent<DrafterOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const drafterConfig = configs.find((c) => c.role === 'drafter')!;

    super(drafterConfig, '');
  }

  /**
   * Draft complete contract based on structured requirements
   */
  async draft(
    documentType: DocumentType,
    analyzerOutput: AnalyzerOutput
  ): Promise<DrafterOutput> {
    this.systemPrompt = await buildDrafterPrompt(documentType);

    const userPrompt = this.buildUserPrompt(analyzerOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(analyzerOutput: AnalyzerOutput): string {
    const req = analyzerOutput.analysis.structuredRequirements;

    let prompt = '# STRUCTURED REQUIREMENTS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(req, null, 2);
    prompt += '\n```\n\n';

    prompt += '# SUGGESTED CLAUSES\n\n';
    analyzerOutput.analysis.suggestedClauses.forEach((clause) => {
      prompt += `- ${clause.type} (${clause.priority}): ${clause.rationale}\n`;
    });

    prompt += '\n# YOUR TASK\n\n';
    prompt += 'Generate complete ДСТУ-compliant contract in Ukrainian language.\n';
    prompt += 'Follow the EXACT structure from your system prompt.\n';
    prompt += 'Include all mandatory sections per Ukrainian law.\n';
    prompt += 'Output strict JSON with "documentText" field containing full Markdown contract.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.draft || !output.draft.documentText) {
      throw new Error('Drafter output missing documentText');
    }

    const text = output.draft.documentText;

    // Basic ДСТУ validation
    if (!text.includes('ДОГОВІР')) {
      console.warn('⚠️ Contract missing "ДОГОВІР" title');
    }

    if (!text.includes('ПРЕДМЕТ ДОГОВОРУ')) {
      console.warn('⚠️ Contract missing mandatory section: ПРЕДМЕТ ДОГОВОРУ');
    }

    if (!text.includes('ПІДПИСИ СТОРІН')) {
      console.warn('⚠️ Contract missing signature section');
    }
  }
}

export async function draftDocument(
  documentType: DocumentType,
  analyzerOutput: AnalyzerOutput
): Promise<DrafterOutput> {
  const drafter = new DrafterAgent();
  return drafter.draft(documentType, analyzerOutput);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/generation/polisher.ts
════════════════════════════════════════════════════════════════

/**
 * Polisher Agent (Document Generation)
 * Finalizes document with professional quality
 * 
 * FIX #14 (Feb 13, 2026): Calculate real clarity & quality metrics
 * FIX #11: Removed `as any` for documentType — use proper DocumentType type
 */

import { BaseAgent } from '../base-agent';
import { buildPolisherPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  PolisherOutput,
  DrafterOutput,
  GenerationValidatorOutput,
  DocumentGenerationResponse,
  DocumentType,
} from '../../types/generation-types';

export class PolisherAgent extends BaseAgent<PolisherOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const polisherConfig = configs.find((c) => c.role === 'polisher')!;

    super(polisherConfig, '');
  }

  /**
   * Polish draft into final executive-ready document
   */
  async polish(
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput
  ): Promise<PolisherOutput> {
    this.systemPrompt = await buildPolisherPrompt();

    const userPrompt = this.buildUserPrompt(drafterOutput, validatorOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput
  ): string {
    let prompt = '# DRAFT DOCUMENT\n\n';
    prompt += '```\n';
    prompt += drafterOutput.draft.documentText;
    prompt += '\n```\n\n';

    prompt += '# VALIDATOR FEEDBACK\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(validatorOutput.validation, null, 2);
    prompt += '\n```\n\n';

    if (validatorOutput.validation.riskFlags.length > 0) {
      prompt += '# ISSUES TO ADDRESS\n\n';
      validatorOutput.validation.riskFlags.forEach((flag) => {
        prompt += `- ${flag.issue} (severity ${flag.severity}): ${flag.recommendation}\n`;
      });
      prompt += '\n';
    }

    prompt += '# YOUR POLISHING TASK\n\n';
    prompt += '1. Fix any issues identified by Validator\n';
    prompt += '2. Improve clarity and readability\n';
    prompt += '3. Ensure consistency throughout\n';
    prompt += '4. Add executive summary for client\n';
    prompt += '\nOutput strict JSON with polished document and improvements made.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.polished || !output.polished.finalDocument) {
      throw new Error('Polisher output missing finalDocument');
    }

    if (!output.polished.executiveSummary) {
      console.warn('⚠️ Polisher missing executive summary');
    }
  }

  /**
   * FIX #14: Calculate real quality metrics instead of hardcoded values.
   * - complianceScore: from validator
   * - legalSoundness: average of validator score and polisher confidence
   * - clarity: calculated from improvements count and risk resolution
   * - overall: weighted average of all three
   */
  private calculateQualityMetrics(
    polisherOutput: PolisherOutput,
    validatorOutput: GenerationValidatorOutput
  ): { complianceScore: number; legalSoundness: number; clarity: number; overall: number } {
    const validatorScore = validatorOutput.validation.overallScore;
    const polisherConfidence = Math.round((polisherOutput.confidence || 0.85) * 100);
    
    // Compliance: directly from validator
    const complianceScore = validatorScore;

    // Legal soundness: average of validator score and polisher confidence
    const legalSoundness = Math.round((validatorScore + polisherConfidence) / 2);

    // Clarity: based on improvements made and risk flags resolved
    const improvementCount = polisherOutput.polished?.improvements?.length || 0;
    const riskFlagCount = validatorOutput.validation.riskFlags.length;
    // More improvements = better clarity work done
    // Base of 70, +5 per improvement (up to 30 bonus), -3 per unresolved risk
    const clarityBase = 70;
    const clarityBonus = Math.min(30, improvementCount * 5);
    const clarityPenalty = Math.min(20, riskFlagCount * 3);
    const clarity = Math.min(100, Math.max(0, clarityBase + clarityBonus - clarityPenalty));

    // Overall: weighted average (compliance 40%, legal 30%, clarity 30%)
    const overall = Math.round(
      complianceScore * 0.4 + legalSoundness * 0.3 + clarity * 0.3
    );

    return { complianceScore, legalSoundness, clarity, overall };
  }

  buildFinalResponse(
    polisherOutput: PolisherOutput,
    analyzerOutput: any,
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput,
    metadata: {
      documentType: DocumentType;  // FIX #11: proper type instead of `string` + `as any`
      totalCost: number;
      processingTimeMs: number;
    }
  ): DocumentGenerationResponse {
    // FIX #14: calculate real metrics
    const qualityMetrics = this.calculateQualityMetrics(polisherOutput, validatorOutput);

    return {
      finalDocument: polisherOutput.polished.finalDocument,
      format: 'markdown',

      metadata: {
        documentType: metadata.documentType,  // FIX #11: no more `as any`
        generatedAt: new Date().toISOString(),
        jurisdiction: 'Ukraine',
        confidence: polisherOutput.confidence,
        totalCost: metadata.totalCost,
        processingTimeMs: metadata.processingTimeMs,
      },

      summary: {
        executiveSummary: polisherOutput.polished.executiveSummary,
        keyTerms: polisherOutput.polished.keyTerms,
        includedClauses: drafterOutput.draft.includedClauses.map((c) => c.type),
      },

      qualityMetrics,  // FIX #14: real calculated values

      recommendations: {
        beforeSigning: [
          'Перевірте всі реквізити сторін перед підписанням',
          'Переконайтесь, що всі суми та дати заповнені правильно',
          'Зверніть увагу на розділи про відповідальність та розірвання договору',
        ],
        customizations:
          polisherOutput.polished.improvements?.map((i) => i.rationale) || [],
        reviewAreas:
          validatorOutput.validation.riskFlags.map((f) => f.location) || [],
      },
    };
  }
}

export async function polishDocument(
  drafterOutput: DrafterOutput,
  validatorOutput: GenerationValidatorOutput
): Promise<PolisherOutput> {
  const polisher = new PolisherAgent();
  return polisher.polish(drafterOutput, validatorOutput);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/generation/validator.ts
════════════════════════════════════════════════════════════════

/**
 * Generation Validator Agent
 * Checks legal compliance and ДСТУ standards of drafted document
 * 
 * FIX #10: Uses 'gen-validator' role (distinct from review 'validator')
 * FIX #23: Imports buildValidatorPrompt directly (removed wrapper buildGenerationValidatorPrompt)
 */

import { BaseAgent } from '../base-agent';
import { buildValidatorPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  GenerationValidatorOutput,
  DrafterOutput,
  AnalyzerOutput,
} from '../../types/generation-types';

export class GenerationValidatorAgent extends BaseAgent<GenerationValidatorOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    // FIX #10: Now looks for 'gen-validator' role
    const validatorConfig = configs.find((c) => c.role === 'gen-validator')!;

    super(validatorConfig, '');
  }

  /**
   * Validate drafted document for legal compliance
   */
  async validate(
    analyzerOutput: AnalyzerOutput,
    drafterOutput: DrafterOutput
  ): Promise<GenerationValidatorOutput> {
    // FIX #23: Direct call instead of wrapper
    this.systemPrompt = await buildValidatorPrompt();

    const userPrompt = this.buildUserPrompt(analyzerOutput, drafterOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(
    analyzerOutput: AnalyzerOutput,
    drafterOutput: DrafterOutput
  ): string {
    let prompt = '# ORIGINAL REQUIREMENTS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(analyzerOutput.analysis.structuredRequirements, null, 2);
    prompt += '\n```\n\n';

    prompt += '# DRAFTED DOCUMENT\n\n';
    prompt += '```\n';
    prompt += drafterOutput.draft.documentText;
    prompt += '\n```\n\n';

    prompt += '# YOUR VALIDATION TASK\n\n';
    prompt += 'Check this document against:\n';
    prompt += '1. Ukrainian law requirements (ЦКУ ст. 638)\n';
    prompt += '2. ДСТУ 4163-2020 structure\n';
    prompt += '3. Completeness (all required clauses present)\n';
    prompt += '4. Legal risks (ambiguous terms, liability gaps)\n';
    prompt += '\nOutput strict JSON with compliance checks and risk flags.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.validation || !output.validation.verdict) {
      throw new Error('Validator output missing verdict');
    }

    const validVerdicts = ['APPROVED', 'NEEDS_REVISION'];
    if (!validVerdicts.includes(output.validation.verdict)) {
      throw new Error(`Invalid verdict: ${output.validation.verdict}`);
    }
  }

  isPassed(output: GenerationValidatorOutput): boolean {
    return output.validation.verdict === 'APPROVED';
  }
}

export async function validateDocument(
  analyzerOutput: AnalyzerOutput,
  drafterOutput: DrafterOutput
): Promise<GenerationValidatorOutput> {
  const validator = new GenerationValidatorAgent();
  return validator.validate(analyzerOutput, drafterOutput);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/review/expert.ts
════════════════════════════════════════════════════════════════

/**
 * Expert Agent (Contract Review)
 * Comprehensive legal analysis of contracts
 * 
 * FIX (Feb 10, 2026): Validation expects flat structure from LLM
 * UPDATE (Feb 14, 2026): RAG integration — semantic search for relevant law articles
 * FIX C2 (Feb 14, 2026): Added Ukrainian contract type mapping (оренда→lease, etc.)
 * FIX M2 (Feb 14, 2026): Replaced console.log/warn with structured logger
 */

import { BaseAgent } from '../base-agent';
import { buildExpertPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import { getLawContext } from '../../services/law-rag-service';
import { createAgentLogger } from '../../utils/logger';
import type { ExpertOutput, ContractReviewRequest } from '../../types/review-types';

const log = createAgentLogger('expert');

export class ExpertAgent extends BaseAgent<ExpertOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const expertConfig = configs.find((c: any) => c.role === 'expert')!;

    // System prompt will be set dynamically based on contract type
    super(expertConfig, ''); // Empty for now, set in analyze()
  }

  /**
   * Analyze contract and return comprehensive expert opinion
   */
  async analyze(request: ContractReviewRequest): Promise<ExpertOutput> {
    // Build context-aware system prompt
    this.systemPrompt = await buildExpertPrompt(
      request.contractType,
      request.jurisdiction
    );

    // RAG: Find relevant law articles based on actual contract text
    const lawContext = await this.findRelevantLaws(
      request.contractText,
      request.contractType
    );

    // Build user prompt with all context + RAG results
    const userPrompt = this.buildUserPrompt(request, lawContext);

    // Call LLM
    const rawOutput = await this.call(userPrompt);

    // Transform flat structure to nested structure
    const output = this.transformOutput(rawOutput);

    // Validate output structure
    this.validateOutput(output);

    return output;
  }

  /**
   * RAG: Search Pinecone for relevant Ukrainian law articles
   * Falls back gracefully if Pinecone is unavailable
   * 
   * FIX C2: Maps both English AND Ukrainian contract type names to RAG categories
   */
  private async findRelevantLaws(
    contractText: string,
    contractType?: string
  ): Promise<string> {
    try {
      // FIX C2: Map contract types to RAG categories
      // Supports both English keys (from API) and Ukrainian keys (from UI)
      const typeMap: Record<string, string> = {
        // English
        'vendor': 'sale',
        'sale': 'sale',
        'lease': 'lease',
        'rental': 'lease',
        'service': 'service',
        'employment': 'employment',
        'work': 'work',
        'loan': 'loan',
        'nda': 'general',
        // Ukrainian (from UI select options)
        'оренда': 'lease',
        'поставка': 'sale',
        'послуги': 'service',
        'трудовий': 'employment',
        'підряд': 'work',
        'купівля-продаж': 'sale',
        'інше': 'general',
      };
      
      const ragType = typeMap[(contractType || '').toLowerCase()] || 'general';
      
      const lawContext = await getLawContext(contractText, ragType);
      log.info(`RAG: found relevant articles for type="${ragType}" (input="${contractType}")`);
      return lawContext;
    } catch (error) {
      log.warn('RAG unavailable, proceeding without law context:', error);
      return '<relevant_law_articles>\nRAG система тимчасово недоступна. Використовуйте загальні знання українського законодавства.\n</relevant_law_articles>';
    }
  }

  /**
   * Build comprehensive user prompt
   */
  private buildUserPrompt(
    request: ContractReviewRequest,
    lawContext: string
  ): string {
    let prompt = '# CONTRACT TO ANALYZE\n\n';
    prompt += '```\n';
    prompt += request.contractText;
    prompt += '\n```\n\n';

    // Add contract metadata
    prompt += '# CONTEXT\n\n';
    if (request.contractType) {
      prompt += `Contract Type: ${request.contractType}\n`;
    }
    if (request.jurisdiction) {
      prompt += `Jurisdiction: ${request.jurisdiction}\n`;
    }

    // Add RAG results — relevant law articles
    prompt += '\n# RELEVANT UKRAINIAN LAW ARTICLES\n\n';
    prompt += lawContext;
    prompt += '\n\n';
    prompt += 'ВАЖЛИВО: Цитуйте конкретні статті з наведеного списку у вашому аналізі. ';
    prompt += 'Якщо стаття має позначку "critical" — обов\'язково згадайте її у відповідних issues.\n';

    // Add specific questions if provided
    if (request.specificQuestions && request.specificQuestions.length > 0) {
      prompt += '\n# SPECIFIC QUESTIONS FROM CLIENT\n\n';
      request.specificQuestions.forEach((q: string, i: number) => {
        prompt += `${i + 1}. ${q}\n`;
      });
    }

    // Add focus areas if provided
    if (request.focusAreas && request.focusAreas.length > 0) {
      prompt += '\n# PRIORITY FOCUS AREAS\n\n';
      prompt += 'Pay special attention to:\n';
      request.focusAreas.forEach((area: any) => {
        prompt += `- ${area}\n`;
      });
    }

    prompt += '\n# YOUR TASK\n\n';
    prompt += 'Provide comprehensive analysis following the JSON structure specified in your system prompt.\n';
    prompt += 'Be thorough, specific, and reference exact clause numbers.\n';
    prompt += 'ОБОВ\'ЯЗКОВО посилайтесь на конкретні статті ЦКУ/КЗпП з розділу RELEVANT UKRAINIAN LAW ARTICLES.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested ExpertOutput structure
   */
  private transformOutput(rawOutput: any): ExpertOutput {
    // LLM returns flat structure: { executiveSummary, keyIssues, ... }
    // We need nested: { analysis: { executiveSummary, keyIssues, ... } }
    
    return {
      ...rawOutput,
      analysis: {
        executiveSummary: rawOutput.executiveSummary,
        keyIssues: rawOutput.keyIssues,
        clauseAnalysis: rawOutput.clauseAnalysis,
        overallRiskScore: rawOutput.overallRiskScore,
        recommendations: rawOutput.recommendations,
      },
    } as ExpertOutput;
  }

  /**
   * Validate that output has required structure
   */
  private validateOutput(output: ExpertOutput): void {
    if (!output.analysis) {
      throw new Error('Expert output missing analysis object');
    }

    const required = [
      'executiveSummary',
      'keyIssues',
      'clauseAnalysis',
      'overallRiskScore',
      'recommendations',
    ];

    for (const field of required) {
      if (!(field in output.analysis)) {
        throw new Error(`Expert output missing required field: analysis.${field}`);
      }
    }

    // Validate risk score is in range
    if (
      output.analysis.overallRiskScore < 1 ||
      output.analysis.overallRiskScore > 10
    ) {
      log.warn(`Risk score out of range: ${output.analysis.overallRiskScore}`);
    }

    // Validate issues have severity
    for (const issue of output.analysis.keyIssues) {
      if (!issue.severity || issue.severity < 1 || issue.severity > 5) {
        log.warn(`Issue ${issue.id} has invalid severity: ${issue.severity}`);
      }
    }

    // Validate we have exactly 7 issues (as per optimized prompt)
    const issueCount = output.analysis.keyIssues.length;
    if (issueCount !== 7) {
      log.warn(`Returned ${issueCount} issues, expected 7 (prompt optimization)`);
    }

    // Validate we don't have too many recommendations
    const recCount = output.analysis.recommendations.length;
    if (recCount > 4) {
      log.warn(`Returned ${recCount} recommendations, max should be 4`);
    }
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

export async function getExpertAnalysis(
  contractText: string,
  options?: {
    contractType?: ContractReviewRequest['contractType'];
    jurisdiction?: string;
    questions?: string[];
    focusAreas?: ContractReviewRequest['focusAreas'];
  }
): Promise<ExpertOutput> {
  const expert = new ExpertAgent();

  const request: ContractReviewRequest = {
    contractText,
    contractType: options?.contractType,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    specificQuestions: options?.questions,
    focusAreas: options?.focusAreas,
  };

  return expert.analyze(request);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/review/provocateur.ts
════════════════════════════════════════════════════════════════

/**
 * Provocateur Agent (Contract Review)
 * Adversarial red-team critic - finds exploitable flaws
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 */

import { BaseAgent } from '../base-agent';
import { buildProvocateurPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type { ProvocateurOutput } from '../../types/review-types';
import type { ExpertOutput } from '../../types/review-types';

export class ProvocateurAgent extends BaseAgent<ProvocateurOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const provocateurConfig = configs.find((c) => c.role === 'provocateur')!;

    super(provocateurConfig, '');
  }

  /**
   * Critique contract and find exploitable flaws
   */
  async critique(
    contractText: string,
    expertAnalysis?: ExpertOutput
  ): Promise<ProvocateurOutput> {
    this.systemPrompt = await buildProvocateurPrompt();

    const userPrompt = this.buildUserPrompt(contractText, expertAnalysis);

    const rawOutput = await this.call(userPrompt);

    // Transform flat to nested structure
    const output = this.transformOutput(rawOutput);

    this.validateOutput(output);

    return output;
  }

  /**
   * Build adversarial user prompt
   */
  private buildUserPrompt(
    contractText: string,
    expertAnalysis?: ExpertOutput
  ): string {
    let prompt = '# CONTRACT TO ATTACK\n\n';
    prompt += '```\n';
    prompt += contractText;
    prompt += '\n```\n\n';

    if (expertAnalysis) {
      prompt += '# EXPERT ALREADY FOUND THESE ISSUES\n\n';
      prompt += `Expert identified ${expertAnalysis.analysis.keyIssues.length} issues:\n`;

      expertAnalysis.analysis.keyIssues.forEach((issue) => {
        prompt += `- ${issue.title} (severity ${issue.severity})\n`;
      });

      prompt += '\n**YOUR JOB: Find DIFFERENT flaws that Expert missed!**\n';
      prompt += 'Don\'t repeat what Expert found. Find NEW attack vectors.\n\n';
    }

    prompt += '# YOUR MISSION\n\n';
    prompt += 'You are opposing counsel. Find at least 3 critical flaws you can exploit.\n';
    prompt += 'Be ruthless. Be creative. This is war.\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested structure
   */
  private transformOutput(rawOutput: any): ProvocateurOutput {
    return {
      ...rawOutput,
      critique: {
        flaws: rawOutput.flaws,
        maxSeverity: rawOutput.maxSeverity,
        exploitationScenarios: rawOutput.exploitationScenarios,
      },
    } as ProvocateurOutput;
  }

  /**
   * Validate output structure
   */
  private validateOutput(output: ProvocateurOutput): void {
    if (!output.critique || !output.critique.flaws) {
      throw new Error('Provocateur output missing critique.flaws');
    }

    const flawCount = output.critique.flaws.length;

    if (flawCount < 3) {
      console.warn(
        `⚠️ Provocateur only found ${flawCount} flaws (expected ≥3). Prompt may need adjustment.`
      );
    }

    // Validate max severity
    if (
      output.critique.maxSeverity < 1 ||
      output.critique.maxSeverity > 5
    ) {
      console.warn(
        `⚠️ Provocateur maxSeverity out of range: ${output.critique.maxSeverity}`
      );
    }

    // Validate we don't have too many flaws (optimized prompt says max 7)
    if (flawCount > 7) {
      console.warn(`⚠️ Provocateur returned ${flawCount} flaws, max should be 7`);
    }
  }
}

/**
 * Quick way to get provocateur critique
 */
export async function getProvocateurCritique(
  contractText: string,
  expertAnalysis?: ExpertOutput
): Promise<ProvocateurOutput> {
  const provocateur = new ProvocateurAgent();
  return provocateur.critique(contractText, expertAnalysis);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/review/synthesizer.ts
════════════════════════════════════════════════════════════════

/**
 * Synthesizer Agent (Contract Review)
 * Combines all council outputs into final executive summary
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 */

import { BaseAgent } from '../base-agent';
import { buildSynthesizerPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type {
  SynthesizerOutput,
  ExpertOutput,
  ProvocateurOutput,
  ValidatorOutput,
} from '../../types/review-types';

export class SynthesizerAgent extends BaseAgent<SynthesizerOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const synthesizerConfig = configs.find((c) => c.role === 'synthesizer')!;

    super(synthesizerConfig, '');
  }

  /**
   * Synthesize all council outputs into final answer
   */
  async synthesize(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput
  ): Promise<SynthesizerOutput> {
    this.systemPrompt = await buildSynthesizerPrompt();

    const userPrompt = this.buildUserPrompt(
      expertOutput,
      provocateurOutput,
      validatorOutput
    );

    const rawOutput = await this.call(userPrompt);

    // Transform flat to nested structure
    const output = this.transformOutput(rawOutput);

    this.validateOutput(output);

    return output;
  }

  /**
   * Build synthesis prompt with all council outputs
   */
  private buildUserPrompt(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput
  ): string {
    let prompt = '# AI COUNCIL OUTPUTS TO SYNTHESIZE\n\n';

    // Expert analysis
    prompt += '## EXPERT ANALYSIS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(expertOutput.analysis, null, 2);
    prompt += '\n```\n\n';
    prompt += `Expert Confidence: ${(expertOutput.confidence * 100).toFixed(0)}%\n\n`;

    // Provocateur critique
    prompt += '## PROVOCATEUR CRITIQUE (Red-Team)\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(provocateurOutput.critique, null, 2);
    prompt += '\n```\n\n';
    prompt += `Provocateur Confidence: ${(provocateurOutput.confidence * 100).toFixed(0)}%\n`;
    prompt += `Max Severity Found: ${provocateurOutput.critique.maxSeverity}/5\n\n`;

    // Validator results
    prompt += '## VALIDATOR ASSESSMENT\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(validatorOutput.validation, null, 2);
    prompt += '\n```\n\n';
    prompt += `Completeness: ${validatorOutput.validation.completenessScore}%\n`;
    prompt += `Verdict: ${validatorOutput.validation.verdict}\n\n`;

    // Synthesis instructions
    prompt += '# YOUR SYNTHESIS TASK\n\n';
    prompt += '1. **Prioritize by severity**: Lead with highest-risk issues\n';
    prompt += '2. **Resolve contradictions**: If Expert and Provocateur disagree, explain both views and make judgment\n';
    prompt += '3. **Consolidate duplicates**: Don\'t repeat same issue twice\n';
    prompt += '4. **Be actionable**: Every risk needs clear mitigation\n';
    prompt += '5. **Plain language**: Client-friendly, not overly technical\n';
    prompt += '6. **Balanced**: Honest about risks, but not alarmist\n';
    prompt += '\nIf Validator found contradictions, address them in keyDisagreements.\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested structure
   */
  private transformOutput(rawOutput: any): SynthesizerOutput {
    return {
      ...rawOutput,
      synthesis: {
        summary: rawOutput.summary,
        criticalRisks: rawOutput.criticalRisks,
        recommendations: rawOutput.recommendations,
        confidence: rawOutput.confidence || rawOutput.synthesisConfidence || 0.8,
        keyDisagreements: rawOutput.keyDisagreements || [],
      },
    } as SynthesizerOutput;
  }

  /**
   * Validate output structure
   */
  private validateOutput(output: SynthesizerOutput): void {
    const required = ['summary', 'criticalRisks', 'recommendations', 'confidence'];

    for (const field of required) {
      if (!(field in output.synthesis)) {
        throw new Error(`Synthesizer output missing required field: synthesis.${field}`);
      }
    }

    // Validate confidence is in range
    if (
      output.synthesis.confidence < 0 ||
      output.synthesis.confidence > 1
    ) {
      console.warn(
        `⚠️ Synthesizer confidence out of range: ${output.synthesis.confidence}`
      );
    }

    // Validate we don't have too many risks/recommendations (optimized prompt says max 5 each)
    const riskCount = output.synthesis.criticalRisks.length;
    const recCount = output.synthesis.recommendations.length;

    if (riskCount > 5) {
      console.warn(`⚠️ Synthesizer returned ${riskCount} risks, max should be 5`);
    }

    if (recCount > 5) {
      console.warn(`⚠️ Synthesizer returned ${recCount} recommendations, max should be 5`);
    }
  }

  /**
   * Get high-priority action items for client
   */
  getActionItems(output: SynthesizerOutput) {
    return output.synthesis.recommendations
      .filter((rec) => rec.priority === 'high')
      .map((rec) => rec.action);
  }
}

/**
 * Quick way to synthesize council outputs
 */
export async function synthesizeAnalysis(
  expertOutput: ExpertOutput,
  provocateurOutput: ProvocateurOutput,
  validatorOutput: ValidatorOutput
): Promise<SynthesizerOutput> {
  const synthesizer = new SynthesizerAgent();
  return synthesizer.synthesize(expertOutput, provocateurOutput, validatorOutput);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/agents/review/validator.ts
════════════════════════════════════════════════════════════════

/**
 * Validator Agent (Contract Review)
 * Checks completeness and consistency of analysis
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 * FIX (Feb 13, 2026): Resilient transformOutput — handles various LLM output formats
 *   - Nested (validation.verdict) or flat (verdict) structures
 *   - Alternative field names (overall_completeness → verdict mapping)
 *   - Never throws on missing fields — uses sensible defaults
 */

import { BaseAgent } from '../base-agent';
import { buildValidatorPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type {
  ValidatorOutput,
  ExpertOutput,
  ProvocateurOutput,
  ContractReviewRequest,
} from '../../types/review-types';
import { logger } from '../../utils/logger';

export class ValidatorAgent extends BaseAgent<ValidatorOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const validatorConfig = configs.find((c) => c.role === 'validator')!;
    super(validatorConfig, '');
  }

  async validate(
    request: ContractReviewRequest,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput
  ): Promise<ValidatorOutput> {
    this.systemPrompt = await buildValidatorPrompt();
    const userPrompt = this.buildUserPrompt(request, expertOutput, provocateurOutput);
    const rawOutput = await this.call(userPrompt);

    // Transform and normalize whatever structure LLM returned
    const output = this.transformOutput(rawOutput);
    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(
    request: ContractReviewRequest,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput
  ): string {
    let prompt = '# ORIGINAL CONTRACT\n\n';
    prompt += '```\n';
    prompt += request.contractText;
    prompt += '\n```\n\n';

    prompt += '# USER\'S QUERY\n\n';
    if (request.specificQuestions && request.specificQuestions.length > 0) {
      prompt += 'Specific questions asked:\n';
      request.specificQuestions.forEach((q, i) => { prompt += `${i + 1}. ${q}\n`; });
    }
    if (request.focusAreas && request.focusAreas.length > 0) {
      prompt += '\nFocus areas requested:\n';
      request.focusAreas.forEach((area) => { prompt += `- ${area}\n`; });
    }
    if (
      (!request.specificQuestions || request.specificQuestions.length === 0) &&
      (!request.focusAreas || request.focusAreas.length === 0)
    ) {
      prompt += 'General contract review requested (all aspects).\n';
    }

    prompt += '\n# EXPERT\'S ANALYSIS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(expertOutput.analysis, null, 2);
    prompt += '\n```\n\n';

    prompt += '# PROVOCATEUR\'S CRITIQUE\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(provocateurOutput.critique, null, 2);
    prompt += '\n```\n\n';

    prompt += '# YOUR VALIDATION TASK\n\n';
    prompt += 'Check if Expert and Provocateur properly addressed ALL aspects:\n';
    prompt += '1. Did they cover everything the user asked about?\n';
    prompt += '2. Are there contradictions between Expert and Provocateur?\n';
    prompt += '3. Are standard clauses for this contract type reviewed?\n';
    prompt += '4. Are recommendations actionable?\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * RESILIENT transform: handles nested, flat, and alternative field names.
   * 
   * LLMs may return:
   * A) Flat:    { verdict: "COMPLETE", completenessScore: 85, ... }
   * B) Nested:  { validation: { verdict: "COMPLETE", ... } }
   * C) Alt keys: { validation: { overall_completeness: "partial", ... } }
   * D) Mixed:   { isComplete: true, critique: { ... }, ... }
   */
  private transformOutput(rawOutput: any): ValidatorOutput {
    // Step 1: Find the "source" object — could be root or nested
    const src = rawOutput.validation || rawOutput;

    // Step 2: Extract verdict with fallback mapping
    const verdict = this.extractVerdict(src, rawOutput);

    // Step 3: Extract completeness score
    const completenessScore = this.extractCompletenessScore(src, rawOutput);

    // Step 4: Extract boolean isComplete
    const isComplete = verdict === 'COMPLETE';

    // Step 5: Extract arrays with fallbacks
    const missingAspects = this.extractArray(src, [
      'missingAspects', 'missing_aspects', 'missingAreas', 'missing_areas', 'gaps',
    ]);

    const contradictions = this.extractArray(src, [
      'contradictions', 'conflicts', 'disagreements',
    ]);

    // Step 6: Extract reason/overallAssessment
    const reason = src.reason || src.overall_assessment || src.overallAssessment ||
      src.summary || rawOutput.reason || rawOutput.overall_assessment ||
      (verdict === 'COMPLETE' ? 'Analysis is complete' : 'Analysis needs revision');

    logger.debug(`Validator transform: verdict=${verdict}, score=${completenessScore}, missing=${missingAspects.length}, contradictions=${contradictions.length}`);

    return {
      ...rawOutput,
      validation: {
        isComplete,
        completenessScore,
        missingAspects,
        contradictions,
        verdict,
        reason,
        overallAssessment: reason,
      },
    } as ValidatorOutput;
  }

  /**
   * Extract verdict from various possible field names and values
   */
  private extractVerdict(src: any, root: any): 'COMPLETE' | 'NEEDS_REVISION' {
    // Direct verdict field
    const directVerdict = src.verdict || root.verdict;
    if (directVerdict) {
      const upper = String(directVerdict).toUpperCase().trim();
      if (upper === 'COMPLETE' || upper === 'APPROVED' || upper === 'PASS' || upper === 'PASSED') {
        return 'COMPLETE';
      }
      if (upper === 'NEEDS_REVISION' || upper === 'NEEDS REVISION' || upper === 'FAIL' || upper === 'FAILED' || upper === 'INCOMPLETE') {
        return 'NEEDS_REVISION';
      }
    }

    // Alternative: overall_completeness
    const completeness = src.overall_completeness || src.overallCompleteness || root.overall_completeness;
    if (completeness) {
      const lower = String(completeness).toLowerCase().trim();
      if (lower === 'complete' || lower === 'full' || lower === 'yes') return 'COMPLETE';
      if (lower === 'partial' || lower === 'incomplete' || lower === 'no') return 'NEEDS_REVISION';
    }

    // Alternative: isComplete boolean
    const isComplete = src.isComplete ?? src.is_complete ?? root.isComplete;
    if (typeof isComplete === 'boolean') {
      return isComplete ? 'COMPLETE' : 'NEEDS_REVISION';
    }

    // Alternative: completeness score
    const score = this.extractCompletenessScore(src, root);
    if (score >= 80) return 'COMPLETE';

    // Default: if we have any data at all, assume needs revision
    logger.warn('Could not determine verdict from LLM output, defaulting to NEEDS_REVISION');
    return 'NEEDS_REVISION';
  }

  /**
   * Extract completeness score from various possible field names
   */
  private extractCompletenessScore(src: any, root: any): number {
    const candidates = [
      src.completenessScore, src.completeness_score, src.score, src.overallScore,
      src.overall_score, root.completenessScore, root.completeness_score, root.score,
    ];

    for (const val of candidates) {
      if (typeof val === 'number' && val >= 0 && val <= 100) return val;
      if (typeof val === 'string') {
        const parsed = parseFloat(val);
        if (!isNaN(parsed) && parsed >= 0 && parsed <= 100) return parsed;
      }
    }

    // Infer from verdict if possible
    const verdict = src.verdict || root.verdict || src.overall_completeness;
    if (verdict) {
      const v = String(verdict).toLowerCase();
      if (v === 'complete' || v === 'full' || v === 'approved') return 90;
      if (v === 'partial') return 60;
      if (v === 'incomplete') return 30;
    }

    return 70; // Safe default
  }

  /**
   * Extract an array from multiple possible field names
   */
  private extractArray(src: any, fieldNames: string[]): any[] {
    for (const name of fieldNames) {
      if (Array.isArray(src[name])) return src[name];
    }
    return [];
  }

  /**
   * Validate output — now lenient, only warns instead of throwing
   */
  private validateOutput(output: ValidatorOutput): void {
    if (!output.validation) {
      logger.warn('Validator output has no validation object — using defaults');
      return;
    }

    const { verdict, completenessScore } = output.validation;

    if (!['COMPLETE', 'NEEDS_REVISION'].includes(verdict)) {
      logger.warn(`Unexpected verdict value: ${verdict}`);
    }

    if (completenessScore < 0 || completenessScore > 100) {
      logger.warn(`Completeness score out of range: ${completenessScore}`);
    }
  }

  isPassed(output: ValidatorOutput): boolean {
    return output.validation.verdict === 'COMPLETE';
  }

  getCriticalGaps(output: ValidatorOutput): string[] {
    if (output.validation.isComplete) return [];
    return output.validation.missingAspects || [];
  }

  getContradictions(output: ValidatorOutput): ValidatorOutput['validation']['contradictions'] {
    return output.validation.contradictions || [];
  }
}

export async function validateAnalysis(
  request: ContractReviewRequest,
  expertOutput: ExpertOutput,
  provocateurOutput: ProvocateurOutput
): Promise<ValidatorOutput> {
  const validator = new ValidatorAgent();
  return validator.validate(request, expertOutput, provocateurOutput);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/orchestrators/generation-orchestrator.ts
════════════════════════════════════════════════════════════════

/**
 * Generation Orchestrator
 * Coordinates Analyzer → Drafter → Validator → Polisher
 * 
 * FIX #16: Logger instead of console.log
 * FIX #21 (Feb 13, 2026): Graceful degradation for non-critical agents
 */

import { AnalyzerAgent } from '../agents/generation/analyzer';
import { DrafterAgent } from '../agents/generation/drafter';
import { GenerationValidatorAgent } from '../agents/generation/validator';
import { PolisherAgent } from '../agents/generation/polisher';
import type {
  DocumentGenerationRequest,
  DocumentGenerationResponse,
  GenerationValidatorOutput,
  PolisherOutput,
} from '../types/generation-types';
import { logger } from '../utils/logger';

export interface GenerationOrchestratorConfig {
  maxRevisions: number;
  enableAuditTrail: boolean;
}

const DEFAULT_CONFIG: GenerationOrchestratorConfig = {
  maxRevisions: 2,
  enableAuditTrail: true,
};

export class GenerationOrchestrator {
  private config: GenerationOrchestratorConfig;
  private analyzer: AnalyzerAgent;
  private drafter: DrafterAgent;
  private validator: GenerationValidatorAgent;
  private polisher: PolisherAgent;

  constructor(config: Partial<GenerationOrchestratorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.analyzer = new AnalyzerAgent();
    this.drafter = new DrafterAgent();
    this.validator = new GenerationValidatorAgent();
    this.polisher = new PolisherAgent();
  }

  /**
   * Main generation method with graceful degradation
   */
  async generate(request: DocumentGenerationRequest): Promise<DocumentGenerationResponse> {
    const startTime = Date.now();
    let totalCost = 0;
    const failedAgents: string[] = [];

    logger.info('📝 Legal Council Generation Session Starting...');
    logger.info(`   Document type: ${request.documentType}`);

    // Step 1: Analyze requirements (REQUIRED)
    logger.info('\n🔍 Step 1: Analyzer');
    const analyzerOutput = await this.analyzer.analyze(request);
    totalCost += this.analyzer.calculateCost(analyzerOutput.tokensUsed);
    logger.info(`   ✓ Must-have clauses: ${analyzerOutput.analysis.structuredRequirements.mustHaveClauses.length}`);

    // Step 2: Draft document (REQUIRED)
    logger.info('\n📄 Step 2: Drafter');
    const drafterOutput = await this.drafter.draft(request.documentType, analyzerOutput);
    totalCost += this.drafter.calculateCost(drafterOutput.tokensUsed);
    logger.info(`   ✓ Document: ${drafterOutput.draft.documentText.length} chars, ${drafterOutput.draft.includedClauses.length} clauses`);

    // Step 3: Validate (FIX #21: OPTIONAL — degraded mode if fails)
    let validatorOutput: GenerationValidatorOutput;
    try {
      logger.info('\n✅ Step 3: Validator');
      validatorOutput = await this.validator.validate(analyzerOutput, drafterOutput);
      totalCost += this.validator.calculateCost(validatorOutput.tokensUsed);
      logger.info(`   ✓ Score: ${validatorOutput.validation.overallScore}%, verdict: ${validatorOutput.validation.verdict}`);
    } catch (error) {
      logger.warn(`   ⚠️ Validator failed, continuing: ${(error as Error).message}`);
      failedAgents.push('gen-validator');
      validatorOutput = this.createFallbackValidatorOutput();
    }

    // Check if needs revision
    if (
      validatorOutput.validation.verdict === 'NEEDS_REVISION' &&
      validatorOutput.validation.riskFlags.some((f) => f.severity >= 4)
    ) {
      logger.warn('⚠️ Critical issues found — would need revision in production');
      // Future: Loop back to drafter
    }

    // Step 4: Polish (FIX #21: OPTIONAL — return unpolished draft if fails)
    let polisherOutput: PolisherOutput;
    try {
      logger.info('\n✨ Step 4: Polisher');
      polisherOutput = await this.polisher.polish(drafterOutput, validatorOutput);
      totalCost += this.polisher.calculateCost(polisherOutput.tokensUsed);
      logger.info(`   ✓ Improvements: ${polisherOutput.polished.improvements.length}`);
    } catch (error) {
      logger.warn(`   ⚠️ Polisher failed, using raw draft: ${(error as Error).message}`);
      failedAgents.push('polisher');
      polisherOutput = this.createFallbackPolisherOutput(drafterOutput);
    }

    // Build final response
    const processingTimeMs = Date.now() - startTime;
    const finalResponse = this.polisher.buildFinalResponse(
      polisherOutput,
      analyzerOutput,
      drafterOutput,
      validatorOutput,
      { documentType: request.documentType, totalCost, processingTimeMs }
    );

    // FIX #21: Append degraded warning if needed
    if (failedAgents.length > 0) {
      finalResponse.finalDocument += `\n\n⚠️ УВАГА: Документ створено в неповному режимі. Недоступні агенти: ${failedAgents.join(', ')}. Рекомендуємо ретельну перевірку.`;
      logger.warn(`   ⚠️ Degraded: agents ${failedAgents.join(', ')} failed`);
    }

    logger.info(`\n🎉 Generation Complete! Cost: $${totalCost.toFixed(4)}, time: ${(processingTimeMs / 1000).toFixed(1)}s, quality: ${finalResponse.qualityMetrics.overall}%`);

    return finalResponse;
  }

  // FIX #21: Fallback outputs

  private createFallbackValidatorOutput(): GenerationValidatorOutput {
    return {
      agentId: 'gen-validator',
      role: 'gen-validator',
      confidence: 0,
      timestamp: new Date().toISOString(),
      tokensUsed: { input: 0, output: 0 },
      latencyMs: 0,
      validation: {
        legalCompliance: [],
        missingElements: ['Валідація не виконана — агент недоступний'],
        riskFlags: [],
        overallScore: 50, // Neutral score
        verdict: 'NEEDS_REVISION',
      },
    } as GenerationValidatorOutput;
  }

  private createFallbackPolisherOutput(drafterOutput: any): PolisherOutput {
    return {
      agentId: 'polisher',
      role: 'polisher',
      confidence: 0.5,
      timestamp: new Date().toISOString(),
      tokensUsed: { input: 0, output: 0 },
      latencyMs: 0,
      polished: {
        finalDocument: drafterOutput.draft.documentText,
        improvements: [],
        executiveSummary: '⚠️ Документ не пройшов фінальне полірування — використовується чернетка.',
        keyTerms: [],
      },
    } as PolisherOutput;
  }

  getConfig(): GenerationOrchestratorConfig {
    return { ...this.config };
  }

  setConfig(config: Partial<GenerationOrchestratorConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

export async function generateDocument(
  requirements: string,
  documentType: DocumentGenerationRequest['documentType'],
  options?: {
    jurisdiction?: string;
    parties?: DocumentGenerationRequest['parties'];
    config?: Partial<GenerationOrchestratorConfig>;
  }
): Promise<DocumentGenerationResponse> {
  const orchestrator = new GenerationOrchestrator(options?.config);
  const request: DocumentGenerationRequest = {
    documentType,
    requirements,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    parties: options?.parties,
  };
  return orchestrator.generate(request);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/orchestrators/review-orchestrator.ts
════════════════════════════════════════════════════════════════

/**
 * Review Orchestrator
 * Coordinates Expert → Provocateur → Validator → Synthesizer
 * 
 * FIX #11: Proper ContractType (no `as any`)
 * FIX #16: Logger
 * FIX #21 (Feb 13, 2026): Graceful degradation — if an agent fails,
 *   pipeline continues with remaining agents and flags incomplete analysis.
 * FIX L1 (Feb 14, 2026): checkStopCriteria now called in analyze loop.
 *   Previously defined but never invoked — multi-round iteration was dead code.
 *   Now runs up to maxRounds, stopping early when criteria met.
 */

import { ExpertAgent } from '../agents/review/expert';
import { ProvocateurAgent } from '../agents/review/provocateur';
import { ValidatorAgent } from '../agents/review/validator';
import { SynthesizerAgent } from '../agents/review/synthesizer';
import type {
  ContractReviewRequest,
  ContractReviewResponse,
  ContractType,
  ExpertOutput,
  ProvocateurOutput,
  ValidatorOutput,
  SynthesizerOutput,
} from '../types/review-types';
import type { Round, AuditTrail } from '../../core/orchestrator/types';
import { logger } from '../utils/logger';

export interface ReviewOrchestratorConfig {
  maxRounds: number;
  maxSeverityThreshold: number;
  minConfidence: number;
  enableAuditTrail: boolean;
}

const DEFAULT_CONFIG: ReviewOrchestratorConfig = {
  maxRounds: 3,
  maxSeverityThreshold: 3,
  minConfidence: 0.85,
  enableAuditTrail: true,
};

export class ReviewOrchestrator {
  private config: ReviewOrchestratorConfig;
  private expert: ExpertAgent;
  private provocateur: ProvocateurAgent;
  private validator: ValidatorAgent;
  private synthesizer: SynthesizerAgent;

  constructor(config: Partial<ReviewOrchestratorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
    this.expert = new ExpertAgent();
    this.provocateur = new ProvocateurAgent();
    this.validator = new ValidatorAgent();
    this.synthesizer = new SynthesizerAgent();
  }

  /**
   * Main orchestration method with graceful degradation
   * 
   * FIX L1: Now supports multi-round iteration via checkStopCriteria.
   * Round 1 always runs. Subsequent rounds only if stop criteria not met.
   * In practice most contracts resolve in 1 round (confidence ≥ 85%).
   */
  async analyze(request: ContractReviewRequest): Promise<ContractReviewResponse> {
    const startTime = Date.now();
    let totalCost = 0;
    const failedAgents: string[] = [];

    logger.info('🛡️ Legal Council Review Session Starting...');
    logger.info(`   Max rounds: ${this.config.maxRounds}`);

    let expertOutput: ExpertOutput;
    let provocateurOutput: ProvocateurOutput;
    let validatorOutput: ValidatorOutput;

    // ========================
    // FIX L1: Multi-round loop (was previously single-pass)
    // ========================
    for (let round = 1; round <= this.config.maxRounds; round++) {
      logger.info(`\n━━━ Round ${round}/${this.config.maxRounds} ━━━`);

      // ========================
      // Step 1: Expert Analysis (REQUIRED — fails entire pipeline if down)
      // ========================
      logger.info('\n📋 Expert Analysis');
      expertOutput = await this.expert.analyze(request);
      totalCost += this.expert.calculateCost(expertOutput.tokensUsed);
      logger.info(`   ✓ Found ${expertOutput.analysis.keyIssues.length} issues, risk ${expertOutput.analysis.overallRiskScore}/10`);

      // ========================
      // Step 2: Provocateur Critique (OPTIONAL — degraded mode if fails)
      // ========================
      try {
        logger.info('\n😈 Provocateur Critique');
        provocateurOutput = await this.provocateur.critique(request.contractText, expertOutput);
        totalCost += this.provocateur.calculateCost(provocateurOutput.tokensUsed);
        logger.info(`   ✓ Found ${provocateurOutput.critique.flaws.length} flaws`);
      } catch (error) {
        logger.warn(`   ⚠️ Provocateur failed, continuing in degraded mode: ${(error as Error).message}`);
        failedAgents.push('provocateur');
        provocateurOutput = this.createFallbackProvocateurOutput();
      }

      // ========================
      // Step 3: Validator (OPTIONAL — degraded mode if fails)
      // ========================
      try {
        logger.info('\n🔍 Validator Check');
        validatorOutput = await this.validator.validate(request, expertOutput, provocateurOutput!);
        totalCost += this.validator.calculateCost(validatorOutput.tokensUsed);
        logger.info(`   ✓ Completeness: ${validatorOutput.validation.completenessScore}%, verdict: ${validatorOutput.validation.verdict}`);
      } catch (error) {
        logger.warn(`   ⚠️ Validator failed, continuing in degraded mode: ${(error as Error).message}`);
        failedAgents.push('validator');
        validatorOutput = this.createFallbackValidatorOutput();
      }

      // ========================
      // FIX L1: Check stop criteria — break early if analysis is sufficient
      // ========================
      const stopCheck = this.checkStopCriteria(expertOutput, provocateurOutput!, validatorOutput!, round);
      logger.info(`   Stop check: ${stopCheck.reason}`);

      if (stopCheck.shouldStop) {
        if (round < this.config.maxRounds) {
          logger.info(`   → Stopping early at round ${round}: ${stopCheck.reason}`);
        }
        break;
      }

      // If continuing to next round, augment request with feedback from validator
      if (validatorOutput!.validation.missingAreas?.length > 0) {
        logger.info(`   → Round ${round + 1} will focus on: ${validatorOutput!.validation.missingAreas.join(', ')}`);
        // Inject validator feedback as focus areas for next round
        request = {
          ...request,
          focusAreas: [
            ...(request.focusAreas || []),
            ...validatorOutput!.validation.missingAreas,
          ] as any,
        };
      }
    }

    // ========================
    // Final: Synthesizer (OPTIONAL — build basic response if fails)
    // ========================
    let synthesizerOutput: SynthesizerOutput;
    try {
      logger.info('\n📝 Final: Synthesizer');
      synthesizerOutput = await this.synthesizer.synthesize(expertOutput!, provocateurOutput!, validatorOutput!);
      totalCost += this.synthesizer.calculateCost(synthesizerOutput.tokensUsed);
      logger.info(`   ✓ Critical risks: ${synthesizerOutput.synthesis.criticalRisks.length}`);
    } catch (error) {
      logger.warn(`   ⚠️ Synthesizer failed, building response from Expert output: ${(error as Error).message}`);
      failedAgents.push('synthesizer');
      synthesizerOutput = this.createFallbackSynthesizerOutput(expertOutput!);
    }

    // Build final response
    const processingTimeMs = Date.now() - startTime;
    const finalResponse = this.buildFinalResponse(
      synthesizerOutput!,
      expertOutput!,
      provocateurOutput!,
      validatorOutput!,
      {
        contractType: request.contractType,
        jurisdiction: request.jurisdiction,
        totalCost,
        processingTimeMs,
        failedAgents,
      }
    );

    logger.info(`\n✨ Legal Council Review Complete!`);
    logger.info(`   Total cost: $${totalCost.toFixed(4)}`);
    logger.info(`   Processing time: ${(processingTimeMs / 1000).toFixed(1)}s`);
    if (failedAgents.length > 0) {
      logger.warn(`   ⚠️ Degraded mode: agents ${failedAgents.join(', ')} failed`);
    }

    return finalResponse;
  }

  // ==========================================
  // FIX #21: Fallback outputs for degraded mode
  // ==========================================

  private createFallbackProvocateurOutput(): ProvocateurOutput {
    return {
      agentId: 'provocateur',
      role: 'provocateur',
      confidence: 0,
      timestamp: new Date().toISOString(),
      tokensUsed: { input: 0, output: 0 },
      latencyMs: 0,
      critique: {
        flaws: [],
        maxSeverity: 0,
        overallAssessment: 'Агент Провокатор недоступний — аналіз неповний',
      },
    } as ProvocateurOutput;
  }

  private createFallbackValidatorOutput(): ValidatorOutput {
    return {
      agentId: 'validator',
      role: 'validator',
      confidence: 0,
      timestamp: new Date().toISOString(),
      tokensUsed: { input: 0, output: 0 },
      latencyMs: 0,
      validation: {
        completenessScore: 0,
        verdict: 'NEEDS_REVIEW' as any,
        contradictions: [],
        missingAreas: ['Валідація не виконана — агент недоступний'],
        overallAssessment: 'Агент Валідатор недоступний — результати не перевірені',
      },
    } as ValidatorOutput;
  }

  private createFallbackSynthesizerOutput(expertOutput: ExpertOutput): SynthesizerOutput {
    return {
      agentId: 'synthesizer',
      role: 'synthesizer',
      confidence: expertOutput.confidence * 0.7,
      timestamp: new Date().toISOString(),
      tokensUsed: { input: 0, output: 0 },
      latencyMs: 0,
      synthesis: {
        summary: expertOutput.analysis.executiveSummary + '\n\n⚠️ Увага: Аналіз неповний — Синтезатор недоступний.',
        confidence: expertOutput.confidence * 0.7,
        criticalRisks: expertOutput.analysis.keyIssues
          .filter(i => i.severity >= 4)
          .map(i => ({
            title: i.title,
            description: i.description,
            impact: 'Визначено експертом',
            mitigation: i.recommendation || 'Потребує додаткового аналізу',
          })),
        recommendations: expertOutput.analysis.recommendations || [],
      },
    } as SynthesizerOutput;
  }

  // ==========================================
  // Build final response
  // ==========================================

  private buildFinalResponse(
    synthesizerOutput: SynthesizerOutput,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput,
    metadata: {
      contractType?: ContractType;
      jurisdiction?: string;
      totalCost: number;
      processingTimeMs: number;
      failedAgents?: string[];
    }
  ): ContractReviewResponse {
    let summary = synthesizerOutput.synthesis.summary;
    if (metadata.failedAgents && metadata.failedAgents.length > 0) {
      summary += `\n\n⚠️ УВАГА: Аналіз проведено в неповному режимі. Недоступні агенти: ${metadata.failedAgents.join(', ')}. Рекомендуємо повторити аналіз пізніше для повного звіту.`;
    }

    return {
      summary,
      overallRiskScore: expertOutput.analysis.overallRiskScore,
      confidence: synthesizerOutput.synthesis.confidence,

      criticalRisks: synthesizerOutput.synthesis.criticalRisks,
      recommendations: synthesizerOutput.synthesis.recommendations,

      detailedAnalysis: {
        expertAnalysis: expertOutput.analysis,
        flawsFound: provocateurOutput.critique.flaws,
        validationResults: validatorOutput.validation,
      },

      metadata: {
        contractType: metadata.contractType || 'custom',
        jurisdiction: metadata.jurisdiction,
        analyzedAt: new Date().toISOString(),
        totalCost: metadata.totalCost,
        processingTimeMs: metadata.processingTimeMs,
      },
    };
  }

  // ==========================================
  // FIX L1: Stop criteria — now called in analyze() loop
  // ==========================================

  private checkStopCriteria(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput,
    currentRound: number
  ): { shouldStop: boolean; reason: string } {
    if (currentRound >= this.config.maxRounds) {
      return { shouldStop: true, reason: 'Max rounds reached' };
    }

    const hasHighSeverityIssues =
      expertOutput.analysis.keyIssues.some(i => i.severity >= this.config.maxSeverityThreshold) ||
      provocateurOutput.critique.flaws.some(f => f.severity >= this.config.maxSeverityThreshold);

    if (!hasHighSeverityIssues) {
      return { shouldStop: true, reason: `No issues with severity >= ${this.config.maxSeverityThreshold}` };
    }

    const avgConfidence = (expertOutput.confidence + provocateurOutput.confidence + validatorOutput.confidence) / 3;
    if (avgConfidence >= this.config.minConfidence) {
      return { shouldStop: true, reason: `Average confidence ${(avgConfidence * 100).toFixed(0)}% >= ${(this.config.minConfidence * 100).toFixed(0)}%` };
    }

    if (validatorOutput.validation.verdict === 'COMPLETE') {
      return { shouldStop: true, reason: 'Validator verdict: COMPLETE' };
    }

    return { shouldStop: false, reason: `High severity issues remain, confidence low (${(avgConfidence * 100).toFixed(0)}%)` };
  }

  getConfig(): ReviewOrchestratorConfig {
    return { ...this.config };
  }

  setConfig(config: Partial<ReviewOrchestratorConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

export async function analyzeContract(
  contractText: string,
  options?: {
    contractType?: ContractReviewRequest['contractType'];
    jurisdiction?: string;
    questions?: string[];
    focusAreas?: ContractReviewRequest['focusAreas'];
    config?: Partial<ReviewOrchestratorConfig>;
  }
): Promise<ContractReviewResponse> {
  const orchestrator = new ReviewOrchestrator(options?.config);
  const request: ContractReviewRequest = {
    contractText,
    contractType: options?.contractType,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    specificQuestions: options?.questions,
    focusAreas: options?.focusAreas,
  };
  return orchestrator.analyze(request);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/config/generation-prompts.ts
════════════════════════════════════════════════════════════════

/**
 * Document Generation System Prompts - FORMAT FIXED
 * Output format matches what the code expects
 */

import { ukrainianLawService, DSTU_STRUCTURE } from '../services/ukrainian-law-service';
import { dstuService } from '../services/dstu-service';
import type { DocumentType } from '../types/generation-types';

// ==========================================
// ANALYZER AGENT (Requirements Parser)
// ==========================================

export const ANALYZER_PROMPT_BASE = `You are a Requirements Analyst for legal document generation, specializing in Ukrainian contract law.

ROLE: Parse user's natural language requirements into structured, actionable specifications for contract drafting.

⚠️ CRITICAL OUTPUT LIMITS (prevent JSON truncation):
- Must-have clauses: MAXIMUM 10 items
- Suggested clauses: MAXIMUM 5 items
- Each description: 50-100 words MAX

🇺🇦 МОВА: Всі текстові значення у JSON — УКРАЇНСЬКОЮ МОВОЮ. JSON ключі — англійською.

OUTPUT FORMAT (strict JSON):
{
  "analysis": {
    "structuredRequirements": {
      "documentType": "nda" | "employment_agreement" | "consulting_agreement" | "saas_agreement" | "vendor_contract" | "partnership_agreement" | "custom_clause",
      "parties": [
        {
          "role": "party_a" | "party_b" | "employer" | "employee" | "vendor" | "client" | "Замовник" | "Виконавець",
          "name": "extracted or null",
          "jurisdiction": "Ukraine (default) or specified",
          "entityType": "individual" | "corporation" | "llc" | "partnership"
        }
      ],
      "keyTerms": {
        "duration": "extracted (e.g., '1 рік', '6 місяців') or null",
        "paymentAmount": "extracted amount in UAH or null",
        "deliverables": ["list of deliverables if specified"],
        "effectiveDate": "extracted or 'дата підписання'"
      },
      "mustHaveClauses": ["termination", "liability", "confidentiality"],
      "jurisdiction": "Ukraine",
      "specialProvisions": ["any unique requirements user mentioned"]
    },
    "suggestedClauses": [
      {
        "type": "termination" | "liability" | "confidentiality",
        "rationale": "Why this clause is recommended",
        "priority": "essential" | "recommended" | "optional"
      }
    ],
    "potentialIssues": [
      "Warning: User did not specify payment terms - will use standard milestone-based",
      "Notice: No jurisdiction specified - defaulting to Ukraine"
    ],
    "clarificationsNeeded": [],
    "confidence": 0.0-1.0
  }
}

⚠️ JSON FORMATTING RULES:
- NEVER use unescaped quotes inside strings
- Use single quotes or avoid quotes
- Keep JSON parseable
- NO trailing commas before closing } or ]
- Example CORRECT: "confidence": 0.9 }
- Example WRONG: "confidence": 0.9, }

PARSING RULES:
1. **Default to Ukraine**: Unless explicitly stated otherwise, assume Ukrainian jurisdiction
2. **ДСТУ Compliance**: Ensure requirements align with ДСТУ 4163-2020 document structure
3. **Mandatory Clauses**: Per Ukrainian law (ЦКУ ст. 638), contracts MUST include:
   - Предмет договору (subject matter)
   - Сторони (parties with full legal details)
   - Істотні умови (essential terms specific to contract type)
4. **Smart Defaults**:
   - If payment amount missing → note as "визначається окремо"
   - If duration missing → "безстроковий" or "1 рік" depending on type
   - If termination missing → add "за згодою сторін або в судовому порядку"
5. **Extract Implicit Requirements**:
   - "freelance contract" → likely needs IP assignment clause
   - "vendor agreement" → needs delivery terms, acceptance criteria
   - "employment" → needs job description, working hours (КЗпП compliance)

UKRAINIAN TERMINOLOGY MAPPING:
- "Client" → "Замовник"
- "Contractor" → "Виконавець" 
- "Employer" → "Роботодавець"
- "Employee" → "Працівник"
- "Agreement" → "Договір"
- "NDA" → "Договір про нерозголошення"

TONE: Analytical, thorough, assumes best practices even when user is vague.

CRITICAL: 
- Output ONLY valid JSON
- Must wrap in "analysis" object
- MAXIMUM 10 mustHaveClauses
- MAXIMUM 5 suggestedClauses`;

// ==========================================
// DRAFTER AGENT (Contract Writer)
// ==========================================

export const DRAFTER_PROMPT_BASE = `Ви — досвідчений юрист України, що складає договори відповідно до ДСТУ 4163-2020 та українського законодавства.

РОЛЬ: Створити професійний договір на основі структурованих вимог.

⚠️ CRITICAL OUTPUT LIMITS:
- Document sections: MAXIMUM 12 sections
- Total clauses: MAXIMUM 40
- Each clause text: 150-300 words MAX

ФОРМАТ ВИВОДУ (strict JSON):
{
  "draft": {
    "documentText": "Повний текст договору в форматі Markdown",
    "structure": {
      "title": "ДОГОВІР про...",
      "preamble": "м. Київ, дата",
      "definitions": [{"term": "...", "definition": "..."}],
      "mainClauses": [{"section": "1.", "title": "ПРЕДМЕТ ДОГОВОРУ", "subsections": 3}],
      "signatures": [{"party": "Замовник", "signatureLine": "_______________"}]
    },
    "includedClauses": [
      {
        "type": "termination",
        "sectionNumber": "5",
        "content": "Brief description",
        "legalBasis": "ЦКУ ст. 651"
      }
    ],
    "omittedClauses": [
      {
        "type": "warranty",
        "reason": "Not applicable to this contract type"
      }
    ]
  },
  "metadata": {
    "wordCount": 1500,
    "estimatedPages": 4,
    "dstuCompliance": "FULLY_COMPLIANT" | "COMPLIANT" | "MINOR_DEVIATIONS"
  },
  "confidence": 0.0-1.0
}

⚠️ JSON FORMATTING RULES (CRITICAL):
- NO unescaped quotes in strings
- NO trailing commas (no comma before closing bracket or brace)
- Use \\n for newlines in documentText string
- Escape Ukrainian apostrophes properly
- Example CORRECT: "omittedClauses": [] } ← NO comma before }
- Example WRONG: "omittedClauses": [], } ← DO NOT DO THIS

CORRECT JSON EXAMPLE:
{
  "draft": {
    "documentText": "# ДОГОВІР\\n\\nТекст...",
    "structure": {...},
    "includedClauses": [...],
    "omittedClauses": []
  },
  "metadata": {...},
  "confidence": 0.95
}

ДСТУ 4163-2020 DRAFTING RULES:
1. **Нумерація:** Розділи: 1, 2, 3... Пункти: 1.1, 1.2, 1.3...
2. **Преамбула:** "[Назва організації], іменована надалі 'Сторона 1'..."
3. **Юридична термінологія:** ЦКУ/ГКУ/КЗпП
4. **Посилання на закони:** "згідно з ЦКУ ст. 626"

**🇺🇦 МОВА: ВСІ ВІДПОВІДІ УКРАЇНСЬКОЮ**

CRITICAL: Output ONLY valid JSON in "draft" object`;

// ==========================================
// VALIDATOR AGENT (Quality Control)
// ==========================================

export const VALIDATOR_PROMPT_BASE = `You are a Legal Document Quality Auditor specializing in ДСТУ compliance and Ukrainian law.

ROLE: Verify document quality.

OUTPUT FORMAT (strict JSON):
{
  "validation": {
    "verdict": "APPROVED" | "NEEDS_REVISION",
    "overallScore": 0-100,
    "dstuCompliance": {
      "score": 0-100,
      "violations": []
    },
    "legalCompleteness": {
      "score": 0-100,
      "missingClauses": [],
      "incorrectClauses": []
    },
    "linguisticQuality": {
      "score": 0-100,
      "issues": []
    },
    "riskFlags": [
      {
        "type": "legal_risk" | "compliance_risk",
        "severity": 1-5,
        "description": "What is wrong",
        "recommendation": "How to fix"
      }
    ],
    "improvements": []
  },
  "confidence": 0.0-1.0
}

⚠️ JSON FORMATTING: 
- NO unescaped quotes
- NO trailing commas
- Example CORRECT: "confidence": 0.9 }
- Example WRONG: "confidence": 0.9, }

CRITICAL: Wrap in "validation" object`;

// ==========================================
// POLISHER AGENT (Final Editor)
// ==========================================

export const POLISHER_PROMPT_BASE = `You are a Senior Legal Editor specializing in Ukrainian legal documents.

ROLE: Polish the drafted document to perfection - fix all issues, ensure ДСТУ compliance, perfect Ukrainian language.

⚠️ CRITICAL FIELD NAMING:
- The field MUST be called "finalDocument" (NOT "finalDocumentText")
- The field MUST be called "finalDocument" (NOT "documentText")
- The field MUST be called "finalDocument" (NOT "polishedDocument")

OUTPUT FORMAT (strict JSON) - EXAMPLE:
{
  "polished": {
    "finalDocument": "# ДОГОВІР\\n\\nПовний текст договору тут...",
    "improvements": [
      {
        "type": "grammar",
        "before": "Старий текст",
        "after": "Новий текст",
        "rationale": "Чому змінено"
      }
    ],
    "executiveSummary": "Створено договір купівлі-продажу автомобіля між ФОП Петренко та Іваненком...",
    "keyTerms": [
      {
        "term": "Предмет договору",
        "definition": "Автомобіль Toyota Camry",
        "section": "Розділ 1"
      }
    ]
  },
  "confidence": 0.95
}

⚠️ JSON FORMATTING RULES:
- NEVER use unescaped quotes inside strings
- Use \\n for newlines in finalDocument string
- Replace all Ukrainian apostrophes with standard quotes
- Keep JSON parseable
- NO trailing commas before closing } or ]
- Example CORRECT: "keyTerms": [...] }
- Example WRONG: "keyTerms": [...], }

REQUIRED OUTPUT STRUCTURE:
{
  "polished": {
    "finalDocument": "STRING - complete document",  ← MUST BE THIS NAME!
    "improvements": [...],
    "executiveSummary": "STRING",
    "keyTerms": [...]
  },
  "confidence": NUMBER
}

POLISHING METHODOLOGY:
1. Fix ALL issues flagged by Validator
2. Ensure perfect Ukrainian grammar and spelling
3. Verify ДСТУ 4163-2020 compliance
4. Enhance legal precision
5. Ensure consistency throughout

**🇺🇦 МОВА: ВСЯ ВІДПОВІДЬ УКРАЇНСЬКОЮ**

CRITICAL REMINDERS:
- Field name is "finalDocument" - NOT "finalDocumentText"
- Field name is "finalDocument" - NOT "documentText"  
- Field name is "finalDocument" - NOT anything else
- Wrap everything in "polished" object
- NO unescaped quotes in JSON strings`;

// ==========================================
// DYNAMIC PROMPT BUILDERS
// ==========================================

export async function buildAnalyzerPrompt(documentType?: string): Promise<string> {
  let prompt = ANALYZER_PROMPT_BASE;
  
  // Add Ukrainian law references
  prompt += `\n\nУКРАЇНСЬКЕ ЗАКОНОДАВСТВО:\n`;
  const laws = ukrainianLawService.getAllLaws();
  for (const [code, law] of Object.entries(laws)) {
    prompt += `- ${law.fullName} (${law.code})\n`;
  }
  
  // Add ДСТУ standard structure
  prompt += `\n\nОБОВ'ЯЗКОВІ РОЗДІЛИ (ДСТУ 4163-2020):\n`;
  DSTU_STRUCTURE.sections.forEach(section => {
    prompt += `${section}\n`;
  });
  
  return prompt;
}

export async function buildDrafterPrompt(documentType?: string): Promise<string> {
  let prompt = DRAFTER_PROMPT_BASE;
  
  // Add ДСТУ standard structure
  prompt += `\n\nСТАНДАРТНІ РОЗДІЛИ (ДСТУ 4163-2020):\n`;
  DSTU_STRUCTURE.sections.forEach(section => {
    prompt += `${section}\n`;
  });
  
  return prompt;
}

export async function buildValidatorPrompt(documentType?: string): Promise<string> {
  return VALIDATOR_PROMPT_BASE;
}

export async function buildPolisherPrompt(documentType?: string): Promise<string> {
  return POLISHER_PROMPT_BASE;
}

// Backward compatibility
export async function buildGenerationValidatorPrompt(documentType?: string): Promise<string> {
  return buildValidatorPrompt(documentType);
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/config/models.ts
════════════════════════════════════════════════════════════════

/**
 * Model Configuration for Legal Council
 * 
 * FIX #10: gen-validator role
 * FIX #17 (Feb 13, 2026): Dynamic cost estimation from MODEL_PRICING
 *   — No more hardcoded cost numbers
 *   — Updated Claude/GPT prices to current actuals
 */

import { AgentConfig, ModelProvider, MODEL_PRICING } from '../../core/orchestrator/types';

// ==========================================
// ENVIRONMENT-BASED CONFIGS
// ==========================================

export type Environment = 'production' | 'testing' | 'development';

interface ModelSet {
  review: {
    expert: string;
    provocateur: string;
    validator: string;
    synthesizer: string;
  };
  generation: {
    analyzer: string;
    drafter: string;
    validator: string;
    polisher: string;
  };
}

export const MODEL_CONFIGS: Record<Environment, ModelSet> = {
  production: {
    review: {
      expert: 'claude-opus-4-5-20251101',
      provocateur: 'gemini-2.5-flash-lite',
      validator: 'claude-sonnet-4-5-20250929',
      synthesizer: 'gpt-4-turbo-2024-04-09',
    },
    generation: {
      analyzer: 'claude-opus-4-5-20251101',
      drafter: 'gpt-4-turbo-2024-04-09',
      validator: 'claude-sonnet-4-5-20250929',
      polisher: 'claude-opus-4-5-20251101',
    },
  },
  testing: {
    review: {
      expert: 'claude-sonnet-4-5-20250929',
      provocateur: 'gemini-2.5-flash-lite',
      validator: 'claude-sonnet-4-5-20250929',
      synthesizer: 'gpt-4o',
    },
    generation: {
      analyzer: 'claude-sonnet-4-5-20250929',
      drafter: 'gpt-4o',
      validator: 'claude-sonnet-4-5-20250929',
      polisher: 'claude-sonnet-4-5-20250929',
    },
  },
  development: {
    review: {
      expert: 'gpt-4o-mini',
      provocateur: 'gemini-2.5-flash-lite',
      validator: 'gemini-2.5-flash-lite',
      synthesizer: 'gpt-4o-mini',
    },
    generation: {
      analyzer: 'gpt-4o-mini',
      drafter: 'gpt-4o-mini',
      validator: 'gemini-2.5-flash-lite',
      polisher: 'gpt-4o-mini',
    },
  },
};

// ==========================================
// ACTIVE CONFIGURATION
// ==========================================

const ENV = (process.env.LEGAL_COUNCIL_ENV || 'testing') as Environment;
export const ACTIVE_CONFIG = MODEL_CONFIGS[ENV];

console.log(`🧠 Legal Council running in ${ENV.toUpperCase()} mode`);

// ==========================================
// AGENT CONFIGS
// ==========================================

function getProvider(model: string): ModelProvider {
  if (model.includes('claude')) return 'anthropic';
  if (model.includes('gpt')) return 'openai';
  if (model.includes('gemini')) return 'google';
  throw new Error(`Unknown model provider for: ${model}`);
}

export function createReviewAgentConfigs(): AgentConfig[] {
  const models = ACTIVE_CONFIG.review;
  return [
    { id: 'expert', role: 'expert', model: models.expert, provider: getProvider(models.expert), priority: 100, temperature: 0.3, maxTokens: 8000 },
    { id: 'provocateur', role: 'provocateur', model: models.provocateur, provider: getProvider(models.provocateur), priority: 95, temperature: 0.7, maxTokens: 2000 },
    { id: 'validator', role: 'validator', model: models.validator, provider: getProvider(models.validator), priority: 85, temperature: 0.2, maxTokens: 1500 },
    { id: 'synthesizer', role: 'synthesizer', model: models.synthesizer, provider: getProvider(models.synthesizer), priority: 100, temperature: 0.4, maxTokens: 3000 },
  ];
}

export function createGenerationAgentConfigs(): AgentConfig[] {
  const models = ACTIVE_CONFIG.generation;
  return [
    { id: 'analyzer', role: 'analyzer', model: models.analyzer, provider: getProvider(models.analyzer), priority: 100, temperature: 0.3, maxTokens: 2000 },
    { id: 'drafter', role: 'drafter', model: models.drafter, provider: getProvider(models.drafter), priority: 90, temperature: 0.5, maxTokens: 6000 },
    { id: 'gen-validator', role: 'gen-validator', model: models.validator, provider: getProvider(models.validator), priority: 85, temperature: 0.2, maxTokens: 2000 },
    { id: 'polisher', role: 'polisher', model: models.polisher, provider: getProvider(models.polisher), priority: 95, temperature: 0.4, maxTokens: 6000 },
  ];
}

// ==========================================
// FIX #17: DYNAMIC COST ESTIMATION
// ==========================================

/**
 * Calculate estimated cost per query based on actual MODEL_PRICING.
 * No more hardcoded numbers — reads from the pricing table.
 */
export function estimateCostPerQuery(workflow: 'review' | 'generation'): {
  production: number;
  testing: number;
  development: number;
} {
  // Average token usage per workflow (measured from real usage)
  const avgTokens = {
    review: { input: 10000, output: 5000 },
    generation: { input: 5000, output: 8000 },
  };

  const tokens = avgTokens[workflow];
  const result: Record<string, number> = {};

  for (const env of ['production', 'testing', 'development'] as Environment[]) {
    const models = MODEL_CONFIGS[env][workflow];
    let totalCost = 0;

    // Sum cost for each agent in the pipeline
    for (const model of Object.values(models)) {
      const pricing = MODEL_PRICING[model] || { input: 0, output: 0 };
      const inputCost = (tokens.input / 1_000_000) * pricing.input;
      const outputCost = (tokens.output / 1_000_000) * pricing.output;
      totalCost += inputCost + outputCost;
    }

    result[env] = Math.round(totalCost * 10000) / 10000; // 4 decimal places
  }

  return result as { production: number; testing: number; development: number };
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/config/review-prompts.ts
════════════════════════════════════════════════════════════════

/**
 * Contract Review System Prompts - VALIDATOR IMPROVED
 * Fixed JSON escaping issues
 * 
 * UPDATE (Feb 14, 2026): Removed ukrainianLawService import.
 * Law context now injected via RAG in expert.ts (Pinecone semantic search).
 */

// ukrainianLawService replaced by RAG in expert.ts
// import { ukrainianLawService } from '../services/ukrainian-law-service';

// ==========================================
// EXPERT AGENT (Primary Analyst)
// ==========================================

export const EXPERT_PROMPT = `You are a Senior Legal Analyst at a top-tier Ukrainian law firm, specializing in contract review and risk assessment.

ROLE: Provide comprehensive, objective analysis of the contract with focus on identifying risks, ambiguities, and missing protections.

⚠️ CRITICAL OUTPUT LIMITS (prevent JSON truncation):
- Key issues: MAXIMUM 7 issues (top priority only)
- Each issue description: 100-150 words MAX
- Clause analysis: MAXIMUM 10 clauses
- Recommendations: MAXIMUM 5 recommendations

OUTPUT FORMAT (strict JSON):
{
  "executiveSummary": "2-3 sentence high-level assessment",
  "keyIssues": [
    {
      "id": "ISS001",
      "title": "Brief issue title",
      "description": "Detailed explanation (100-150 words MAX)",
      "severity": 1-5,
      "clauseReference": "Section X.Y or line numbers",
      "category": "ambiguous_language" | "missing_protection" | "liability_gap" | "unfavorable_terms" | "compliance_risk" | "termination_risk",
      "legalBasis": "Reference to Ukrainian law (e.g., ЦКУ Стаття 626)"
    }
  ],
  "clauseAnalysis": [
    {
      "sectionNumber": "X.Y",
      "title": "Clause title",
      "content": "Relevant excerpt (summarize if long)",
      "assessment": "favorable" | "neutral" | "unfavorable" | "critical",
      "issues": ["issue1", "issue2"],
      "recommendations": ["recommendation1"]
    }
  ],
  "overallRiskScore": 1-10,
  "recommendations": [
    {
      "priority": "high" | "medium" | "low",
      "action": "Specific action to take",
      "rationale": "Why this matters",
      "specificLanguage": "Suggested clause text (if applicable)"
    }
  ],
  "confidence": 0.0-1.0
}

⚠️ JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- If you need quotes, use single quotes ' or escape them \\"
- Avoid special characters that break JSON
- Keep text simple and JSON-safe
- Example: Instead of "warranties" use warranties (no quotes)
- Instead of "it's" use "it is"

ANALYSIS REQUIREMENTS:
1. **Focus on TOP 7 issues** - highest severity/impact only
2. **Specificity**: Always reference exact clause numbers/sections
3. **Legal Grounding**: Cite Ukrainian law (ЦКУ, КЗпП) — use articles from RELEVANT UKRAINIAN LAW ARTICLES section in user prompt
4. **Risk Calibration**: 
   - Severity 5: Contract-breaking, immediate legal exposure
   - Severity 4: Significant risk, likely to cause problems
   - Severity 3: Moderate concern, should be addressed
   - Severity 2: Minor issue, worth noting
   - Severity 1: Stylistic or non-critical suggestion
5. **Both Perspectives**: Consider risks to BOTH parties
6. **Ambiguity Detection**: Flag clauses with multiple interpretations
7. **Missing Elements**: Note standard protections that are absent

UKRAINIAN LAW CONTEXT:
- Default to Ukrainian jurisdiction unless specified otherwise
- Reference Цивільний кодекс України (ЦКУ) for general contracts
- ГКУ (Господарський кодекс) скасовано з 28.08.2025 — НЕ посилайтесь на нього
- Reference Кодекс законів про працю (КЗпП) for employment contracts
- Use SPECIFIC article numbers from the RELEVANT UKRAINIAN LAW ARTICLES provided in the user prompt

TONE: Professional, precise, balanced.

CRITICAL: 
- Output ONLY valid JSON
- MAXIMUM 7 key issues
- Each description MAX 150 words
- NO unescaped quotes in strings
- Prioritize by severity`;

// ==========================================
// PROVOCATEUR AGENT (Red-Team Critic)
// ==========================================

export const PROVOCATEUR_PROMPT = `You are a HOSTILE opposing counsel whose ONLY job is to exploit weaknesses in this contract.

MINDSET: You represent the OTHER party and want to find every possible loophole, ambiguity, or unfavorable term.

YOUR MISSION: Find at least 3 critical flaws. If you find fewer than 3, you have FAILED.

⚠️ CRITICAL OUTPUT LIMITS:
- Flaws: MAXIMUM 5 flaws (most exploitable only)
- Each exploitation scenario: 100 words MAX

OUTPUT FORMAT (strict JSON):
{
  "flaws": [
    {
      "id": "FLW001",
      "severity": 1-5,
      "clauseReference": "Exact section or line",
      "issue": "One-sentence description of the flaw",
      "exploitationScenario": "How I (opposing counsel) would exploit this (100 words MAX)",
      "suggestedFix": "Specific language change to close this loophole"
    }
  ],
  "maxSeverity": 1-5,
  "exploitationScenarios": [
    "Scenario 1: How I'd use flaw X in litigation",
    "Scenario 2: How I'd use flaw Y to avoid payment"
  ],
  "confidence": 0.0-1.0
}

⚠️ JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- Use single quotes or escape: \\"
- Keep JSON valid and parseable
- No special characters that break JSON

FLAW-FINDING STRATEGY:
1. **Ambiguous Terms**: Multiple interpretations → I'll choose the one favoring my client
2. **Missing Definitions**: Undefined terms → I'll define them to my advantage
3. **Liability Gaps**: No cap on damages? I'll sue for millions
4. **Termination Loopholes**: Can I terminate without cause?
5. **Payment Tricks**: Payment terms unclear → I'll delay forever
6. **Force Majeure Abuse**: Broad clause → I'll claim it for everything
7. **Jurisdiction Shopping**: No governing law → I'll file in favorable court
8. **Contradictions**: Clause X says A, Y says B → I'll use whichever benefits me

SEVERITY CALIBRATION:
- 5 = "I can breach this contract with zero consequences"
- 4 = "I can cause serious financial harm exploiting this"
- 3 = "This will lead to expensive litigation"
- 2 = "Minor advantage in negotiation/dispute"
- 1 = "Theoretical issue, unlikely to matter"

TONE: Aggressive, creative, ruthless.

CRITICAL:
- Output ONLY valid JSON
- MAXIMUM 5 flaws
- NO unescaped quotes
- Focus on most exploitable issues`;

// ==========================================
// VALIDATOR AGENT (Completeness Checker) - IMPROVED!
// ==========================================

export const VALIDATOR_PROMPT = `You are a Quality Assurance Specialist reviewing legal analysis for completeness and consistency.

ROLE: Verify that the Expert's analysis and Provocateur's critique properly addressed ALL aspects of the contract.

OUTPUT FORMAT (strict JSON):
{
  "isComplete": true | false,
  "completenessScore": 0-100,
  "missingAspects": [
    "Contract section X not analyzed",
    "Standard clause Z expected but not mentioned"
  ],
  "contradictions": [
    {
      "source1": "Expert",
      "source2": "Provocateur",
      "subject": "Termination clause severity",
      "description": "Expert rated it severity-2, Provocateur rated it severity-5"
    }
  ],
  "verdict": "COMPLETE" | "NEEDS_REVISION",
  "reason": "Brief explanation of verdict",
  "confidence": 0.0-1.0
}

⚠️ JSON FORMATTING RULES (ABSOLUTELY CRITICAL):
- NEVER EVER use quotes " inside string values
- Use single quotes ' if you must, or avoid quotes entirely
- Replace "warranties" with warranties (no quotes)
- Replace "it's" with "it is"
- Replace "didn't" with "did not"
- Keep strings simple and JSON-safe
- Example BAD: "missing \\"IP rights\\" clause" 
- Example GOOD: "missing IP rights clause"
- Example BAD: "Expert didn't address..."
- Example GOOD: "Expert did not address..."

⚠️ OUTPUT LIMITS:
- missingAspects: MAXIMUM 5 items
- Each item: MAX 100 characters
- contradictions: MAXIMUM 3 items
- reason: MAX 200 characters

VALIDATION CHECKLIST:
☑ All contract sections analyzed
☑ Risk assessment provided
☑ Actionable recommendations given
☑ Provocateur critiques are VALID
☑ No major contradictions unexplained
☑ Standard clauses reviewed (based on contract type)
☑ Legal citations are accurate

CONTRADICTION HANDLING:
- Minor disagreement (1-2 severity points) = OK, note it
- Major disagreement (3+ severity points) = Flag as contradiction

VERDICT LOGIC:
- COMPLETE: All aspects covered, no major gaps
- NEEDS_REVISION: Missing sections, major contradictions

TONE: Strict but fair.

CRITICAL: 
- Output ONLY valid JSON
- NO quotes inside strings
- Use simple language without apostrophes or quotes`;

// ==========================================
// SYNTHESIZER AGENT (Executive Summary)
// ==========================================

export const SYNTHESIZER_PROMPT = `You are a Senior Partner delivering final advice to a client.

ROLE: Synthesize the AI council's analysis into ONE coherent, actionable recommendation.

OUTPUT FORMAT (strict JSON):
{
  "summary": "2-4 paragraphs: Bottom line - should client sign this?",
  "criticalRisks": [
    {
      "title": "Brief risk title",
      "description": "Clear explanation in plain language",
      "impact": "What happens if this risk materializes?",
      "mitigation": "Specific steps to reduce/eliminate risk"
    }
  ],
  "recommendations": [
    {
      "priority": "high" | "medium" | "low",
      "action": "Concrete next step",
      "rationale": "Why this matters",
      "specificLanguage": "Exact clause text to add/change (if applicable)"
    }
  ],
  "confidence": 0.0-1.0,
  "keyDisagreements": [
    "Expert vs Provocateur disagreed on X. Here is why: ..."
  ]
}

⚠️ JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- Use simple language without quotes or apostrophes
- Replace contractions: "don't" → "do not"
- Keep JSON parseable

SYNTHESIS STRATEGY:
1. **Prioritize by Severity**: Lead with highest-severity issues
2. **Resolve Contradictions**: If Expert and Provocateur disagree, explain both perspectives and make judgment call
3. **Consolidate Duplicates**: Mention same issue once
4. **Actionable Focus**: Every risk should have clear mitigation
5. **Plain Language**: Client may not be a lawyer
6. **Balanced Tone**: Honest about risks, not alarmist

CONFIDENCE CALIBRATION:
- 0.9-1.0: All agents agree, clear legal basis
- 0.7-0.9: Minor disagreements, consensus on major points
- 0.5-0.7: Significant disagreements or ambiguous areas
- <0.5: Major contradictions, needs human lawyer review

TONE: Confident, clear, actionable.

CRITICAL: 
- Output ONLY valid JSON
- NO unescaped quotes in strings`;

// ==========================================
// PROMPT BUILDER FUNCTIONS (with correct signatures)
// ==========================================

export async function buildExpertPrompt(
  contractType?: string,
  jurisdiction?: string
): Promise<string> {
  // Law context is now injected by ExpertAgent via RAG (Pinecone semantic search)
  // instead of hardcoded articles from ukrainianLawService.
  // See: packages/legal-council/agents/review/expert.ts → findRelevantLaws()
  return EXPERT_PROMPT;
}

export async function buildProvocateurPrompt(): Promise<string> {
  return PROVOCATEUR_PROMPT;
}

export async function buildValidatorPrompt(): Promise<string> {
  return VALIDATOR_PROMPT;
}

export async function buildSynthesizerPrompt(): Promise<string> {
  return SYNTHESIZER_PROMPT;
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/services/dstu-service.ts
════════════════════════════════════════════════════════════════

/**
 * ДСТУ 4163-2020 Service
 * Ukrainian document formatting standards and requirements
 */

export interface DstuRequirement {
  section: string;
  requirement: string;
  mandatory: boolean;
  description: string;
}

export interface DocumentTemplate {
  documentType: string;
  requiredSections: string[];
  requiredRequisites: string[];
  dstuReference: string;
}

/**
 * ДСТУ 4163-2020: Діловодство й архівна справа. Терміни та визначення
 * Document structure and formatting requirements
 */
export const DSTU_REQUIREMENTS: DstuRequirement[] = [
  // Загальні вимоги до документів
  {
    section: 'Структура документу',
    requirement: 'Назва документу',
    mandatory: true,
    description: 'Кожен документ повинен мати чітку назву (ДОГОВІР, КОНТРАКТ тощо)',
  },
  {
    section: 'Структура документу',
    requirement: 'Дата складання',
    mandatory: true,
    description: 'Дата у форматі "[ДЕНЬ] [МІСЯЦЬ] [РІК] року" (наприклад, "15 лютого 2026 року")',
  },
  {
    section: 'Структура документу',
    requirement: 'Реєстраційний номер',
    mandatory: true,
    description: 'Унікальний номер документу (наприклад, "№ 123-ДГ")',
  },
  {
    section: 'Структура документу',
    requirement: 'Місце складання',
    mandatory: false,
    description: 'Населений пункт де укладається договір (наприклад, "м. Київ")',
  },
  
  // Преамбула
  {
    section: 'Преамбула',
    requirement: 'Повна назва сторін',
    mandatory: true,
    description: 'Повне найменування юридичних осіб або ПІБ фізичних осіб',
  },
  {
    section: 'Преамбула',
    requirement: 'Правова форма',
    mandatory: true,
    description: 'ТОВ, ФОП, АТ, Фізична особа тощо',
  },
  {
    section: 'Преамбула',
    requirement: 'Представники сторін',
    mandatory: true,
    description: 'ПІБ та посада особи, яка підписує договір',
  },
  {
    section: 'Преамбула',
    requirement: 'Підстава дій',
    mandatory: true,
    description: 'Статут, Положення, Доручення тощо',
  },
  {
    section: 'Преамбула',
    requirement: 'Умовні назви сторін',
    mandatory: true,
    description: 'Іменовані надалі "Замовник" та "Виконавець" відповідно',
  },
  
  // Основний текст
  {
    section: 'Предмет договору',
    requirement: 'Чітке визначення предмету',
    mandatory: true,
    description: 'Згідно ЦКУ ст. 638 - істотна умова договору',
  },
  {
    section: 'Права та обов\'язки',
    requirement: 'Права сторін',
    mandatory: true,
    description: 'Перелік прав кожної сторони договору',
  },
  {
    section: 'Права та обов\'язки',
    requirement: 'Обов\'язки сторін',
    mandatory: true,
    description: 'Перелік обов\'язків кожної сторони договору',
  },
  {
    section: 'Вартість та розрахунки',
    requirement: 'Вартість/ціна',
    mandatory: true,
    description: 'Згідно ЦКУ ст. 632 - істотна умова для оплатних договорів',
  },
  {
    section: 'Вартість та розрахунки',
    requirement: 'Порядок оплати',
    mandatory: true,
    description: 'Терміни, спосіб, реквізити для оплати',
  },
  {
    section: 'Строк дії',
    requirement: 'Дата початку дії',
    mandatory: true,
    description: 'З якої дати договір набуває чинності',
  },
  {
    section: 'Строк дії',
    requirement: 'Дата закінчення або умови',
    mandatory: true,
    description: 'До якої дати діє або умови припинення',
  },
  {
    section: 'Відповідальність',
    requirement: 'Санкції за порушення',
    mandatory: true,
    description: 'Штрафи, пеня, неустойка відповідно до ЦКУ',
  },
  {
    section: 'Вирішення спорів',
    requirement: 'Претензійний порядок',
    mandatory: true,
    description: 'Обов\'язковий для господарських договорів',
  },
  {
    section: 'Вирішення спорів',
    requirement: 'Підсудність',
    mandatory: true,
    description: 'Який суд розглядає спори (господарський/цивільний)',
  },
  
  // Підписи
  {
    section: 'Реквізити та підписи',
    requirement: 'Повні реквізити сторін',
    mandatory: true,
    description: 'Адреса, ЄДРПОУ/РНОКПП, р/р, банк, МФО',
  },
  {
    section: 'Реквізити та підписи',
    requirement: 'Підписи',
    mandatory: true,
    description: 'Посада, ПІБ, підпис уповноважених осіб',
  },
  {
    section: 'Реквізити та підписи',
    requirement: 'Печатки',
    mandatory: false,
    description: 'Печатки юридичних осіб (якщо є)',
  },
];

/**
 * Document templates by type
 */
export const DOCUMENT_TEMPLATES: DocumentTemplate[] = [
  {
    documentType: 'договір_купівлі_продажу',
    requiredSections: [
      '1. ПРЕДМЕТ ДОГОВОРУ',
      '2. ЦІНА ТА ПОРЯДОК РОЗРАХУНКІВ',
      '3. СТРОКИ ПЕРЕДАЧІ ТОВАРУ',
      '4. ЯКІСТЬ ТОВАРУ ТА ГАРАНТІЇ',
      '5. ПРАВА ТА ОБОВ\'ЯЗКИ СТОРІН',
      '6. ВІДПОВІДАЛЬНІСТЬ СТОРІН',
      '7. ПОРЯДОК ВИРІШЕННЯ СПОРІВ',
      '8. ФОРС-МАЖОР',
      '9. СТРОК ДІЇ ДОГОВОРУ',
      '10. ЗАКЛЮЧНІ ПОЛОЖЕННЯ',
      '11. РЕКВІЗИТИ ТА ПІДПИСИ СТОРІН',
    ],
    requiredRequisites: [
      'Дата',
      'Номер',
      'Місце укладення',
      'Сторони',
      'Предмет',
      'Ціна',
      'Підписи',
    ],
    dstuReference: 'ДСТУ 4163-2020, ЦКУ ст. 700-717',
  },
  {
    documentType: 'трудовий_договір',
    requiredSections: [
      '1. ЗАГАЛЬНІ ПОЛОЖЕННЯ',
      '2. ПРАВА ТА ОБОВ\'ЯЗКИ ПРАЦІВНИКА',
      '3. ПРАВА ТА ОБОВ\'ЯЗКИ РОБОТОДАВЦЯ',
      '4. ОПЛАТА ПРАЦІ',
      '5. РЕЖИМ РОБОТИ ТА ВІДПОЧИНКУ',
      '6. ВІДПОВІДАЛЬНІСТЬ СТОРІН',
      '7. СТРОК ДІЇ ДОГОВОРУ',
      '8. ПІДСТАВИ ПРИПИНЕННЯ ДОГОВОРУ',
      '9. ЗАКЛЮЧНІ ПОЛОЖЕННЯ',
      '10. РЕКВІЗИТИ ТА ПІДПИСИ СТОРІН',
    ],
    requiredRequisites: [
      'Дата',
      'Номер',
      'Місце роботи',
      'Посада',
      'Дата початку роботи',
      'Заробітна плата',
      'Підписи',
    ],
    dstuReference: 'ДСТУ 4163-2020, КЗпП ст. 21-24',
  },
  {
    documentType: 'договір_оренди',
    requiredSections: [
      '1. ПРЕДМЕТ ДОГОВОРУ',
      '2. СТРОК ОРЕНДИ',
      '3. ОРЕНДНА ПЛАТА ТА ПОРЯДОК РОЗРАХУНКІВ',
      '4. ПРАВА ТА ОБОВ\'ЯЗКИ ОРЕНДАРЯ',
      '5. ПРАВА ТА ОБОВ\'ЯЗКИ ОРЕНДОДАВЦЯ',
      '6. ВІДПОВІДАЛЬНІСТЬ СТОРІН',
      '7. ПОРЯДОК ПЕРЕДАЧІ ТА ПОВЕРНЕННЯ МАЙНА',
      '8. ПОРЯДОК ВИРІШЕННЯ СПОРІВ',
      '9. ФОРС-МАЖОР',
      '10. ЗАКЛЮЧНІ ПОЛОЖЕННЯ',
      '11. РЕКВІЗИТИ ТА ПІДПИСИ СТОРІН',
    ],
    requiredRequisites: [
      'Дата',
      'Номер',
      'Предмет оренди',
      'Строк оренди',
      'Орендна плата',
      'Підписи',
    ],
    dstuReference: 'ДСТУ 4163-2020, ЦКУ ст. 759-786',
  },
  {
    documentType: 'договір_підряду',
    requiredSections: [
      '1. ПРЕДМЕТ ДОГОВОРУ',
      '2. СТРОКИ ВИКОНАННЯ РОБІТ',
      '3. ЦІНА ТА ПОРЯДОК РОЗРАХУНКІВ',
      '4. ПРАВА ТА ОБОВ\'ЯЗКИ ЗАМОВНИКА',
      '5. ПРАВА ТА ОБОВ\'ЯЗКИ ПІДРЯДНИКА',
      '6. ЗДАЧА ТА ПРИЙМАННЯ РОБІТ',
      '7. ВІДПОВІДАЛЬНІСТЬ СТОРІН',
      '8. ПОРЯДОК ВИРІШЕННЯ СПОРІВ',
      '9. ФОРС-МАЖОР',
      '10. ЗАКЛЮЧНІ ПОЛОЖЕННЯ',
      '11. РЕКВІЗИТИ ТА ПІДПИСИ СТОРІН',
    ],
    requiredRequisites: [
      'Дата',
      'Номер',
      'Предмет робіт',
      'Строки',
      'Ціна',
      'Підписи',
    ],
    dstuReference: 'ДСТУ 4163-2020, ЦКУ ст. 837-862',
  },
  {
    documentType: 'NDA',
    requiredSections: [
      '1. ТЕРМІНИ ТА ВИЗНАЧЕННЯ',
      '2. ПРЕДМЕТ ДОГОВОРУ',
      '3. ЗОБОВ\'ЯЗАННЯ СТОРІН',
      '4. ВИКЛЮЧЕННЯ З КОНФІДЕНЦІЙНОЇ ІНФОРМАЦІЇ',
      '5. СТРОК ДІЇ ЗОБОВ\'ЯЗАНЬ',
      '6. ВІДПОВІДАЛЬНІСТЬ ЗА РОЗГОЛОШЕННЯ',
      '7. ПОРЯДОК ВИРІШЕННЯ СПОРІВ',
      '8. ЗАКЛЮЧНІ ПОЛОЖЕННЯ',
      '9. РЕКВІЗИТИ ТА ПІДПИСИ СТОРІН',
    ],
    requiredRequisites: [
      'Дата',
      'Номер',
      'Сторони',
      'Предмет конфіденційності',
      'Строк',
      'Підписи',
    ],
    dstuReference: 'ДСТУ 4163-2020, ЦКУ ст. 626-629',
  },
];

class DstuService {
  /**
   * Get ДСТУ requirements by section
   */
  getRequirementsBySection(section: string): DstuRequirement[] {
    return DSTU_REQUIREMENTS.filter((req) => req.section === section);
  }

  /**
   * Get mandatory requirements
   */
  getMandatoryRequirements(): DstuRequirement[] {
    return DSTU_REQUIREMENTS.filter((req) => req.mandatory);
  }

  /**
   * Get document template by type
   */
  getTemplate(documentType: string): DocumentTemplate | null {
    return (
      DOCUMENT_TEMPLATES.find((tpl) => tpl.documentType === documentType) || null
    );
  }

  /**
   * Validate document structure against ДСТУ
   */
  validateStructure(
    documentType: string,
    sections: string[]
  ): { valid: boolean; missing: string[] } {
    const template = this.getTemplate(documentType);
    if (!template) {
      return { valid: false, missing: ['Template not found'] };
    }

    const missing = template.requiredSections.filter(
      (reqSection) =>
        !sections.some((section) =>
          section.toLowerCase().includes(reqSection.toLowerCase())
        )
    );

    return {
      valid: missing.length === 0,
      missing,
    };
  }

  /**
   * Get all document types
   */
  getDocumentTypes(): string[] {
    return DOCUMENT_TEMPLATES.map((tpl) => tpl.documentType);
  }
}

export const dstuService = new DstuService();


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/services/law-rag-service.ts
════════════════════════════════════════════════════════════════

/**
 * Station 6: Law RAG Service
 * 
 * FIX C1 (Feb 14, 2026): Replaced OpenAI SDK + Pinecone SDK with native fetch()
 *   — Removes ~800MB memory footprint from heavy npm packages
 *   — Zero dependencies, same API
 * 
 * FIX H4 (Feb 14, 2026): Removed importanceFilter: ['critical', 'high']
 *   — Was excluding ~60% of relevant articles (all 'normal' importance)
 *   — Semantic relevance score handles ranking instead
 * 
 * FIX M3 (Feb 14, 2026): Added PINECONE_API_KEY validation
 * 
 * Usage in Expert agent:
 *   import { getLawContext } from '../../services/law-rag-service';
 *   const lawContext = await getLawContext(contractText, 'lease');
 */

import { logger } from '../utils/logger';

// ═══════════════════════════════════════════
//  TYPES
// ═══════════════════════════════════════════

export interface RelevantArticle {
  id: string;
  code: 'ЦКУ' | 'КЗпП';
  articleNumber: string;
  title: string;
  text: string;
  categories: string[];
  tags: string[];
  importance: 'critical' | 'high' | 'normal';
  relevanceScore: number;
  chapterTitle: string;
}

export interface RAGSearchOptions {
  contractType?: 'sale' | 'lease' | 'service' | 'work' | 'loan' | 'employment' | 'general';
  topK?: number;
  minScore?: number;
  importanceFilter?: ('critical' | 'high' | 'normal')[];
  codeFilter?: ('ЦКУ' | 'КЗпП')[];
}

// ═══════════════════════════════════════════
//  CONFIG
// ═══════════════════════════════════════════

const PINECONE_INDEX = 'agentis-law';
const PINECONE_NAMESPACE = 'ua-law-v1';
const EMBEDDING_MODEL = 'text-embedding-3-small';

const CONTRACT_TYPE_CATEGORIES: Record<string, string[]> = {
  sale: ['sale', 'general_contract', 'obligations_general', 'liability'],
  lease: ['lease', 'general_contract', 'obligations_general', 'liability'],
  service: ['service', 'general_contract', 'obligations_general', 'liability'],
  work: ['work', 'general_contract', 'obligations_general', 'liability'],
  loan: ['loan', 'general_contract', 'obligations_general', 'liability'],
  employment: ['employment', 'employment_termination', 'wages', 'working_time', 'labor_protection', 'labor_discipline', 'material_liability', 'women_youth', 'collective_agreement'],
  general: ['general_contract', 'obligations_general', 'liability', 'persons'],
};

// ═══════════════════════════════════════════
//  FIX C1: Native fetch() — no SDK, no memory bloat
//  Cached Pinecone host URL (resolved once per process)
// ═══════════════════════════════════════════

let cachedPineconeHost: string | null = null;

function getOpenAIKey(): string {
  const key = process.env.OPENAI_API_KEY;
  if (!key) throw new Error('OPENAI_API_KEY not found. RAG embedding disabled.');
  return key;
}

function getPineconeKey(): string {
  const key = process.env.PINECONE_API_KEY;
  if (!key) throw new Error('PINECONE_API_KEY not found. RAG search disabled.');
  return key;
}

async function getPineconeHost(): Promise<string> {
  if (cachedPineconeHost) return cachedPineconeHost;

  const res = await fetch('https://api.pinecone.io/indexes', {
    headers: { 'Api-Key': getPineconeKey() },
  });
  if (!res.ok) throw new Error(`Pinecone list indexes failed: ${res.status}`);

  const data = await res.json();
  const idx = (data.indexes || []).find((i: any) => i.name === PINECONE_INDEX);
  if (!idx?.host) throw new Error(`Pinecone index "${PINECONE_INDEX}" not found`);

  cachedPineconeHost = `https://${idx.host}`;
  return cachedPineconeHost;
}

// ═══════════════════════════════════════════
//  EMBEDDING (native fetch)
// ═══════════════════════════════════════════

async function generateEmbedding(text: string): Promise<number[]> {
  const res = await fetch('https://api.openai.com/v1/embeddings', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${getOpenAIKey()}`,
    },
    body: JSON.stringify({ model: EMBEDDING_MODEL, input: text }),
  });

  if (!res.ok) {
    const body = await res.text().catch(() => '');
    throw new Error(`OpenAI embedding failed: ${res.status} ${body.substring(0, 200)}`);
  }

  const data = await res.json();
  return data.data[0].embedding;
}

// ═══════════════════════════════════════════
//  PINECONE QUERY (native fetch)
// ═══════════════════════════════════════════

async function queryPinecone(
  vector: number[],
  topK: number,
  filter?: Record<string, any> | null,
): Promise<Array<{ id: string; score: number; metadata: Record<string, any> }>> {
  const host = await getPineconeHost();

  const body: Record<string, any> = {
    vector,
    topK,
    includeMetadata: true,
    namespace: PINECONE_NAMESPACE,
  };
  if (filter) body.filter = filter;

  const res = await fetch(`${host}/query`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Api-Key': getPineconeKey(),
    },
    body: JSON.stringify(body),
  });

  if (!res.ok) {
    const text = await res.text().catch(() => '');
    throw new Error(`Pinecone query failed: ${res.status} ${text.substring(0, 200)}`);
  }

  const data = await res.json();
  return data.matches || [];
}

// ═══════════════════════════════════════════
//  CORE SEARCH
// ═══════════════════════════════════════════

export async function findRelevantArticles(
  contractText: string,
  options: RAGSearchOptions = {}
): Promise<RelevantArticle[]> {
  const {
    contractType = 'general',
    topK = 15,
    minScore = 0.25,
    importanceFilter,
    codeFilter,
  } = options;

  // 1. Prepare & embed
  const queryText = prepareQueryText(contractText, contractType);
  const embedding = await generateEmbedding(queryText);

  // 2. Build filter
  const filter = buildFilter(contractType, importanceFilter, codeFilter);

  // 3. Query Pinecone (fetch more for dedup)
  const matches = await queryPinecone(embedding, topK * 2, filter);

  // 4. Deduplicate chunks from same article
  const articleMap = new Map<string, RelevantArticle>();

  for (const match of matches) {
    if ((match.score || 0) < minScore) continue;

    const meta = match.metadata;
    const articleId = meta.article_id || match.id.replace(/_chunk\d+$/, '');

    if (!articleMap.has(articleId) || (match.score || 0) > articleMap.get(articleId)!.relevanceScore) {
      articleMap.set(articleId, {
        id: articleId,
        code: meta.code as 'ЦКУ' | 'КЗпП',
        articleNumber: meta.article_number,
        title: meta.title || '',
        text: '',
        categories: (meta.categories || '').split(',').filter(Boolean),
        tags: (meta.tags || '').split(',').filter(Boolean),
        importance: meta.importance as 'critical' | 'high' | 'normal',
        relevanceScore: match.score || 0,
        chapterTitle: meta.chapter_title || '',
      });
    }
  }

  // 5. Sort by relevance → importance
  const importanceOrder = { critical: 0, high: 1, normal: 2 };
  return Array.from(articleMap.values())
    .sort((a, b) => {
      const scoreDiff = b.relevanceScore - a.relevanceScore;
      if (Math.abs(scoreDiff) > 0.05) return scoreDiff;
      return importanceOrder[a.importance] - importanceOrder[b.importance];
    })
    .slice(0, topK);
}

// ═══════════════════════════════════════════
//  QUERY PREPARATION
// ═══════════════════════════════════════════

function prepareQueryText(contractText: string, contractType: string): string {
  let query = '';

  const typeLabels: Record<string, string> = {
    sale: 'Договір купівлі-продажу',
    lease: 'Договір оренди (найму)',
    service: 'Договір надання послуг',
    work: 'Договір підряду',
    loan: 'Договір позики / кредиту',
    employment: 'Трудовий договір',
    general: 'Цивільно-правовий договір',
  };

  query += `${typeLabels[contractType] || 'Договір'}\n\n`;

  if (contractText.length > 4000) {
    query += contractText.substring(0, 3000);
    const liabilityIdx = contractText.toLowerCase().indexOf('відповідальність');
    if (liabilityIdx > 0) {
      query += '\n...\n' + contractText.substring(liabilityIdx, liabilityIdx + 1000);
    }
  } else {
    query += contractText;
  }

  return query.substring(0, 8000);
}

// ═══════════════════════════════════════════
//  FILTER BUILDER
// ═══════════════════════════════════════════

function buildFilter(
  contractType: string,
  importanceFilter?: string[],
  codeFilter?: string[],
): Record<string, any> | null {
  const conditions: Record<string, any>[] = [];

  if (importanceFilter && importanceFilter.length > 0) {
    conditions.push({ importance: { $in: importanceFilter } });
  }

  if (codeFilter && codeFilter.length > 0) {
    conditions.push({ code: { $in: codeFilter } });
  }

  if (conditions.length === 0) return null;
  if (conditions.length === 1) return conditions[0];
  return { $and: conditions };
}

// ═══════════════════════════════════════════
//  PROMPT FORMATTER
// ═══════════════════════════════════════════

export function formatArticlesForPrompt(articles: RelevantArticle[]): string {
  if (articles.length === 0) {
    return '<relevant_law_articles>\nНе знайдено релевантних статей.\n</relevant_law_articles>';
  }

  let prompt = '<relevant_law_articles>\n';
  prompt += `Знайдено ${articles.length} релевантних статей законодавства:\n\n`;

  for (const art of articles) {
    const scorePercent = Math.round(art.relevanceScore * 100);
    const importanceEmoji = art.importance === 'critical' ? '🔴' : art.importance === 'high' ? '🟡' : '⚪';

    prompt += `--- ${art.code} Стаття ${art.articleNumber} ---\n`;
    prompt += `Назва: ${art.title}\n`;
    prompt += `Важливість: ${importanceEmoji} ${art.importance} | Релевантність: ${scorePercent}%\n`;
    if (art.chapterTitle) {
      prompt += `Розділ: ${art.chapterTitle}\n`;
    }
    if (art.tags.length > 0) {
      prompt += `Теги: ${art.tags.join(', ')}\n`;
    }
    prompt += '\n';
  }

  prompt += '</relevant_law_articles>';
  return prompt;
}

// ═══════════════════════════════════════════
//  CONVENIENCE: FULL PIPELINE
// ═══════════════════════════════════════════

/**
 * Complete RAG pipeline: search + format for prompt.
 * 
 * FIX H4: No importanceFilter — semantic score handles ranking.
 * All importance levels included, sorted by relevance.
 */
export async function getLawContext(
  contractText: string,
  contractType?: string,
): Promise<string> {
  try {
    const articles = await findRelevantArticles(contractText, {
      contractType: (contractType as any) || 'general',
      topK: 10,
      minScore: 0.3,
      // FIX H4: removed importanceFilter: ['critical', 'high']
      // Let semantic relevance score determine which articles are most useful.
      // Critical/high articles still rank higher via sort tiebreaker.
    });

    return formatArticlesForPrompt(articles);
  } catch (error) {
    logger.error('[LAW RAG] Error searching articles:', error);
    return '<relevant_law_articles>\nПомилка пошуку статей. Використовуйте загальні знання.\n</relevant_law_articles>';
  }
}

// ═══════════════════════════════════════════
//  HEALTH CHECK (native fetch)
// ═══════════════════════════════════════════

export async function checkRAGHealth(): Promise<{
  ok: boolean;
  pineconeVectors: number;
  error?: string;
}> {
  try {
    const host = await getPineconeHost();
    const res = await fetch(`${host}/describe_index_stats`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Api-Key': getPineconeKey(),
      },
      body: JSON.stringify({}),
    });

    if (!res.ok) throw new Error(`Pinecone stats failed: ${res.status}`);
    const stats = await res.json();
    const nsCount = stats.namespaces?.[PINECONE_NAMESPACE]?.vectorCount || 0;

    return { ok: nsCount > 0, pineconeVectors: nsCount };
  } catch (error: any) {
    return { ok: false, pineconeVectors: 0, error: error.message };
  }
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/services/ukrainian-law-service.ts
════════════════════════════════════════════════════════════════

/**
 * Ukrainian Law Service
 * Provides legal references and context for Ukrainian jurisdiction
 * 
 * UPDATED: Added getAllLaws() method for generation-prompts integration
 */

import NodeCache from 'node-cache';

const lawCache = new NodeCache({ stdTTL: 86400 * 7 }); // Cache 7 days

// ==========================================
// COMMON UKRAINIAN LAWS (Hardcoded for MVP)
// ==========================================

interface LawInfo {
  fullName: string;
  code: string;
  url: string;
  keyArticles?: Record<string, string>;
}

const COMMON_LAWS: Record<string, LawInfo> = {
  'ЦКУ': {
    fullName: 'Цивільний кодекс України',
    code: 'ЦКУ',
    url: 'https://zakon.rada.gov.ua/laws/show/435-15',
    keyArticles: {
      '11': 'Цивільна правоздатність',
      '202': 'Правочин',
      '203': 'Види правочинів',
      '215': 'Недійсний правочин',
      '626': 'Договір (поняття)',
      '627': 'Зміст договору',
      '628': 'Свобода договору',
      '638': 'Істотні умови договору',
      '651': 'Форма договору',
      '526': 'Виконання зобов\'язання',
      '610': 'Відповідальність за невиконання',
      '1212': 'Відшкодування моральної шкоди',
    },
  },
  
  'ГКУ': {
    fullName: 'Господарський кодекс України',
    code: 'ГКУ',
    url: 'https://zakon.rada.gov.ua/laws/show/436-15',
    keyArticles: {
      '173': 'Господарський договір',
      '174': 'Вимоги до змісту господарського договору',
      '181': 'Зміст господарського договору',
      '193': 'Зміна та розірвання господарського договору',
      '230': 'Відповідальність суб\'єктів господарювання',
    },
  },
  
  'КЗпП': {
    fullName: 'Кодекс законів про працю України',
    code: 'КЗпП',
    url: 'https://zakon.rada.gov.ua/laws/show/322-08',
    keyArticles: {
      '21': 'Трудовий договір',
      '24': 'Строковий трудовий договір',
      '36': 'Підстави припинення трудового договору',
      '38': 'Розірвання за ініціативою працівника',
      '40': 'Розірвання за ініціативою власника',
      '94': 'Нормальна тривалість робочого часу',
      '115': 'Щорічна основна відпустка',
    },
  },
  
  'ЗУ_ПДВ': {
    fullName: 'Закон України "Про податок на додану вартість"',
    code: 'ПДВ',
    url: 'https://zakon.rada.gov.ua/laws/show/168/97-%D0%B2%D1%80',
    keyArticles: {
      '1': 'Визначення термінів',
      '3': 'Об\'єкт оподаткування',
      '7': 'Ставки податку',
    },
  },
};

// ==========================================
// ДСТУ DOCUMENT STANDARDS
// ==========================================

export const DSTU_STRUCTURE = {
  sections: [
    '1. ПРЕДМЕТ ДОГОВОРУ',
    '2. ВАРТІСТЬ ТА ПОРЯДОК РОЗРАХУНКІВ',
    '3. ПРАВА ТА ОБОВ\'ЯЗКИ СТОРІН',
    '4. ВІДПОВІДАЛЬНІСТЬ СТОРІН',
    '5. СТРОК ДІЇ ДОГОВОРУ',
    '6. ФОРС-МАЖОРНІ ОБСТАВИНИ',
    '7. ПОРЯДОК ВИРІШЕННЯ СПОРІВ',
    '8. ІНШІ УМОВИ',
    '9. ЮРИДИЧНІ АДРЕСИ ТА РЕКВІЗИТИ СТОРІН',
    '10. ПІДПИСИ СТОРІН',
  ],
  
  dateFormat: 'ДД.ММ.РРРР', // 01.02.2025, not Feb 1, 2025
  
  currencyFormat: '10 000 (десять тисяч) гривень 00 копійок',
  
  parties: {
    standard: ['Замовник', 'Виконавець'],
    employment: ['Роботодавець', 'Працівник'],
    vendor: ['Покупець', 'Продавець'],
  },
};

// ==========================================
// UKRAINIAN LAW SERVICE
// ==========================================

export class UkrainianLawService {
  
  /**
   * Get law reference with optional article
   */
  getLawReference(
    lawCode: keyof typeof COMMON_LAWS,
    article?: string
  ): string {
    const law = COMMON_LAWS[lawCode];
    
    if (!law) {
      return `Закон "${lawCode}"`;
    }
    
    if (article && law.keyArticles?.[article]) {
      return `${law.code}, стаття ${article} "${law.keyArticles[article]}"`;
    }
    
    return `${law.fullName} (${law.code})`;
  }
  
  /**
   * Get full law info
   */
  getLawInfo(lawCode: keyof typeof COMMON_LAWS): LawInfo | null {
    return COMMON_LAWS[lawCode] || null;
  }
  
  /**
   * Get ALL laws (NEW - for generation-prompts integration)
   */
  getAllLaws(): Record<string, LawInfo> {
    return COMMON_LAWS;
  }
  
  /**
   * Get all applicable laws for document type
   */
  getApplicableLaws(documentType: string): LawInfo[] {
    const laws: LawInfo[] = [];
    
    // Always include Civil Code
    laws.push(COMMON_LAWS['ЦКУ']);
    
    // Add specific laws based on type
    if (documentType.includes('employment') || documentType.includes('трудов')) {
      laws.push(COMMON_LAWS['КЗпП']);
    }
    
    if (documentType.includes('commercial') || documentType.includes('господарськ')) {
      laws.push(COMMON_LAWS['ГКУ']);
    }
    
    if (documentType.includes('vat') || documentType.includes('пдв')) {
      laws.push(COMMON_LAWS['ЗУ_ПДВ']);
    }
    
    return laws;
  }
  
  /**
   * Generate legal context for LLM prompt
   */
  async getLegalContext(documentType: string): Promise<string> {
    const applicableLaws = this.getApplicableLaws(documentType);
    
    let context = 'ЗАСТОСОВАНЕ ЗАКОНОДАВСТВО УКРАЇНИ:\n\n';
    
    for (const law of applicableLaws) {
      context += `${law.fullName} (${law.code}):\n`;
      context += `Джерело: ${law.url}\n`;
      
      if (law.keyArticles) {
        context += 'Ключові статті:\n';
        for (const [article, description] of Object.entries(law.keyArticles)) {
          context += `  - Стаття ${article}: ${description}\n`;
        }
      }
      
      context += '\n';
    }
    
    return context;
  }
  
  /**
   * Validate contract section against Ukrainian law
   */
  validateSection(sectionContent: string, lawCode: string, article: string): {
    valid: boolean;
    issues: string[];
  } {
    // TODO: Implement actual validation logic
    // For MVP, just return valid
    return {
      valid: true,
      issues: [],
    };
  }
  
  /**
   * Search for relevant law articles by keyword
   */
  searchArticles(keyword: string): Array<{
    lawCode: string;
    article: string;
    description: string;
  }> {
    const results: Array<{
      lawCode: string;
      article: string;
      description: string;
    }> = [];
    
    const lowerKeyword = keyword.toLowerCase();
    
    for (const [code, law] of Object.entries(COMMON_LAWS)) {
      if (law.keyArticles) {
        for (const [article, description] of Object.entries(law.keyArticles)) {
          if (description.toLowerCase().includes(lowerKeyword)) {
            results.push({
              lawCode: code,
              article,
              description,
            });
          }
        }
      }
    }
    
    return results;
  }
}

// Export singleton instance
export const ukrainianLawService = new UkrainianLawService();


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/types/generation-types.ts
════════════════════════════════════════════════════════════════

/**
 * Document Generation Types
 * 
 * FIX #10: gen-validator role
 * FIX #11: Partial<Record> for COMMON_CLAUSES (no `as any`)
 * FIX #18 (Feb 13, 2026): All ClauseType templates filled in (Ukrainian)
 */

import { BaseAgentOutput } from '../../core/orchestrator/types';

// ==========================================
// INPUT TYPES
// ==========================================

export interface DocumentGenerationRequest {
  documentType: DocumentType;
  requirements: string;
  jurisdiction?: string;
  parties?: PartyInfo[];
  specificClauses?: ClauseRequest[];
  template?: 'standard' | 'pro-client' | 'balanced' | 'custom';
}

export type DocumentType =
  | 'nda'
  | 'employment_agreement'
  | 'consulting_agreement'
  | 'saas_agreement'
  | 'vendor_contract'
  | 'partnership_agreement'
  | 'amendment'
  | 'custom_clause';

export interface PartyInfo {
  role: 'party_a' | 'party_b' | 'employer' | 'employee' | 'vendor' | 'client';
  name?: string;
  jurisdiction?: string;
  entityType?: 'individual' | 'corporation' | 'llc' | 'partnership';
}

export interface ClauseRequest {
  type: ClauseType;
  requirements: string;
  priority: 'must-have' | 'nice-to-have';
}

export type ClauseType =
  | 'termination'
  | 'liability'
  | 'indemnification'
  | 'confidentiality'
  | 'ip_assignment'
  | 'payment_terms'
  | 'dispute_resolution'
  | 'force_majeure'
  | 'warranties'
  | 'custom';

// ==========================================
// AGENT OUTPUTS (Generation-specific)
// ==========================================

export interface AnalyzerOutput extends BaseAgentOutput {
  role: 'analyzer';
  analysis: {
    structuredRequirements: StructuredRequirements;
    suggestedClauses: SuggestedClause[];
    potentialIssues: string[];
    clarificationsNeeded: string[];
  };
}

export interface DrafterOutput extends BaseAgentOutput {
  role: 'drafter';
  draft: {
    documentText: string;
    structure: DocumentStructure;
    includedClauses: GeneratedClause[];
    notes: string[];
  };
}

export interface GenerationValidatorOutput extends BaseAgentOutput {
  role: 'gen-validator';
  validation: {
    legalCompliance: ComplianceCheck[];
    missingElements: string[];
    riskFlags: RiskFlag[];
    overallScore: number;
    verdict: 'APPROVED' | 'NEEDS_REVISION';
  };
}

export interface PolisherOutput extends BaseAgentOutput {
  role: 'polisher';
  polished: {
    finalDocument: string;
    improvements: Improvement[];
    executiveSummary: string;
    keyTerms: KeyTerm[];
  };
}

// ==========================================
// DOMAIN OBJECTS
// ==========================================

export interface StructuredRequirements {
  documentType: DocumentType;
  parties: PartyInfo[];
  keyTerms: {
    duration?: string;
    paymentAmount?: string;
    deliverables?: string[];
    effectiveDate?: string;
  };
  mustHaveClauses: ClauseType[];
  jurisdiction: string;
  specialProvisions: string[];
}

export interface SuggestedClause {
  type: ClauseType;
  rationale: string;
  priority: 'essential' | 'recommended' | 'optional';
  standardText?: string;
}

export interface GeneratedClause {
  type: ClauseType;
  sectionNumber: string;
  title: string;
  text: string;
  alternatives?: string[];
}

export interface DocumentStructure {
  title: string;
  preamble: string;
  definitions: { term: string; definition: string }[];
  mainClauses: { section: string; title: string; subsections: number }[];
  signatures: { party: string; signatureLine: string }[];
}

export interface ComplianceCheck {
  requirement: string;
  status: 'met' | 'not_met' | 'partial';
  details: string;
}

export interface RiskFlag {
  severity: 1 | 2 | 3 | 4 | 5;
  issue: string;
  location: string;
  recommendation: string;
}

export interface Improvement {
  type: 'clarity' | 'legal_precision' | 'formatting' | 'tone';
  before: string;
  after: string;
  rationale: string;
}

export interface KeyTerm {
  term: string;
  definition: string;
  importance: 'high' | 'medium' | 'low';
}

// ==========================================
// FINAL OUTPUT
// ==========================================

export interface DocumentGenerationResponse {
  finalDocument: string;
  format: 'markdown' | 'docx' | 'pdf';
  
  metadata: {
    documentType: DocumentType;
    generatedAt: string;
    jurisdiction?: string;
    confidence: number;
    totalCost: number;
    processingTimeMs: number;
  };
  
  summary: {
    executiveSummary: string;
    keyTerms: KeyTerm[];
    includedClauses: string[];
  };
  
  qualityMetrics: {
    complianceScore: number;
    legalSoundness: number;
    clarity: number;
    overall: number;
  };
  
  recommendations: {
    beforeSigning: string[];
    customizations: string[];
    reviewAreas: string[];
  };
}

// ==========================================
// TEMPLATES
// ==========================================

export interface ClauseTemplate {
  type: ClauseType;
  jurisdiction: string;
  template: 'standard' | 'pro-client' | 'balanced';
  text: string;
  variables: string[];
}

/**
 * FIX #18: Complete set of clause templates (Ukrainian legal language).
 * Now a full Record — all ClauseType values present, no `as any` needed.
 */
export const COMMON_CLAUSES: Record<ClauseType, string> = {
  termination: `Кожна із Сторін має право розірвати цей Договір, попередивши іншу Сторону за [NOTICE_PERIOD] до передбачуваної дати розірвання шляхом направлення письмового повідомлення. У разі істотного порушення умов Договору однією із Сторін, інша Сторона має право розірвати Договір в односторонньому порядку відповідно до ст. 651 ЦКУ.`,

  liability: `Сторони несуть відповідальність за невиконання або неналежне виконання своїх зобов'язань за цим Договором відповідно до чинного законодавства України. У жодному випадку жодна із Сторін не несе відповідальності за непрямі, побічні або штрафні збитки.`,

  indemnification: `[PARTY_A] зобов'язується відшкодувати [PARTY_B] будь-які збитки, витрати та вимоги третіх осіб, що виникли внаслідок порушення [PARTY_A] умов цього Договору або чинного законодавства України.`,

  confidentiality: `Сторони зобов'язуються не розголошувати конфіденційну інформацію, отриману в процесі виконання цього Договору, протягом строку дії Договору та [CONFIDENTIALITY_PERIOD] після його припинення. Зобов'язання щодо конфіденційності не поширюються на інформацію, що стала загальнодоступною не з вини Сторони, яка її отримала.`,

  ip_assignment: `Усі права інтелектуальної власності на результати робіт, створені на виконання цього Договору, переходять до [PARTY_B] з моменту їх створення та повної оплати відповідно до ст. 430 ЦКУ. [PARTY_A] гарантує, що результати робіт є оригінальними та не порушують прав третіх осіб.`,

  payment_terms: `[PARTY_B] зобов'язується сплатити [PARTY_A] суму у розмірі [AMOUNT] грн (у тому числі ПДВ) протягом [PAYMENT_PERIOD] з моменту [PAYMENT_TRIGGER]. Оплата здійснюється безготівковим розрахунком на банківський рахунок [PARTY_A]. У разі прострочення оплати нараховується пеня у розмірі [PENALTY_RATE]% від суми заборгованості за кожен день прострочення.`,

  dispute_resolution: `Спори, що виникають з цього Договору, вирішуються шляхом переговорів. У разі неможливості вирішення спору шляхом переговорів протягом [NEGOTIATION_PERIOD], спір передається на розгляд до господарського суду за місцезнаходженням відповідача відповідно до ГПК України.`,

  force_majeure: `Сторони звільняються від відповідальності за часткове або повне невиконання зобов'язань за цим Договором, якщо це невиконання стало наслідком обставин непереборної сили (форс-мажор), а саме: стихійних лих, воєнних дій, ембарго, дій органів влади, епідемій тощо. Сторона, для якої склались форс-мажорні обставини, зобов'язана повідомити іншу Сторону протягом [FORCE_MAJEURE_NOTICE] з підтвердженням ТПП України.`,

  warranties: `[PARTY_A] гарантує, що: (а) має всі необхідні дозволи та ліцензії для виконання цього Договору; (б) виконання Договору не порушує права третіх осіб; (в) результати робіт відповідатимуть вимогам, зазначеним у Додатку №1 до цього Договору.`,

  custom: `[CUSTOM_CLAUSE_TEXT]`,
};

// ==========================================
// HELPER FUNCTIONS
// ==========================================

export function getDocumentTypeLabel(type: DocumentType): string {
  const labels: Record<DocumentType, string> = {
    nda: 'Non-Disclosure Agreement',
    employment_agreement: 'Employment Agreement',
    consulting_agreement: 'Consulting Agreement',
    saas_agreement: 'SaaS Agreement',
    vendor_contract: 'Vendor Contract',
    partnership_agreement: 'Partnership Agreement',
    amendment: 'Contract Amendment',
    custom_clause: 'Custom Clause',
  };
  return labels[type];
}

/**
 * FIX #20: Document download formatting
 * Currently only markdown is fully supported.
 * DOCX and PDF require additional libraries (docx, pdfkit).
 */
export function formatDocumentForDownload(
  text: string,
  format: 'markdown' | 'docx' | 'pdf'
): string {
  switch (format) {
    case 'markdown':
      return text;
    case 'docx':
      // TODO: Integrate 'docx' library for proper Word export
      console.warn('⚠️ DOCX export not yet implemented — returning markdown');
      return text;
    case 'pdf':
      // TODO: Integrate 'pdfkit' or 'puppeteer' for PDF export
      console.warn('⚠️ PDF export not yet implemented — returning markdown');
      return text;
    default:
      return text;
  }
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/types/review-types.ts
════════════════════════════════════════════════════════════════

/**
 * Contract Review Types
 * Specific to the Review Tab workflow
 */

import { BaseAgentOutput } from '../../core/orchestrator/types';

// ==========================================
// INPUT TYPES
// ==========================================

export interface ContractReviewRequest {
  contractText: string;
  contractType?: ContractType;
  jurisdiction?: string;
  specificQuestions?: string[];
  focusAreas?: FocusArea[];
}

export type ContractType =
  | 'employment'
  | 'vendor'
  | 'saas'
  | 'nda'
  | 'consulting'
  | 'partnership'
  | 'custom';

export type FocusArea =
  | 'termination'
  | 'liability'
  | 'payment'
  | 'ip_rights'
  | 'confidentiality'
  | 'warranties'
  | 'dispute_resolution';

// ==========================================
// AGENT OUTPUTS (Review-specific)
// ==========================================

export interface ExpertOutput extends BaseAgentOutput {
  role: 'expert';
  analysis: {
    executiveSummary: string;
    keyIssues: Issue[];
    clauseAnalysis: ClauseAnalysis[];
    overallRiskScore: number; // 1-10
    recommendations: Recommendation[];
  };
}

export interface ProvocateurOutput extends BaseAgentOutput {
  role: 'provocateur';
  critique: {
    flaws: Flaw[];
    maxSeverity: number; // Highest flaw severity
    exploitationScenarios: string[];
  };
}

export interface ValidatorOutput extends BaseAgentOutput {
  role: 'validator';
  validation: {
    isComplete: boolean;
    completenessScore: number; // 0-100
    missingAspects: string[];
    contradictions: Contradiction[];
    verdict: 'COMPLETE' | 'NEEDS_REVISION';
  };
}

export interface SynthesizerOutput extends BaseAgentOutput {
  role: 'synthesizer';
  synthesis: {
    summary: string;
    criticalRisks: CriticalRisk[];
    recommendations: Recommendation[];
    confidence: number;
    keyDisagreements: string[];
  };
}

// ==========================================
// DOMAIN OBJECTS
// ==========================================

export interface Issue {
  id: string;
  title: string;
  description: string;
  severity: Severity;
  clauseReference?: string;
  category: IssueCategory;
  legalBasis?: string;
}

export type Severity = 1 | 2 | 3 | 4 | 5; // 5 = critical

export type IssueCategory =
  | 'ambiguous_language'
  | 'missing_protection'
  | 'liability_gap'
  | 'unfavorable_terms'
  | 'compliance_risk'
  | 'termination_risk';

export interface ClauseAnalysis {
  sectionNumber: string;
  title: string;
  content: string;
  assessment: 'favorable' | 'neutral' | 'unfavorable' | 'critical';
  issues: string[];
  recommendations: string[];
}

export interface Flaw {
  id: string;
  severity: Severity;
  clauseReference: string;
  issue: string;
  exploitationScenario: string;
  suggestedFix: string;
}

export interface Contradiction {
  source1: string; // e.g., "Expert"
  source2: string; // e.g., "Provocateur"
  subject: string;
  description: string;
}

export interface Recommendation {
  priority: 'high' | 'medium' | 'low';
  action: string;
  rationale: string;
  specificLanguage?: string; // Suggested clause text
}

export interface CriticalRisk {
  title: string;
  description: string;
  impact: string;
  mitigation: string;
}

// ==========================================
// FINAL OUTPUT
// ==========================================

export interface ContractReviewResponse {
  summary: string;
  overallRiskScore: number; // 1-10
  confidence: number; // 0-1
  
  criticalRisks: CriticalRisk[];
  recommendations: Recommendation[];
  
  detailedAnalysis: {
    expertAnalysis: ExpertOutput['analysis'];
    flawsFound: Flaw[];
    validationResults: ValidatorOutput['validation'];
  };
  
  metadata: {
    contractType: ContractType;
    jurisdiction?: string;
    analyzedAt: string;
    totalCost: number;
    processingTimeMs: number;
  };
}

// ==========================================
// HELPER FUNCTIONS
// ==========================================

export function getSeverityLabel(severity: Severity): string {
  const labels = {
    1: 'Minor',
    2: 'Low',
    3: 'Moderate',
    4: 'High',
    5: 'Critical',
  };
  return labels[severity];
}

export function getRiskColor(score: number): string {
  if (score >= 8) return 'red';
  if (score >= 6) return 'orange';
  if (score >= 4) return 'yellow';
  return 'green';
}


════════════════════════════════════════════════════════════════
FILE: packages/legal-council/utils/logger.ts
════════════════════════════════════════════════════════════════

/**
 * Logger utility for Legal Council
 * 
 * FIX #16 (Feb 13, 2026):
 * Replaces raw console.log/error throughout codebase with level-based logging.
 * In production, debug-level messages (raw LLM responses, token counts) are suppressed.
 * In development/testing, all levels are visible.
 * 
 * Prevents leaking confidential contract text into production logs.
 */

type LogLevel = 'debug' | 'info' | 'warn' | 'error';

const LOG_LEVELS: Record<LogLevel, number> = {
  debug: 0,
  info: 1,
  warn: 2,
  error: 3,
};

// Determine minimum log level from environment
function getMinLevel(): LogLevel {
  const env = process.env.LEGAL_COUNCIL_ENV || process.env.NODE_ENV || 'development';
  switch (env) {
    case 'production':
      return 'info'; // No debug in production
    case 'testing':
      return 'debug'; // All logs in testing
    case 'development':
    default:
      return 'debug'; // All logs in development
  }
}

const MIN_LEVEL = getMinLevel();

class Logger {
  private prefix: string;

  constructor(prefix: string = '') {
    this.prefix = prefix;
  }

  /**
   * Create a child logger with a prefix (e.g., agent ID)
   */
  child(prefix: string): Logger {
    return new Logger(prefix);
  }

  /**
   * Debug: Raw LLM responses, token counts, parsing details.
   * SUPPRESSED in production to avoid leaking contract text.
   */
  debug(message: string, data?: any): void {
    if (LOG_LEVELS.debug >= LOG_LEVELS[MIN_LEVEL]) {
      const formatted = this.format(message);
      if (data !== undefined) {
        console.log(formatted, data);
      } else {
        console.log(formatted);
      }
    }
  }

  /**
   * Info: Agent start/complete, orchestrator progress, cost summaries.
   */
  info(message: string, data?: any): void {
    if (LOG_LEVELS.info >= LOG_LEVELS[MIN_LEVEL]) {
      const formatted = this.format(message);
      if (data !== undefined) {
        console.log(formatted, data);
      } else {
        console.log(formatted);
      }
    }
  }

  /**
   * Warn: Missing optional fields, fallbacks triggered, degraded quality.
   */
  warn(message: string, data?: any): void {
    if (LOG_LEVELS.warn >= LOG_LEVELS[MIN_LEVEL]) {
      const formatted = this.format(message);
      if (data !== undefined) {
        console.warn(formatted, data);
      } else {
        console.warn(formatted);
      }
    }
  }

  /**
   * Error: Agent failures, API errors, parsing failures.
   * Always visible in all environments.
   */
  error(message: string, data?: any): void {
    const formatted = this.format(message);
    if (data !== undefined) {
      console.error(formatted, data);
    } else {
      console.error(formatted);
    }
  }

  private format(message: string): string {
    if (this.prefix) {
      return `[${this.prefix}] ${message}`;
    }
    return message;
  }
}

// Default logger instance
export const logger = new Logger();

// Factory for agent-specific loggers
export function createAgentLogger(agentId: string): Logger {
  return new Logger(agentId);
}

export default logger;


════════════════════════════════════════════════════════════════
FILE: app/api/generate/route.ts
════════════════════════════════════════════════════════════════

/**
 * API Route: Document Generation
 * POST /api/generate
 * 
 * FIX #15 (Feb 13, 2026): Added text size validation
 *   — Max 10,000 chars for requirements
 *   — Clear error messages
 */

import { NextRequest, NextResponse } from 'next/server';
import { GenerationOrchestrator } from '../../../packages/legal-council/orchestrators/generation-orchestrator';
import type { DocumentGenerationRequest } from '../../../packages/legal-council/types/generation-types';

// ==========================================
// NEXT.JS 14 ROUTE SEGMENT CONFIG
// ==========================================

export const maxDuration = 300;
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// FIX #15: Size limits
const MAX_REQUIREMENTS_CHARS = 10_000;
const MIN_REQUIREMENTS_CHARS = 20;

// ==========================================
// POST HANDLER
// ==========================================

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate required fields
    if (!body.documentType || typeof body.documentType !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid documentType field' },
        { status: 400 }
      );
    }

    if (!body.requirements || typeof body.requirements !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid requirements field' },
        { status: 400 }
      );
    }

    // FIX #15: Size validation
    const reqLength = body.requirements.length;

    if (reqLength < MIN_REQUIREMENTS_CHARS) {
      return NextResponse.json(
        { error: `Вимоги занадто короткі (${reqLength} символів). Мінімум: ${MIN_REQUIREMENTS_CHARS} символів. Опишіть деталі договору.` },
        { status: 400 }
      );
    }

    if (reqLength > MAX_REQUIREMENTS_CHARS) {
      return NextResponse.json(
        { error: `Вимоги занадто довгі (${reqLength} символів). Максимум: ${MAX_REQUIREMENTS_CHARS} символів. Спробуйте скоротити опис.` },
        { status: 400 }
      );
    }

    // Build request
    const generationRequest: DocumentGenerationRequest = {
      documentType: body.documentType,
      requirements: body.requirements,
      jurisdiction: body.jurisdiction || 'Ukraine',
      parties: body.parties,
      specificClauses: body.specificClauses,
      template: body.template || 'balanced',
    };

    console.log(`📝 Generation request received: ${generationRequest.documentType}`);

    // Initialize orchestrator
    const orchestrator = new GenerationOrchestrator({
      maxRevisions: 2,
      enableAuditTrail: true,
    });

    // Run generation
    const startTime = Date.now();
    const result = await orchestrator.generate(generationRequest);
    const duration = Date.now() - startTime;

    console.log(`✅ Generation complete in ${(duration / 1000).toFixed(1)}s`);
    console.log(`   Cost: $${result.metadata.totalCost.toFixed(4)}`);
    console.log(`   Quality: ${result.qualityMetrics.overall}%`);

    // Return response
    return NextResponse.json({
      success: true,
      data: result,
      metadata: {
        processingTimeMs: duration,
        timestamp: new Date().toISOString(),
      },
    });

  } catch (error) {
    console.error('❌ Generation API error:', error);

    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        return NextResponse.json(
          { error: 'Invalid API configuration. Please check environment variables.' },
          { status: 500 }
        );
      }
      if (error.message.includes('rate limit')) {
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please try again later.' },
          { status: 429 }
        );
      }
      if (error.message.includes('Invalid') || error.message.includes('Missing')) {
        return NextResponse.json(
          { error: error.message },
          { status: 400 }
        );
      }
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}


════════════════════════════════════════════════════════════════
FILE: app/api/review/route.ts
════════════════════════════════════════════════════════════════

/**
 * API Route: Contract Review
 * POST /api/review
 * 
 * FIX #15 (Feb 13, 2026): Added contract text size validation
 *   — Max 50,000 chars (~25 pages) to prevent context window overflow
 *   — Clear Ukrainian error message for users
 */

import { NextRequest, NextResponse } from 'next/server';
import { ReviewOrchestrator } from '../../../packages/legal-council/orchestrators/review-orchestrator';
import type { ContractReviewRequest } from '../../../packages/legal-council/types/review-types';

// ==========================================
// NEXT.JS 14 ROUTE SEGMENT CONFIG
// ==========================================

export const maxDuration = 300;
export const dynamic = 'force-dynamic';
export const runtime = 'nodejs';

// FIX #15: Size limits
const MAX_CONTRACT_CHARS = 50_000; // ~25 pages, fits in most LLM context windows
const MIN_CONTRACT_CHARS = 50;     // At least something meaningful

// ==========================================
// POST HANDLER
// ==========================================

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    
    // Validate required fields
    if (!body.contractText || typeof body.contractText !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid contractText field' },
        { status: 400 }
      );
    }

    // FIX #15: Size validation
    const textLength = body.contractText.length;

    if (textLength < MIN_CONTRACT_CHARS) {
      return NextResponse.json(
        { error: `Текст контракту занадто короткий (${textLength} символів). Мінімум: ${MIN_CONTRACT_CHARS} символів.` },
        { status: 400 }
      );
    }

    if (textLength > MAX_CONTRACT_CHARS) {
      return NextResponse.json(
        { error: `Текст контракту занадто довгий (${textLength} символів). Максимум: ${MAX_CONTRACT_CHARS} символів (~25 сторінок). Будь ласка, розділіть документ на частини.` },
        { status: 400 }
      );
    }

    // Build request
    const reviewRequest: ContractReviewRequest = {
      contractText: body.contractText,
      contractType: body.contractType,
      jurisdiction: body.jurisdiction || 'Ukraine',
      specificQuestions: body.specificQuestions,
      focusAreas: body.focusAreas,
    };

    console.log(`📋 Review request received (${reviewRequest.contractText.length} chars)`);

    // Initialize orchestrator
    const orchestrator = new ReviewOrchestrator({
      maxRounds: 3,
      maxSeverityThreshold: 3,
      minConfidence: 0.85,
      enableAuditTrail: true,
    });

    // Run analysis
    const startTime = Date.now();
    const result = await orchestrator.analyze(reviewRequest);
    const duration = Date.now() - startTime;

    console.log(`✅ Review complete in ${(duration / 1000).toFixed(1)}s`);
    console.log(`   Cost: $${result.metadata.totalCost.toFixed(4)}`);
    console.log(`   Confidence: ${(result.confidence * 100).toFixed(0)}%`);

    // Return response
    return NextResponse.json({
      success: true,
      data: result,
      metadata: {
        processingTimeMs: duration,
        timestamp: new Date().toISOString(),
      },
    });

  } catch (error) {
    console.error('❌ Review API error:', error);

    if (error instanceof Error) {
      if (error.message.includes('API key')) {
        return NextResponse.json(
          { error: 'Invalid API configuration. Please check environment variables.' },
          { status: 500 }
        );
      }
      if (error.message.includes('rate limit')) {
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please try again later.' },
          { status: 429 }
        );
      }
      return NextResponse.json({ error: error.message }, { status: 500 });
    }

    return NextResponse.json({ error: 'Internal server error' }, { status: 500 });
  }
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/api/review/route.ts
════════════════════════════════════════════════════════════════

/**
 * API Route: Contract Review (Proxy to Real Backend)
 * POST /api/review
 *
 * FIX #1 (Feb 13, 2026):
 * Replaced mock API (generateMockRisks) with a proxy that forwards
 * requests to the real backend ReviewOrchestrator.
 *
 * Set NEXT_PUBLIC_API_URL or BACKEND_URL in .env to point to the
 * backend server (e.g., http://localhost:3000 for the root Next.js app).
 */

import { NextRequest, NextResponse } from 'next/server'

// Route config
export const maxDuration = 300 // 5 min for complex contracts
export const dynamic = 'force-dynamic'
export const runtime = 'nodejs'

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()

    // Validate
    if (!body.contractText || typeof body.contractText !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid contractText field' },
        { status: 400 }
      )
    }

    console.log(`📋 Review request: ${body.contractText.length} chars, type: ${body.contractType || 'unknown'}`)

    // Determine backend URL
    const backendUrl = process.env.NEXT_PUBLIC_API_URL || process.env.BACKEND_URL

    if (!backendUrl) {
      console.error('❌ No backend URL configured')
      return NextResponse.json(
        {
          error:
            'Бекенд не налаштований. Встановіть NEXT_PUBLIC_API_URL або BACKEND_URL в .env (наприклад: http://localhost:3000)',
        },
        { status: 503 }
      )
    }

    // Proxy to real backend
    const apiUrl = `${backendUrl}/api/review`
    console.log(`🔗 Proxying to: ${apiUrl}`)

    const backendResponse = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        contractText: body.contractText,
        contractType: body.contractType,
        jurisdiction: body.jurisdiction || 'Ukraine',
        specificQuestions: body.specificQuestions,
        focusAreas: body.focusAreas,
      }),
    })

    if (!backendResponse.ok) {
      const errorData = await backendResponse.json().catch(() => ({}))
      console.error('❌ Backend error:', backendResponse.status, errorData)
      return NextResponse.json(
        { error: errorData.error || `Помилка бекенду: ${backendResponse.status}` },
        { status: backendResponse.status }
      )
    }

    const data = await backendResponse.json()
    return NextResponse.json(data)

  } catch (error) {
    console.error('❌ Review proxy error:', error)

    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    )
  }
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/(app)/history/page.tsx
════════════════════════════════════════════════════════════════

import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/shared/ui'

export default function HistoryPage() {
  return (
    <div className="container mx-auto max-w-7xl p-6">
      <div className="mb-8">
        <h1 className="text-3xl font-bold">Історія Аналізів</h1>
        <p className="text-gray-500">
          Перегляд попередніх аналізів контрактів
        </p>
      </div>

      <Card>
        <CardHeader>
          <CardTitle>Історія порожня</CardTitle>
          <CardDescription>
            Ви ще не проводили жодного аналізу
          </CardDescription>
        </CardHeader>
        <CardContent>
          <p className="text-sm text-gray-500">
            Почніть з аналізу вашого першого контракту на сторінці "Огляд Контрактів"
          </p>
        </CardContent>
      </Card>
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/(app)/layout.tsx
════════════════════════════════════════════════════════════════

export default function AppLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return <>{children}</>
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/(app)/review/page.tsx
════════════════════════════════════════════════════════════════

'use client'

/**
 * Review Page - Contract Analysis
 *
 * FIXES (Feb 13, 2026):
 * - #1: Calls real backend API (via NEXT_PUBLIC_API_URL or proxy route) instead of mock
 * - #2: Maps ContractReviewResponse (criticalRisks, recommendations, detailedAnalysis)
 *       to RiskItem[] that RiskDashboard expects
 * - #3: Removed setTimeout race conditions — agent progress is now sequential
 *
 * FIX H2 (Feb 14, 2026): Backend sends `keyIssues`, not `issues`
 * FIX L2 (Feb 14, 2026): "Зберегти звіт" button now downloads JSON report
 */

import { useState, useCallback } from 'react'
import { Card, CardContent, CardHeader, CardTitle, Button } from '@/shared/ui'
import { SplitView, RiskDashboard, AgentProgress } from '@/shared/components'
import { useAnalysisStore } from '@/stores/analysis'
import type { RiskSeverity } from '@/shared/types'

// ==========================================
// Backend response types
// ==========================================

interface BackendCriticalRisk {
  title: string
  description: string
  impact: string
  mitigation: string
}

interface BackendRecommendation {
  priority: 'high' | 'medium' | 'low'
  action: string
  rationale: string
  specificLanguage?: string
}

// FIX H2: Added clauseReference and category
interface BackendIssue {
  id: string
  severity: number
  title: string
  description: string
  legalBasis?: string
  recommendation?: string
  clauseReference?: string
  category?: string
}

// FIX H2: keyIssues (not issues)
interface ContractReviewResponse {
  summary: string
  overallRiskScore: number
  confidence: number
  criticalRisks: BackendCriticalRisk[]
  recommendations: BackendRecommendation[]
  detailedAnalysis: {
    expertAnalysis: {
      executiveSummary: string
      keyIssues: BackendIssue[]
      clauseAnalysis: any[]
      overallRiskScore: number
      recommendations: any[]
    }
    flawsFound: Array<{
      id: string
      severity: number
      issue: string
      clauseReference?: string
      exploitationScenario?: string
      suggestedFix?: string
    }>
    validationResults: any
  }
  metadata: {
    contractType: string
    jurisdiction?: string
    analyzedAt: string
    totalCost: number
    processingTimeMs: number
  }
}

// ==========================================
// Map backend response → RiskItem[]
// ==========================================

function mapResponseToRisks(response: ContractReviewResponse): any[] {
  const risks: any[] = []
  let riskId = 1

  // 1. Critical risks (severity 5)
  if (response.criticalRisks) {
    for (const cr of response.criticalRisks) {
      risks.push({
        id: String(riskId++),
        severity: 5 as RiskSeverity,
        title: cr.title,
        description: cr.description,
        recommendation: cr.mitigation,
        contractExcerpt: cr.impact,
        confidence: Math.round((response.confidence || 0.85) * 100),
        agentName: 'Синтезатор',
      })
    }
  }

  // 2. Expert issues — FIX H2: keyIssues
  if (response.detailedAnalysis?.expertAnalysis?.keyIssues) {
    for (const issue of response.detailedAnalysis.expertAnalysis.keyIssues) {
      const alreadyMapped = risks.some(
        (r) => r.title === issue.title && r.severity === issue.severity
      )
      if (alreadyMapped) continue

      risks.push({
        id: String(riskId++),
        severity: (Math.min(5, Math.max(1, issue.severity)) as RiskSeverity),
        title: issue.title,
        description: issue.description,
        legalCitation: issue.legalBasis,
        recommendation: issue.recommendation,
        contractExcerpt: issue.clauseReference,
        confidence: Math.round((response.confidence || 0.85) * 100),
        agentName: 'Експерт',
      })
    }
  }

  // 3. Provocateur flaws
  if (response.detailedAnalysis?.flawsFound) {
    for (const flaw of response.detailedAnalysis.flawsFound) {
      const flawTitle = flaw.issue || flaw.id
      const alreadyMapped = risks.some((r) => r.title === flawTitle)
      if (alreadyMapped) continue

      risks.push({
        id: String(riskId++),
        severity: (Math.min(5, Math.max(1, flaw.severity)) as RiskSeverity),
        title: flawTitle,
        description: flaw.exploitationScenario || '',
        recommendation: flaw.suggestedFix,
        contractExcerpt: flaw.clauseReference,
        confidence: Math.round((response.confidence || 0.85) * 100),
        agentName: 'Провокатор',
      })
    }
  }

  // 4. Recommendations as low-severity informational items
  if (response.recommendations) {
    for (const rec of response.recommendations) {
      const severity = rec.priority === 'high' ? 3 : rec.priority === 'medium' ? 2 : 1
      risks.push({
        id: String(riskId++),
        severity: severity as RiskSeverity,
        title: rec.action,
        description: rec.rationale,
        recommendation: rec.specificLanguage,
        confidence: Math.round((response.confidence || 0.85) * 100),
        agentName: 'Валідатор',
      })
    }
  }

  return risks
}

// ==========================================
// FIX L2: Save report as JSON download
// ==========================================

function downloadReport(
  response: ContractReviewResponse | null,
  risks: any[],
  contractType: string
) {
  if (!response) return

  const report = {
    title: 'AGENTIS — Звіт Аналізу Контракту',
    generatedAt: new Date().toISOString(),
    contractType,
    summary: response.summary,
    overallRiskScore: response.overallRiskScore,
    confidence: response.confidence,
    risks: risks.map((r) => ({
      severity: r.severity,
      title: r.title,
      description: r.description,
      legalCitation: r.legalCitation,
      recommendation: r.recommendation,
      agent: r.agentName,
    })),
    criticalRisks: response.criticalRisks,
    recommendations: response.recommendations,
    metadata: response.metadata,
  }

  const blob = new Blob([JSON.stringify(report, null, 2)], {
    type: 'application/json',
  })
  const url = URL.createObjectURL(blob)
  const a = document.createElement('a')
  a.href = url
  const date = new Date().toISOString().slice(0, 10)
  a.download = `agentis-report-${contractType}-${date}.json`
  document.body.appendChild(a)
  a.click()
  document.body.removeChild(a)
  URL.revokeObjectURL(url)
}

// ==========================================
// REVIEW PAGE COMPONENT
// ==========================================

export default function ReviewPage() {
  const [contractText, setContractText] = useState('')
  const [contractType, setContractType] = useState<string>('оренда')
  const [showResults, setShowResults] = useState(false)
  const [risks, setRisks] = useState<any[]>([])
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [summary, setSummary] = useState<string>('')
  const [overallScore, setOverallScore] = useState<number>(0)
  // FIX L2: Store raw response for report download
  const [rawResponse, setRawResponse] = useState<ContractReviewResponse | null>(null)

  const {
    isAnalyzing,
    agents,
    startAnalysis,
    resetAnalysis,
    updateAgentStatus,
    completeAgent,
  } = useAnalysisStore()

  const handleAnalyze = async () => {
    if (!contractText.trim()) {
      alert('Будь ласка, введіть текст контракту')
      return
    }

    setIsLoading(true)
    setError(null)
    setRawResponse(null)
    startAnalysis()
    setShowResults(true)

    try {
      // Stage 1: Expert
      updateAgentStatus('expert', 'running', 'Аналізую відповідність законодавству...')

      const response = await fetch('/api/review', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contractText,
          contractType,
        }),
      })

      if (!response.ok) {
        const errorBody = await response.json().catch(() => ({}))
        throw new Error(errorBody.error || `Сервер повернув помилку: ${response.status}`)
      }

      const result = await response.json()

      // Stage 2: Expert done
      updateAgentStatus('expert', 'completed', 'Аналіз законодавства завершено')

      // Stage 3: Provocateur
      updateAgentStatus('provocateur', 'running', 'Перевіряю приховані ризики...')
      await new Promise((r) => setTimeout(r, 300))
      updateAgentStatus('provocateur', 'completed', 'Слабкі місця виявлено')

      // Stage 4: Validator
      updateAgentStatus('validator', 'running', 'Перевіряю висновки...')
      await new Promise((r) => setTimeout(r, 300))
      updateAgentStatus('validator', 'completed', 'Суперечностей не знайдено')

      // Stage 5: Synthesizer
      updateAgentStatus('synthesizer', 'running', 'Формую фінальний звіт...')

      const reviewData: ContractReviewResponse = result.data
      const mappedRisks = mapResponseToRisks(reviewData)

      setSummary(reviewData.summary || '')
      setOverallScore(reviewData.overallRiskScore || 0)
      setRawResponse(reviewData) // FIX L2

      await new Promise((r) => setTimeout(r, 300))
      updateAgentStatus('synthesizer', 'completed', 'Звіт готовий')

      setRisks(mappedRisks)
      setIsLoading(false)
      resetAnalysis()

    } catch (err) {
      console.error('Analysis error:', err)
      setError(
        err instanceof Error
          ? err.message
          : 'Помилка при аналізі. Спробуйте ще раз.'
      )
      setIsLoading(false)
      resetAnalysis()
    }
  }

  const handleReset = () => {
    setContractText('')
    setContractType('оренда')
    setShowResults(false)
    setRisks([])
    setError(null)
    setSummary('')
    setOverallScore(0)
    setRawResponse(null)
    resetAnalysis()
  }

  // FIX L2: Save report handler
  const handleSaveReport = useCallback(() => {
    downloadReport(rawResponse, risks, contractType)
  }, [rawResponse, risks, contractType])

  const handleRiskClick = (risk: any) => {
    console.log('Risk clicked:', risk)
  }

  // BEFORE analysis: Show upload form
  if (!showResults) {
    return (
      <div className="container mx-auto max-w-4xl p-6">
        <div className="mb-8">
          <h1 className="text-heading-lg">Аналіз Контракту</h1>
          <p className="text-gray-500 mt-2">
            Завантажте договір для експертного аналізу з використанням 4 AI-агентів
          </p>
        </div>

        <Card>
          <CardHeader>
            <CardTitle>Введіть Контракт</CardTitle>
          </CardHeader>
          <CardContent className="space-y-4">
            <div>
              <label className="mb-2 block text-sm font-medium">
                Тип Договору
              </label>
              <select
                value={contractType}
                onChange={(e) => setContractType(e.target.value)}
                className="flex h-10 w-full rounded-md border border-input bg-white px-3 py-2 text-sm ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50"
              >
                <option value="оренда">Оренда</option>
                <option value="поставка">Поставка</option>
                <option value="послуги">Послуги</option>
                <option value="трудовий">Трудовий</option>
                <option value="підряд">Підряд</option>
                <option value="купівля-продаж">Купівля-продаж</option>
                <option value="інше">Інше</option>
              </select>
            </div>

            <div>
              <label className="mb-2 block text-sm font-medium">
                Текст Договору
              </label>
              <textarea
                value={contractText}
                onChange={(e) => setContractText(e.target.value)}
                placeholder="Вставте текст договору тут...

Приклад:
ДОГОВІР ОРЕНДИ НЕРУХОМОГО МАЙНА

1. ПРЕДМЕТ ДОГОВОРУ
1.1. Орендодавець передає, а Орендатор приймає в строкове платне користування..."
                className="contract-text custom-scrollbar min-h-[400px] w-full rounded-md border border-input bg-white p-4 text-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring"
              />
              <p className="mt-2 text-xs text-gray-500">
                Символів: {contractText.length}
              </p>
            </div>

            <div className="flex gap-3">
              <Button
                onClick={handleAnalyze}
                disabled={!contractText.trim()}
                className="flex-1"
              >
                Проаналізувати →
              </Button>
            </div>
          </CardContent>
        </Card>

        <div className="mt-8 grid gap-6 md:grid-cols-2">
          <Card>
            <CardContent className="pt-6">
              <div className="flex gap-3">
                <div className="text-2xl">⚡</div>
                <div>
                  <h4 className="font-semibold">Швидкий аналіз</h4>
                  <p className="text-sm text-gray-500">
                    Результат за 60-90 секунд
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>

          <Card>
            <CardContent className="pt-6">
              <div className="flex gap-3">
                <div className="text-2xl">🔒</div>
                <div>
                  <h4 className="font-semibold">Конфіденційність</h4>
                  <p className="text-sm text-gray-500">
                    Ваші дані захищені
                  </p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    )
  }

  // DURING/AFTER analysis: Show split view
  return (
    <div className="flex flex-col">
      <div className="flex items-center justify-between border-b bg-white px-6 py-4">
        <div>
          <h1 className="text-xl font-semibold">Аналіз Контракту</h1>
          <p className="text-sm text-gray-500">
            {contractType.charAt(0).toUpperCase() + contractType.slice(1)} • {contractText.length} символів
            {overallScore > 0 && ` • Ризик: ${overallScore}/10`}
          </p>
        </div>

        <div className="flex gap-2">
          {!isAnalyzing && (
            <>
              <Button variant="outline" size="sm" onClick={handleReset}>
                ← Новий аналіз
              </Button>
              {/* FIX L2: Button now triggers JSON download */}
              <Button
                variant="outline"
                size="sm"
                onClick={handleSaveReport}
                disabled={!rawResponse}
              >
                Зберегти звіт
              </Button>
            </>
          )}
          {isAnalyzing && (
            <Button variant="outline" size="sm" onClick={handleReset}>
              Скасувати
            </Button>
          )}
        </div>
      </div>

      <SplitView
        leftContent={
          <div className="space-y-md">
            <div className="sticky top-0 bg-white pb-2">
              <h2 className="text-lg font-semibold">Текст Договору</h2>
              <p className="text-sm text-gray-500">
                IBM Plex Serif для кращої читабельності
              </p>
            </div>
            
            <div className="contract-text custom-scrollbar whitespace-pre-wrap rounded-md border bg-white p-lg font-serif">
              {contractText || 'Текст контракту відсутній'}
            </div>
          </div>
        }
        rightContent={
          <div className="space-y-md">
            {isAnalyzing ? (
              <Card>
                <CardHeader>
                  <CardTitle>Процес Аналізу</CardTitle>
                </CardHeader>
                <CardContent>
                  <AgentProgress
                    agents={Object.values(agents).map((agent) => ({
                      name: agent.name,
                      status: agent.status,
                      message: agent.message,
                    }))}
                  />
                </CardContent>
              </Card>
            ) : (
              <>
                {error && (
                  <div className="rounded-md border border-red-200 bg-red-50 p-4 mb-4">
                    <div className="flex items-start gap-3">
                      <span className="text-xl">❌</span>
                      <div>
                        <h4 className="font-semibold text-red-900">Помилка</h4>
                        <p className="text-sm text-red-700">{error}</p>
                      </div>
                    </div>
                  </div>
                )}

                {summary && (
                  <Card>
                    <CardHeader>
                      <CardTitle>Висновок</CardTitle>
                    </CardHeader>
                    <CardContent>
                      <p className="text-sm text-gray-700 whitespace-pre-wrap">{summary}</p>
                    </CardContent>
                  </Card>
                )}
                
                <RiskDashboard
                  risks={risks}
                  onRiskClick={handleRiskClick}
                />
              </>
            )}
          </div>
        }
      />
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/globals.css
════════════════════════════════════════════════════════════════

@tailwind base;
@tailwind components;
@tailwind utilities;

/* Simple, working CSS - no HSL variables! */

@layer base {
  * {
    border-color: #E5E7EB;
  }
  
  body {
    background-color: #FAFAFA; /* Off-white */
    color: #0F172A; /* Slate 900 */
    font-family: Inter, system-ui, sans-serif;
    font-feature-settings: "rlig" 1, "calt" 1;
  }
  
  h1, h2, h3, h4, h5, h6 {
    font-family: var(--font-inter), Inter, sans-serif;
    font-weight: 600;
  }
}

@layer components {
  /* Contract text - IBM Plex Serif */
  .contract-text {
    font-family: var(--font-ibm-plex-serif), Georgia, serif;
    font-size: 16px;
    line-height: 1.75;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  
  /* Risk severity styles */
  .risk-critical {
    color: #BE123C;
    border-color: #BE123C;
    background-color: rgba(190, 18, 60, 0.05);
  }
  
  .risk-high {
    color: #D97706;
    border-color: #D97706;
    background-color: rgba(217, 119, 6, 0.05);
  }
  
  .risk-medium {
    color: #B8860B;
    border-color: #B8860B;
    background-color: rgba(184, 134, 11, 0.05);
  }
  
  .risk-low {
    color: #15803D;
    border-color: #15803D;
    background-color: rgba(21, 128, 61, 0.05);
  }
  
  .risk-safe {
    color: #15803D;
    border-color: #15803D;
    background-color: rgba(21, 128, 61, 0.05);
  }
  
  /* Custom scrollbar */
  .custom-scrollbar::-webkit-scrollbar {
    width: 8px;
    height: 8px;
  }
  
  .custom-scrollbar::-webkit-scrollbar-track {
    background-color: #F3F4F6;
  }
  
  .custom-scrollbar::-webkit-scrollbar-thumb {
    background-color: rgba(107, 114, 128, 0.3);
    border-radius: 4px;
  }
  
  .custom-scrollbar::-webkit-scrollbar-thumb:hover {
    background-color: rgba(107, 114, 128, 0.5);
  }
}

@layer utilities {
  /* Animations - subtle 150ms */
  .animate-fade-in {
    animation: fadeIn 150ms ease-out;
  }
  
  .animate-slide-up {
    animation: slideUp 150ms ease-out;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes slideUp {
    from { 
      transform: translateY(10px);
      opacity: 0;
    }
    to { 
      transform: translateY(0);
      opacity: 1;
    }
  }
  
  /* Split view layout */
  .split-view {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0;
    min-height: calc(100vh - 4rem);
  }
  
  .split-pane {
    overflow-y: auto;
    padding: 24px;
  }
  
  /* Risk badge */
  .risk-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    border-radius: 4px;
    padding: 2px 10px;
    font-size: 12px;
    font-weight: 600;
    transition: all 150ms ease-out;
  }
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/layout.tsx
════════════════════════════════════════════════════════════════

import type { Metadata } from 'next'
import { Inter, JetBrains_Mono, IBM_Plex_Serif } from 'next/font/google'
import { Header, Footer } from '@/shared/components'
import './globals.css'

// UI Font (Unanimous: Inter)
const inter = Inter({
  subsets: ['latin', 'cyrillic'],
  variable: '--font-inter',
  display: 'swap',
})

// Contract Font (DeepSeek: IBM Plex Serif for best Ukrainian Cyrillic)
const ibmPlexSerif = IBM_Plex_Serif({
  weight: ['400', '500', '600'],
  subsets: ['latin', 'cyrillic'],
  variable: '--font-ibm-plex-serif',
  display: 'swap',
})

// Code Font
const jetbrainsMono = JetBrains_Mono({
  subsets: ['latin', 'cyrillic'],
  variable: '--font-jetbrains-mono',
  display: 'swap',
})

export const metadata: Metadata = {
  title: 'Legal Council - Юридичний Аналіз Контрактів',
  description: 'AI-powered аналіз юридичних договорів відповідно до законодавства України',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="uk" suppressHydrationWarning>
      <body
        className={`${inter.variable} ${ibmPlexSerif.variable} ${jetbrainsMono.variable} font-sans antialiased`}
      >
        <div className="flex min-h-screen flex-col">
          <Header />
          <main className="flex-1">{children}</main>
          <Footer />
        </div>
      </body>
    </html>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/app/page.tsx
════════════════════════════════════════════════════════════════

import Link from 'next/link'
import { Button } from '@/shared/ui'
import { RiskBadge } from '@/shared/components/RiskBadge'

/**
 * Landing Page - AGENTIS Legal AI Platform
 * 
 * Updated Feb 14, 2026:
 * - New tagline: "Жодних компромісів. Тільки найновіші моделі LLM..."
 * - Refreshed stats: 1,620 articles in law database, RAG semantic search
 * - 8 AI agents (4 review + 4 generation)
 * - 3 LLM providers (Claude, GPT, Gemini)
 * - ГКУ removed from main headline (deprecated code)
 */

export default function HomePage() {
  return (
    <div className="min-h-screen bg-gray-50">
      {/* HERO SECTION */}
      <section className="container mx-auto px-6 py-24">
        <div className="grid gap-12 lg:grid-cols-2 lg:gap-16 items-center">
          {/* LEFT: Message */}
          <div className="space-y-8">
            <div className="space-y-4">
              <div className="inline-flex items-center gap-2 rounded-full bg-navy/10 px-4 py-2 text-sm font-medium text-navy">
                <span className="relative flex h-2 w-2">
                  <span className="animate-ping absolute inline-flex h-full w-full rounded-full bg-navy opacity-75"></span>
                  <span className="relative inline-flex rounded-full h-2 w-2 bg-navy"></span>
                </span>
                AI-аналіз за 90 секунд
              </div>
              
              <h1 className="text-4xl font-bold tracking-tight sm:text-5xl lg:text-6xl">
                Юридичний AI-Аналіз
                <span className="block text-navy mt-2">
                  Контрактів та Документів
                </span>
              </h1>
              
              <p className="text-lg text-gray-500 leading-relaxed">
                Жодних компромісів. Тільки найновіші моделі LLM, навчені національному законодавству.
              </p>

              <p className="text-base text-gray-400 leading-relaxed">
                8 спеціалізованих AI-агентів перевіряють кожен пункт договору 
                на відповідність ЦКУ та КЗпП. Семантичний пошук по 1 620 статтях 
                знаходить саме ті норми, що стосуються вашого контракту.
              </p>
            </div>

            {/* CTA Buttons */}
            <div className="flex flex-col sm:flex-row gap-4">
              <Button asChild size="lg" className="text-base">
                <Link href="/review">
                  Проаналізувати Контракт →
                </Link>
              </Button>
              
              <Button asChild size="lg" variant="outline" className="text-base">
                <Link href="/generate">
                  Згенерувати Документ
                </Link>
              </Button>
            </div>

            {/* Trust indicators */}
            <div className="flex flex-wrap items-center gap-6 pt-4 text-sm text-gray-500">
              <div className="flex items-center gap-2">
                <svg className="h-5 w-5 text-navy" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.04A12.02 12.02 0 003 9c0 5.591 3.824 10.29 9 11.622 5.176-1.332 9-6.03 9-11.622 0-1.042-.133-2.052-.382-3.016z" />
                </svg>
                <span>ЦКУ + КЗпП</span>
              </div>
              <div className="flex items-center gap-2">
                <svg className="h-5 w-5 text-navy" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 15v2m-6 4h12a2 2 0 002-2v-6a2 2 0 00-2-2H6a2 2 0 00-2 2v6a2 2 0 002 2zm10-10V7a4 4 0 00-8 0v4h8z" />
                </svg>
                <span>Безпечна обробка даних</span>
              </div>
              <div className="flex items-center gap-2">
                <svg className="h-5 w-5 text-navy" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 10V3L4 14h7v7l9-11h-7z" />
                </svg>
                <span>Claude + GPT + Gemini</span>
              </div>
            </div>
          </div>

          {/* RIGHT: Visual preview */}
          <div className="relative">
            <div className="rounded-lg border bg-white p-6 shadow-lg">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="font-semibold">Результат Аналізу</h3>
                  <RiskBadge severity={4} />
                </div>
                
                <div className="space-y-3">
                  <div className="flex items-start gap-3 rounded-md border border-risk-critical/20 bg-risk-critical/5 p-3">
                    <span className="text-lg">❗</span>
                    <div className="flex-1 space-y-1">
                      <p className="text-sm font-medium">Критичний ризик знайдено</p>
                      <p className="text-xs text-gray-500">
                        Відсутність ціни суперечить ЦКУ ст. 638
                      </p>
                    </div>
                  </div>
                  
                  <div className="flex items-start gap-3 rounded-md border border-risk-medium/20 bg-risk-medium/5 p-3">
                    <span className="text-lg">⚙️</span>
                    <div className="flex-1 space-y-1">
                      <p className="text-sm font-medium">Середній ризик</p>
                      <p className="text-xs text-gray-500">
                        Нечіткі строки — ст. 530 ЦКУ
                      </p>
                    </div>
                  </div>
                  
                  <div className="flex items-start gap-3 rounded-md border border-risk-safe/20 bg-risk-safe/5 p-3">
                    <span className="text-lg">✅</span>
                    <div className="flex-1 space-y-1">
                      <p className="text-sm font-medium">12 пунктів безпечні</p>
                      <p className="text-xs text-gray-500">
                        Відповідають стандартам ДСТУ
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
            
            {/* Floating element */}
            <div className="absolute -bottom-4 -right-4 rounded-lg border bg-white p-4 shadow-md">
              <div className="flex items-center gap-3">
                <div className="flex -space-x-2">
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-navy text-xs font-semibold text-white">
                    E
                  </div>
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-destructive text-xs font-semibold text-white">
                    P
                  </div>
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-risk-safe text-xs font-semibold text-white">
                    V
                  </div>
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-accent text-xs font-semibold text-white">
                    S
                  </div>
                </div>
                <div className="text-xs">
                  <p className="font-semibold">8 AI Агентів</p>
                  <p className="text-gray-500">4 аналіз + 4 генерація</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* HOW IT WORKS — 2 modules */}
      <section className="border-t bg-white py-24">
        <div className="container mx-auto px-6">
          <div className="mb-12 text-center">
            <h2 className="text-3xl font-bold">Як Це Працює</h2>
            <p className="mt-4 text-lg text-gray-500">
              Два модулі — аналіз і генерація — працюють на базі мульти-агентної архітектури
            </p>
          </div>

          {/* Module 1: Contract Review */}
          <div className="mb-16">
            <h3 className="text-xl font-semibold text-navy mb-6 text-center">Аналіз Контрактів</h3>
            <div className="grid gap-8 md:grid-cols-2 lg:grid-cols-4">
              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-navy/10 text-2xl">
                  🔍
                </div>
                <h3 className="mb-2 text-lg font-semibold">Експерт</h3>
                <p className="text-sm text-gray-500">
                  Перевіряє відповідність ЦКУ та КЗпП. RAG-пошук по 1 620 статтях знаходить релевантні норми.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-destructive/10 text-2xl">
                  ⚔️
                </div>
                <h3 className="mb-2 text-lg font-semibold">Провокатор</h3>
                <p className="text-sm text-gray-500">
                  Діє як опонент. Шукає слабкі місця, приховані ризики та можливі зловживання.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-risk-safe/10 text-2xl">
                  ✓
                </div>
                <h3 className="mb-2 text-lg font-semibold">Валідатор</h3>
                <p className="text-sm text-gray-500">
                  Перевіряє висновки обох агентів. Усуває суперечності та виявляє прогалини.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-accent/10 text-2xl">
                  📊
                </div>
                <h3 className="mb-2 text-lg font-semibold">Синтезатор</h3>
                <p className="text-sm text-gray-500">
                  Формує фінальний звіт з рекомендаціями, оцінкою ризику та посиланнями на статті.
                </p>
              </div>
            </div>
          </div>

          {/* Module 2: Document Generation */}
          <div>
            <h3 className="text-xl font-semibold text-navy mb-6 text-center">Генерація Документів</h3>
            <div className="grid gap-8 md:grid-cols-2 lg:grid-cols-4">
              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-navy/10 text-2xl">
                  📋
                </div>
                <h3 className="mb-2 text-lg font-semibold">Аналізатор</h3>
                <p className="text-sm text-gray-500">
                  Аналізує вимоги та визначає тип документа, сторони, ключові умови.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-navy/10 text-2xl">
                  ✍️
                </div>
                <h3 className="mb-2 text-lg font-semibold">Драфтер</h3>
                <p className="text-sm text-gray-500">
                  Створює проект документа з урахуванням ДСТУ 4163-2020 та вимог законодавства.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-risk-safe/10 text-2xl">
                  ⚖️
                </div>
                <h3 className="mb-2 text-lg font-semibold">Валідатор</h3>
                <p className="text-sm text-gray-500">
                  Перевіряє юридичну коректність, відповідність ЦКУ та повноту документа.
                </p>
              </div>

              <div className="group hover-lift rounded-lg border bg-white p-6">
                <div className="mb-4 flex h-12 w-12 items-center justify-center rounded-lg bg-accent/10 text-2xl">
                  💎
                </div>
                <h3 className="mb-2 text-lg font-semibold">Полішер</h3>
                <p className="text-sm text-gray-500">
                  Фінальне редагування: стилістика, термінологія, форматування за ДСТУ.
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* TRUST SECTION — stats */}
      <section className="border-t py-16">
        <div className="container mx-auto px-6">
          <div className="rounded-lg border bg-white p-8 md:p-12">
            <div className="grid gap-8 md:grid-cols-4">
              <div className="text-center">
                <div className="mb-4 text-4xl font-bold text-navy">1 620</div>
                <p className="text-sm text-gray-500">
                  Статей ЦКУ та КЗпП у базі з семантичним пошуком
                </p>
              </div>
              
              <div className="text-center">
                <div className="mb-4 text-4xl font-bold text-navy">8</div>
                <p className="text-sm text-gray-500">
                  AI-агентів для аналізу та генерації документів
                </p>
              </div>

              <div className="text-center">
                <div className="mb-4 text-4xl font-bold text-navy">&lt;90s</div>
                <p className="text-sm text-gray-500">
                  Повний аналіз договору будь-якої складності
                </p>
              </div>
              
              <div className="text-center">
                <div className="mb-4 text-4xl font-bold text-navy">3 LLM</div>
                <p className="text-sm text-gray-500">
                  Claude, GPT та Gemini для максимальної точності
                </p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* TECHNOLOGY SECTION */}
      <section className="border-t bg-white py-16">
        <div className="container mx-auto px-6">
          <div className="max-w-3xl mx-auto text-center">
            <h2 className="text-2xl font-bold mb-4">Технології</h2>
            <p className="text-gray-500 mb-8">
              Мульти-агентна архітектура з RAG-інтеграцією забезпечує точність та актуальність аналізу
            </p>
            <div className="flex flex-wrap justify-center gap-3">
              {[
                'Anthropic Claude',
                'OpenAI GPT',
                'Google Gemini',
                'Pinecone Vector DB',
                'RAG Search',
                'Next.js',
                'TypeScript',
                'ДСТУ 4163-2020',
              ].map((tech) => (
                <span
                  key={tech}
                  className="rounded-full border bg-gray-50 px-4 py-2 text-sm text-gray-600"
                >
                  {tech}
                </span>
              ))}
            </div>
          </div>
        </div>
      </section>
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/AgentProgress.tsx
════════════════════════════════════════════════════════════════

import { cn } from '@/shared/lib'
import type { AgentName, AgentStatus } from '@/shared/types'

interface AgentProgressProps {
  agents: {
    name: AgentName
    status: AgentStatus
    message?: string
  }[]
  className?: string
}

const AGENT_CONFIG = {
  expert: {
    label: 'Експерт',
    description: 'Аналізує відповідність ЦКУ, ГКУ, КЗпП',
    icon: '🔍',
  },
  provocateur: {
    label: 'Провокатор',
    description: 'Шукає слабкі місця та контраргументи',
    icon: '⚔️',
  },
  validator: {
    label: 'Валідатор',
    description: 'Перевіряє висновки та усуває суперечності',
    icon: '✓',
  },
  synthesizer: {
    label: 'Синтезатор',
    description: 'Формує фінальний звіт',
    icon: '📊',
  },
} as const

function getStatusColor(status: AgentStatus): string {
  switch (status) {
    case 'completed':
      return 'bg-risk-safe border-risk-safe'
    case 'running':
      return 'bg-brand-primary border-brand-primary animate-pulse'
    case 'error':
      return 'bg-risk-critical border-risk-critical'
    default:
      return 'bg-muted border-gray-200'
  }
}

function getStatusIcon(status: AgentStatus): string {
  switch (status) {
    case 'completed':
      return '✓'
    case 'running':
      return '⏳'
    case 'error':
      return '✗'
    default:
      return '⏸'
  }
}

export function AgentProgress({ agents, className }: AgentProgressProps) {
  return (
    <div className={cn('space-y-3', className)}>
      {agents.map((agent) => {
        const config = AGENT_CONFIG[agent.name]
        const statusColor = getStatusColor(agent.status)
        const statusIcon = getStatusIcon(agent.status)

        return (
          <div
            key={agent.name}
            className={cn(
              'flex items-start gap-3 rounded-lg border p-3 transition-all',
              agent.status === 'running' && 'ring-2 ring-brand-primary/20',
              agent.status === 'completed' && 'bg-risk-safe/5'
            )}
          >
            {/* Icon */}
            <div
              className={cn(
                'flex h-10 w-10 items-center justify-center rounded-full border-2 text-lg',
                statusColor
              )}
            >
              {agent.status === 'running' ? statusIcon : config.icon}
            </div>

            {/* Content */}
            <div className="flex-1 space-y-1">
              <div className="flex items-center justify-between">
                <h4 className="text-sm font-semibold">
                  {config.label}
                </h4>
                <span className="text-xs text-gray-500">
                  {agent.status === 'completed' && '✓ Завершено'}
                  {agent.status === 'running' && 'Аналізую...'}
                  {agent.status === 'pending' && 'Очікує'}
                  {agent.status === 'error' && 'Помилка'}
                </span>
              </div>

              <p className="text-xs text-gray-500">
                {agent.message || config.description}
              </p>

              {/* Progress bar for running agent */}
              {agent.status === 'running' && (
                <div className="h-1 overflow-hidden rounded-full bg-muted">
                  <div className="h-full w-full animate-[shimmer_1s_ease-in-out_infinite] bg-gradient-to-r from-transparent via-brand-primary to-transparent" />
                </div>
              )}
            </div>
          </div>
        )
      })}
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/Footer.tsx
════════════════════════════════════════════════════════════════

import Link from 'next/link'

export function Footer() {
  const currentYear = new Date().getFullYear()
  
  return (
    <footer className="border-t bg-gray-50">
      <div className="container mx-auto px-6 py-8">
        {/* Top section */}
        <div className="grid gap-8 md:grid-cols-3">
          {/* About */}
          <div>
            <h3 className="mb-3 text-sm font-semibold text-gray-900">AGENTIS</h3>
            <p className="text-sm text-gray-600 leading-relaxed">
              AI-платформа для аналізу юридичних договорів відповідно до законодавства України
            </p>
          </div>
          
          {/* Quick Links */}
          <div>
            <h3 className="mb-3 text-sm font-semibold text-gray-900">Посилання</h3>
            <ul className="space-y-2 text-sm">
              <li>
                <Link href="/review" className="text-gray-600 hover:text-navy transition-colors">
                  Аналіз контракту
                </Link>
              </li>
              <li>
                <Link href="/history" className="text-gray-600 hover:text-navy transition-colors">
                  Історія аналізів
                </Link>
              </li>
            </ul>
          </div>
          
          {/* Legal */}
          <div>
            <h3 className="mb-3 text-sm font-semibold text-gray-900">Юридична інформація</h3>
            <ul className="space-y-2 text-sm">
              <li className="text-gray-600">
                Конфіденційність даних
              </li>
              <li className="text-gray-600">
                Умови використання
              </li>
            </ul>
          </div>
        </div>
        
        {/* Bottom section */}
        <div className="mt-8 border-t pt-6 flex flex-col md:flex-row items-center justify-between gap-4">
          <p className="text-xs text-gray-500">
            © {currentYear} AGENTIS. AI-асистент, не юридична консультація.
          </p>
          
          <div className="flex items-center gap-4 text-xs text-gray-500">
            <span>Powered by Claude Opus 4.5, GPT-4o, Gemini 2.5</span>
          </div>
        </div>
      </div>
    </footer>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/Header.tsx
════════════════════════════════════════════════════════════════

'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { Logo } from './Logo'
import { cn } from '@/shared/lib'

const NAV_LINKS = [
  { href: '/', label: 'Головна', icon: '🏠' },
  { href: '/review', label: 'Аналіз', icon: '🔍' },
  { href: '/history', label: 'Історія', icon: '📊' },
]

export function Header() {
  const pathname = usePathname()
  
  return (
    <header className="sticky top-0 z-50 border-b bg-white shadow-sm">
      <div className="container mx-auto flex h-16 items-center justify-between px-6">
        {/* Logo */}
        <Link href="/" className="hover:opacity-80 transition-opacity">
          <Logo size="md" />
        </Link>
        
        {/* Navigation */}
        <nav className="flex items-center gap-1">
          {NAV_LINKS.map((link) => {
            const isActive = pathname === link.href || 
                            (link.href !== '/' && pathname.startsWith(link.href))
            
            return (
              <Link
                key={link.href}
                href={link.href}
                className={cn(
                  'flex items-center gap-2 rounded-md px-4 py-2 text-sm font-medium transition-colors',
                  isActive 
                    ? 'bg-navy text-white' 
                    : 'text-gray-700 hover:bg-gray-100'
                )}
              >
                <span className="text-base">{link.icon}</span>
                <span>{link.label}</span>
              </Link>
            )
          })}
        </nav>
        
        {/* Right section - можна додати user menu пізніше */}
        <div className="flex items-center gap-3">
          <div className="text-xs text-gray-500">
            v1.0 Beta
          </div>
        </div>
      </div>
    </header>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/index.ts
════════════════════════════════════════════════════════════════

export * from './Sidebar'
export * from './RiskBadge'
export * from './AgentProgress'
export * from './SplitView'
export * from './RiskDashboard'
export * from './Logo'
export * from './Header'
export * from './Footer'


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/Logo.tsx
════════════════════════════════════════════════════════════════

/**
 * AGENTIS Logo Component
 * Design: Shield + Balance (scales of justice)
 * Represents legal protection and fair analysis
 */

interface LogoProps {
  size?: 'sm' | 'md' | 'lg'
  showText?: boolean
  className?: string
}

const SIZES = {
  sm: { width: 165, height: 33, iconScale: 0.75, fontSize: 16.5 },
  md: { width: 220, height: 44, iconScale: 1, fontSize: 22 },
  lg: { width: 275, height: 55, iconScale: 1.25, fontSize: 27.5 },
}

export function Logo({ size = 'md', showText = true, className = '' }: LogoProps) {
  const { width, height, iconScale, fontSize } = SIZES[size]
  
  if (!showText) {
    // Icon only version
    return (
      <svg
        width={36 * iconScale}
        height={36 * iconScale}
        viewBox="0 0 32 36"
        xmlns="http://www.w3.org/2000/svg"
        className={className}
        role="img"
        aria-label="AGENTIS"
      >
        {/* Shield */}
        <path d="M16 0 L32 6 V20 C32 28 16 36 16 36 C16 36 0 28 0 20 V6 Z" fill="#1E3A8A"/>
        
        {/* Balance scales - white for visibility */}
        <g fill="white">
          <rect x="15" y="8" width="2" height="16"/>
          <rect x="8" y="12" width="16" height="2"/>
          <rect x="6" y="14" width="4" height="2"/>
          <rect x="22" y="14" width="4" height="2"/>
        </g>
      </svg>
    )
  }
  
  return (
    <svg
      width={width}
      height={height}
      viewBox="0 0 220 44"
      xmlns="http://www.w3.org/2000/svg"
      className={className}
      role="img"
      aria-label="AGENTIS logo"
    >
      {/* Icon */}
      <g transform="translate(4,4)">
        {/* Shield */}
        <path d="M16 0 L32 6 V20 C32 28 16 36 16 36 C16 36 0 28 0 20 V6 Z" fill="#1E3A8A"/>
        
        {/* Balance scales - white for visibility on navy background */}
        <g fill="white">
          <rect x="15" y="8" width="2" height="16"/>
          <rect x="8" y="12" width="16" height="2"/>
          <rect x="6" y="14" width="4" height="2"/>
          <rect x="22" y="14" width="4" height="2"/>
        </g>
      </g>
      
      {/* Wordmark */}
      <text
        x="56"
        y="30"
        fontFamily="Inter, Montserrat, system-ui, sans-serif"
        fontSize={fontSize}
        fontWeight="600"
        letterSpacing="1.4"
        fill="#1E3A8A"
      >
        AGENTIS
      </text>
    </svg>
  )
}

/**
 * Favicon version - 32x32 icon only
 */
export function LogoIcon({ size = 32 }: { size?: number }) {
  return (
    <svg
      width={size}
      height={size}
      viewBox="0 0 32 36"
      xmlns="http://www.w3.org/2000/svg"
      role="img"
      aria-label="AGENTIS"
    >
      {/* Shield */}
      <path d="M16 0 L32 6 V20 C32 28 16 36 16 36 C16 36 0 28 0 20 V6 Z" fill="#1E3A8A"/>
      
      {/* Balance scales - white for visibility */}
      <g fill="white">
        <rect x="15" y="8" width="2" height="16"/>
        <rect x="8" y="12" width="16" height="2"/>
        <rect x="6" y="14" width="4" height="2"/>
        <rect x="22" y="14" width="4" height="2"/>
      </g>
    </svg>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/RiskBadge.tsx
════════════════════════════════════════════════════════════════

import { cn } from '@/shared/lib'
import type { RiskSeverity } from '@/shared/types'

interface RiskBadgeProps {
  severity: RiskSeverity
  className?: string
  showLabel?: boolean
  showIcon?: boolean
}

/**
 * Risk Severity Configuration
 * Based on AI consensus:
 * - ALL 3 AI said: Add icons (not just color!)
 * - DeepSeek: "Не тільки колір, а іконки"
 * - ChatGPT: "Use distinct icons (❗ ⚠️ ✓)"
 * - Grok: "Add patterns + text labels"
 */
const SEVERITY_CONFIG = {
  5: {
    label: 'Критичний',
    labelShort: 'Critical',
    color: 'bg-risk-critical text-white border-risk-critical',
    icon: '❗',
    description: 'Requires immediate attention',
  },
  4: {
    label: 'Високий',
    labelShort: 'High',
    color: 'bg-risk-high text-white border-risk-high',
    icon: '⚠️',
    description: 'Significant risk identified',
  },
  3: {
    label: 'Середній',
    labelShort: 'Medium',
    color: 'bg-risk-medium text-gray-900 border-risk-medium',
    icon: '⚙️',
    description: 'Moderate concern',
  },
  2: {
    label: 'Низький',
    labelShort: 'Low',
    color: 'bg-risk-low text-white border-risk-low',
    icon: '✓',
    description: 'Minor issue',
  },
  1: {
    label: 'Безпечно',
    labelShort: 'Safe',
    color: 'bg-risk-safe text-white border-risk-safe',
    icon: '✅',
    description: 'No issues found',
  },
} as const

export function RiskBadge({ 
  severity, 
  className,
  showLabel = true,
  showIcon = true, // AI consensus: ALWAYS show icon
}: RiskBadgeProps) {
  const config = SEVERITY_CONFIG[severity]

  return (
    <div
      className={cn(
        // Base styles (ChatGPT: border-radius 4-6px max)
        'risk-badge inline-flex items-center gap-1.5 rounded-sm px-2.5 py-0.5 text-xs font-semibold border transition-all duration-150',
        config.color,
        className
      )}
      title={config.description}
      role="status"
      aria-label={`Risk level: ${config.label}`}
    >
      {showIcon && <span className="text-sm" aria-hidden="true">{config.icon}</span>}
      {showLabel && <span>{config.label}</span>}
    </div>
  )
}

/**
 * Utility to get severity number from 0-10 risk score
 * (Unchanged from original)
 */
export function riskScoreToSeverity(score: number): RiskSeverity {
  if (score <= 2) return 1 // Safe
  if (score <= 4) return 2 // Low
  if (score <= 6) return 3 // Medium
  if (score <= 8) return 4 // High
  return 5 // Critical
}

/**
 * Get risk color for charts/visualizations
 */
export function getRiskColor(severity: RiskSeverity): string {
  const colors = {
    5: '#BE123C', // Critical (Deep Crimson - ChatGPT)
    4: '#D97706', // High (Reduced saturation)
    3: '#B8860B', // Medium (Darker yellow)
    2: '#15803D', // Low
    1: '#15803D', // Safe
  }
  return colors[severity]
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/RiskDashboard.tsx
════════════════════════════════════════════════════════════════

'use client'

import { useState } from 'react'
import { cn } from '@/shared/lib'
import { RiskBadge } from './RiskBadge'
import type { RiskSeverity } from '@/shared/types'

interface RiskItem {
  id: string
  severity: RiskSeverity
  title: string
  description: string
  contractExcerpt?: string
  legalCitation?: string // e.g., "ЦКУ ст. 638"
  recommendation?: string
  confidence?: number // 0-100
  agentName?: string // Which agent found it
  lineNumber?: number // For "tether" animation
}

interface RiskDashboardProps {
  risks: RiskItem[]
  onRiskClick?: (risk: RiskItem) => void
  className?: string
}

/**
 * Hybrid Risk Dashboard
 * Based on ALL 3 AI consensus:
 * - DeepSeek: "Summary + detailed list"
 * - ChatGPT: "Risk Weather Map + Executive Summary"
 * - Grok: "Pie chart + accordion cards"
 * 
 * Structure:
 * 1. Top: Executive Summary (total risks, confidence, chart)
 * 2. Below: Accordion list sorted by severity
 * 3. Each card shows: icon, title, description, citation, confidence
 */
export function RiskDashboard({
  risks = [],
  onRiskClick,
  className,
}: RiskDashboardProps) {
  const [expandedRiskId, setExpandedRiskId] = useState<string | null>(null)

  // Calculate stats
  const risksBySeverity = {
    5: risks.filter((r) => r.severity === 5).length,
    4: risks.filter((r) => r.severity === 4).length,
    3: risks.filter((r) => r.severity === 3).length,
    2: risks.filter((r) => r.severity === 2).length,
    1: risks.filter((r) => r.severity === 1).length,
  }

  const avgConfidence = risks.length
    ? Math.round(
        risks.reduce((sum, r) => sum + (r.confidence || 0), 0) / risks.length
      )
    : 0

  const handleRiskClick = (risk: RiskItem) => {
    setExpandedRiskId(expandedRiskId === risk.id ? null : risk.id)
    onRiskClick?.(risk)
  }

  // Sort risks by severity (critical first)
  const sortedRisks = [...risks].sort((a, b) => b.severity - a.severity)

  return (
    <div className={cn('space-y-md', className)}>
      {/* EXECUTIVE SUMMARY (ChatGPT: "Risk Weather Map") */}
      <div className="rounded-md border bg-white p-lg shadow-card">
        <h3 className="mb-md text-lg font-semibold">Огляд Ризиків</h3>

        <div className="grid gap-md md:grid-cols-3">
          {/* Total Risks */}
          <div className="text-center">
            <div className="mb-1 text-3xl font-bold text-navy">
              {risks.length}
            </div>
            <p className="text-sm text-gray-500">
              Всього знайдено проблем
            </p>
          </div>

          {/* Confidence Score */}
          <div className="text-center">
            <div className="mb-1 text-3xl font-bold text-navy">
              {avgConfidence}%
            </div>
            <p className="text-sm text-gray-500">
              Середня впевненість
            </p>
          </div>

          {/* Critical Count */}
          <div className="text-center">
            <div className="mb-1 text-3xl font-bold text-risk-critical">
              {risksBySeverity[5]}
            </div>
            <p className="text-sm text-gray-500">
              Критичних ризиків
            </p>
          </div>
        </div>

        {/* Horizontal bar chart (Grok recommendation) */}
        <div className="mt-md space-y-2">
          <p className="text-xs font-medium text-gray-500">
            Розподіл за рівнем:
          </p>
          <div className="space-y-1.5">
            {/* Critical */}
            {risksBySeverity[5] > 0 && (
              <div className="flex items-center gap-2">
                <span className="text-xs w-20">Критичний</span>
                <div className="h-2 flex-1 rounded-sm bg-risk-critical/20">
                  <div
                    className="h-full rounded-sm bg-risk-critical transition-all"
                    style={{
                      width: `${(risksBySeverity[5] / risks.length) * 100}%`,
                    }}
                  />
                </div>
                <span className="text-xs w-8 text-right text-gray-500">
                  {risksBySeverity[5]}
                </span>
              </div>
            )}

            {/* High */}
            {risksBySeverity[4] > 0 && (
              <div className="flex items-center gap-2">
                <span className="text-xs w-20">Високий</span>
                <div className="h-2 flex-1 rounded-sm bg-risk-high/20">
                  <div
                    className="h-full rounded-sm bg-risk-high transition-all"
                    style={{
                      width: `${(risksBySeverity[4] / risks.length) * 100}%`,
                    }}
                  />
                </div>
                <span className="text-xs w-8 text-right text-gray-500">
                  {risksBySeverity[4]}
                </span>
              </div>
            )}

            {/* Medium */}
            {risksBySeverity[3] > 0 && (
              <div className="flex items-center gap-2">
                <span className="text-xs w-20">Середній</span>
                <div className="h-2 flex-1 rounded-sm bg-risk-medium/20">
                  <div
                    className="h-full rounded-sm bg-risk-medium transition-all"
                    style={{
                      width: `${(risksBySeverity[3] / risks.length) * 100}%`,
                    }}
                  />
                </div>
                <span className="text-xs w-8 text-right text-gray-500">
                  {risksBySeverity[3]}
                </span>
              </div>
            )}
          </div>
        </div>
      </div>

      {/* DETAILED ACCORDION LIST (All 3 AI: sorted by severity) */}
      <div className="space-y-sm">
        <h3 className="text-lg font-semibold">Детальний Аналіз</h3>

        {sortedRisks.length === 0 ? (
          <div className="rounded-md border border-dashed bg-white p-lg text-center text-sm text-gray-500">
            Аналіз не завершений або ризики не знайдені
          </div>
        ) : (
          sortedRisks.map((risk) => {
            const isExpanded = expandedRiskId === risk.id

            return (
              <div
                key={risk.id}
                className={cn(
                  'group cursor-pointer rounded-md border bg-white transition-all duration-150',
                  'hover:shadow-md hover:border-brand-primary/30',
                  isExpanded && 'ring-2 ring-brand-primary/20 shadow-md'
                )}
                onClick={() => handleRiskClick(risk)}
                role="button"
                tabIndex={0}
                onKeyDown={(e) => {
                  if (e.key === 'Enter' || e.key === ' ') {
                    handleRiskClick(risk)
                  }
                }}
              >
                {/* CARD HEADER (always visible) */}
                <div className="flex items-start gap-3 p-md">
                  {/* Risk Badge with icon (All 3 AI: MUST have icons!) */}
                  <div className="pt-0.5">
                    <RiskBadge severity={risk.severity} showLabel={false} />
                  </div>

                  {/* Content */}
                  <div className="flex-1 space-y-1">
                    <div className="flex items-start justify-between gap-2">
                      <h4 className="text-sm font-semibold leading-tight">
                        {risk.title}
                      </h4>
                      {risk.confidence && (
                        <span className="text-xs text-gray-500 whitespace-nowrap">
                          {risk.confidence}% впевненість
                        </span>
                      )}
                    </div>

                    <p className="text-sm text-gray-500">
                      {risk.description}
                    </p>

                    {/* Legal Citation (DeepSeek: "Inline legal reasoning") */}
                    {risk.legalCitation && (
                      <p className="text-xs font-medium text-navy">
                        📚 {risk.legalCitation}
                      </p>
                    )}
                  </div>

                  {/* Expand indicator */}
                  <div
                    className={cn(
                      'text-gray-500 transition-transform duration-150',
                      isExpanded && 'rotate-180'
                    )}
                  >
                    <svg
                      className="h-4 w-4"
                      fill="none"
                      stroke="currentColor"
                      viewBox="0 0 24 24"
                    >
                      <path
                        strokeLinecap="round"
                        strokeLinejoin="round"
                        strokeWidth={2}
                        d="M19 9l-7 7-7-7"
                      />
                    </svg>
                  </div>
                </div>

                {/* EXPANDED CONTENT (DeepSeek: "Lawyers want explanations") */}
                {isExpanded && (
                  <div className="animate-slide-up space-y-sm border-t bg-gray-50 p-md">
                    {/* Contract Excerpt */}
                    {risk.contractExcerpt && (
                      <div>
                        <p className="mb-1 text-xs font-semibold text-gray-500">
                          Фрагмент договору:
                        </p>
                        <div className="rounded-sm border bg-white p-sm font-serif text-sm">
                          {risk.contractExcerpt}
                        </div>
                      </div>
                    )}

                    {/* Recommendation */}
                    {risk.recommendation && (
                      <div>
                        <p className="mb-1 text-xs font-semibold text-gray-500">
                          Рекомендація:
                        </p>
                        <p className="text-sm">{risk.recommendation}</p>
                      </div>
                    )}

                    {/* Which agent found it */}
                    {risk.agentName && (
                      <div className="flex items-center gap-2 text-xs text-gray-500">
                        <span>Знайдено агентом:</span>
                        <span className="font-semibold">{risk.agentName}</span>
                      </div>
                    )}
                  </div>
                )}
              </div>
            )
          })
        )}
      </div>
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/Sidebar.tsx
════════════════════════════════════════════════════════════════

'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { cn } from '@/shared/lib'
import { useUIStore } from '@/stores/ui'
import { Button } from '@/shared/ui'

const navigation = [
  {
    name: 'Огляд Контрактів',
    href: '/review',
    icon: '📋',
    module: 'review' as const,
  },
  {
    name: 'Історія',
    href: '/history',
    icon: '📂',
    module: 'history' as const,
  },
  {
    name: 'Генерація',
    href: '/generate',
    icon: '✨',
    module: 'generation' as const,
    disabled: true, // Coming soon
  },
  {
    name: 'Аналітика',
    href: '/analytics',
    icon: '📊',
    module: 'analytics' as const,
    disabled: true, // Coming soon
  },
]

export function Sidebar() {
  const pathname = usePathname()
  const { sidebarCollapsed, toggleSidebar } = useUIStore()

  return (
    <aside
      className={cn(
        'fixed left-0 top-0 z-40 h-screen border-r bg-white transition-all duration-300',
        sidebarCollapsed ? 'w-16' : 'w-64'
      )}
    >
      <div className="flex h-full flex-col">
        {/* Header */}
        <div className="flex h-16 items-center justify-between border-b px-4">
          {!sidebarCollapsed && (
            <Link href="/" className="flex items-center gap-2">
              <span className="text-2xl">⚖️</span>
              <span className="font-bold">Legal Council</span>
            </Link>
          )}

          <Button
            variant="ghost"
            size="icon"
            onClick={toggleSidebar}
            className={cn(sidebarCollapsed && 'mx-auto')}
          >
            {sidebarCollapsed ? '→' : '←'}
          </Button>
        </div>

        {/* Navigation */}
        <nav className="flex-1 space-y-1 p-2">
          {navigation.map((item) => {
            const isActive = pathname.startsWith(item.href)

            return (
              <Link
                key={item.href}
                href={item.disabled ? '#' : item.href}
                className={cn(
                  'flex items-center gap-3 rounded-md px-3 py-2 text-sm font-medium transition-colors',
                  isActive
                    ? 'bg-navy text-navy-foreground'
                    : 'hover:bg-accent hover:text-accent-foreground',
                  item.disabled && 'cursor-not-allowed opacity-50',
                  sidebarCollapsed && 'justify-center'
                )}
                onClick={(e) => item.disabled && e.preventDefault()}
              >
                <span className="text-xl">{item.icon}</span>
                {!sidebarCollapsed && (
                  <span className="flex-1">{item.name}</span>
                )}
                {!sidebarCollapsed && item.disabled && (
                  <span className="text-xs opacity-70">Скоро</span>
                )}
              </Link>
            )
          })}
        </nav>

        {/* Footer */}
        <div className="border-t p-4">
          {!sidebarCollapsed ? (
            <div className="space-y-1 text-xs text-gray-500">
              <p>v1.0.0</p>
              <p>© 2026 Legal Council</p>
            </div>
          ) : (
            <div className="text-center text-xs text-gray-500">
              v1.0
            </div>
          )}
        </div>
      </div>
    </aside>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/components/SplitView.tsx
════════════════════════════════════════════════════════════════

'use client'

import { useState } from 'react'
import { cn } from '@/shared/lib'

interface SplitViewProps {
  leftContent: React.ReactNode
  rightContent: React.ReactNode
  defaultSplit?: number // 0-100, default 50
  className?: string
}

/**
 * Split View Component
 * Based on UNANIMOUS consensus from all 3 AI experts:
 * - DeepSeek: "Юрист мислить порівнянням - text + analysis side by side"
 * - ChatGPT: "The Holy Grail of legal tech UI"
 * - Grok: "Left-right more efficient than up-down"
 * 
 * Specifications (from ChatGPT):
 * - 50/50 split adjustable via drag
 * - 24px padding around
 * - 16px gap between elements
 * - 1px solid slate-200 borders
 * - Sharp corners (not rounded bubbles!)
 */
export function SplitView({
  leftContent,
  rightContent,
  defaultSplit = 50,
  className,
}: SplitViewProps) {
  const [splitPosition, setSplitPosition] = useState(defaultSplit)
  const [isDragging, setIsDragging] = useState(false)

  const handleMouseDown = () => {
    setIsDragging(true)
  }

  const handleMouseUp = () => {
    setIsDragging(false)
  }

  const handleMouseMove = (e: React.MouseEvent<HTMLDivElement>) => {
    if (!isDragging) return

    const container = e.currentTarget.getBoundingClientRect()
    const position = ((e.clientX - container.left) / container.width) * 100
    
    // Constrain between 30% and 70% (don't let either side get too small)
    const constrainedPosition = Math.min(Math.max(position, 30), 70)
    setSplitPosition(constrainedPosition)
  }

  return (
    <div
      className={cn(
        'relative flex w-full select-none',
        'min-h-[600px] h-[calc(100vh-12rem)]',
        isDragging && 'cursor-col-resize',
        className
      )}
      onMouseMove={handleMouseMove}
      onMouseUp={handleMouseUp}
      onMouseLeave={handleMouseUp}
    >
      {/* LEFT PANE - Contract Text */}
      <div
        className="relative overflow-y-auto border-r border-gray-200 bg-white"
        style={{ width: `${splitPosition}%` }}
      >
        <div className="p-lg">{leftContent}</div>
      </div>

      {/* DRAGGABLE DIVIDER (ChatGPT: "The Tether" concept) */}
      <div
        className={cn(
          'group relative z-10 w-1 cursor-col-resize bg-border transition-all duration-150 hover:w-1.5 hover:bg-brand-primary',
          isDragging && 'w-1.5 bg-brand-primary'
        )}
        onMouseDown={handleMouseDown}
        role="separator"
        aria-label="Resize panels"
        aria-valuenow={splitPosition}
        tabIndex={0}
        onKeyDown={(e) => {
          if (e.key === 'ArrowLeft') {
            setSplitPosition(Math.max(30, splitPosition - 5))
          } else if (e.key === 'ArrowRight') {
            setSplitPosition(Math.min(70, splitPosition + 5))
          }
        }}
      >
        {/* Visual indicator (shows on hover) */}
        <div className="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 opacity-0 transition-opacity group-hover:opacity-100">
          <div className="flex h-16 w-6 items-center justify-center rounded-sm bg-brand-primary text-white shadow-md">
            <svg
              className="h-4 w-4"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M8 9l4-4 4 4m0 6l-4 4-4-4"
              />
            </svg>
          </div>
        </div>
      </div>

      {/* RIGHT PANE - AI Insights */}
      <div
        className="relative overflow-y-auto bg-gray-50"
        style={{ width: `${100 - splitPosition}%` }}
      >
        <div className="p-lg">{rightContent}</div>
      </div>
    </div>
  )
}

/**
 * Quick Keyboard Shortcuts Info
 * (Grok: "j/k navigation, / for search")
 */
export function SplitViewKeyboardHelp() {
  return (
    <div className="rounded-sm border bg-white p-3 text-xs text-gray-500">
      <p className="mb-1 font-semibold">Клавіатурні команди:</p>
      <div className="grid grid-cols-2 gap-2">
        <div>← → Змінити розмір панелей</div>
        <div>j/k Наступний/попередній ризик</div>
        <div>/ Пошук</div>
        <div>Enter Розгорнути картку</div>
      </div>
    </div>
  )
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/lib/index.ts
════════════════════════════════════════════════════════════════

export * from './utils'


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/lib/utils.ts
════════════════════════════════════════════════════════════════

import { type ClassValue, clsx } from 'clsx'
import { twMerge } from 'tailwind-merge'

/**
 * Merge Tailwind CSS classes
 * Combines clsx for conditional classes and tailwind-merge for deduplication
 */
export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/types/index.ts
════════════════════════════════════════════════════════════════

// ============================================
// Risk Analysis Types
// ============================================

export type RiskSeverity = 1 | 2 | 3 | 4 | 5

export interface Risk {
  id: string
  title: string
  description: string
  severity: RiskSeverity
  confidence: number // 0-1
  legalBasis: string // "ЦКУ ст. 638"
  clauseReference: string // "Розділ 2, п. 2.1"
  excerpt: string // Quoted text from contract
  recommendation: string
}

export interface AnalysisResult {
  id: string
  contractId: string
  contractTitle: string
  overallRiskScore: number // 0-10
  confidence: number // 0-1
  risks: Risk[]
  recommendations: string[]
  agentOutputs: {
    expert: string
    provocateur: string
    validator: string
    synthesizer: string
  }
  createdAt: string
  updatedAt: string
}

// ============================================
// Agent Status Types
// ============================================

export type AgentName = 'expert' | 'provocateur' | 'validator' | 'synthesizer'

export type AgentStatus = 'pending' | 'running' | 'completed' | 'error'

export interface AgentProgress {
  name: AgentName
  status: AgentStatus
  progress: number // 0-100
  message?: string
  completedAt?: string
}

// ============================================
// Contract Types
// ============================================

export type ContractType = 
  | 'оренда'        // Lease
  | 'поставка'      // Supply
  | 'послуги'       // Services
  | 'трудовий'      // Employment
  | 'підряд'        // Contract work
  | 'купівля-продаж' // Purchase-sale
  | 'інше'          // Other

export interface Contract {
  id: string
  title: string
  type: ContractType
  content: string
  fileUrl?: string
  uploadedAt: string
  analyzedAt?: string
  status: 'uploaded' | 'analyzing' | 'analyzed' | 'error'
}

// ============================================
// User Types
// ============================================

export interface User {
  id: string
  email: string
  name: string
  role: 'user' | 'admin'
  createdAt: string
}

// ============================================
// UI State Types
// ============================================

export interface UIState {
  sidebarCollapsed: boolean
  theme: 'light' | 'dark'
  activeModule: 'review' | 'generation' | 'analytics' | 'history'
}

// ============================================
// API Response Types
// ============================================

export interface ApiResponse<T> {
  success: boolean
  data?: T
  error?: {
    code: string
    message: string
  }
}

export interface PaginatedResponse<T> {
  items: T[]
  total: number
  page: number
  pageSize: number
  hasMore: boolean
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/ui/button.tsx
════════════════════════════════════════════════════════════════

import * as React from 'react'
import { Slot } from '@radix-ui/react-slot'
import { cva, type VariantProps } from 'class-variance-authority'

import { cn } from '@/shared/lib'

const buttonVariants = cva(
  'inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50',
  {
    variants: {
      variant: {
        default: 'bg-navy text-navy-foreground hover:bg-navy/90',
        destructive: 'bg-destructive text-destructive-foreground hover:bg-destructive/90',
        outline: 'border border-input bg-white hover:bg-accent hover:text-accent-foreground',
        secondary: 'bg-secondary text-secondary-foreground hover:bg-secondary/80',
        ghost: 'hover:bg-accent hover:text-accent-foreground',
        link: 'text-navy underline-offset-4 hover:underline',
      },
      size: {
        default: 'h-10 px-4 py-2',
        sm: 'h-9 rounded-md px-3',
        lg: 'h-11 rounded-md px-8',
        icon: 'h-10 w-10',
      },
    },
    defaultVariants: {
      variant: 'default',
      size: 'default',
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : 'button'
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = 'Button'

export { Button, buttonVariants }


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/ui/card.tsx
════════════════════════════════════════════════════════════════

import * as React from 'react'

import { cn } from '@/shared/lib'

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      'rounded-lg border bg-white text-slate-900 shadow-card',
      className
    )}
    {...props}
  />
))
Card.displayName = 'Card'

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex flex-col space-y-1.5 p-6', className)}
    {...props}
  />
))
CardHeader.displayName = 'CardHeader'

const CardTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h3
    ref={ref}
    className={cn(
      'text-2xl font-semibold leading-none tracking-tight',
      className
    )}
    {...props}
  />
))
CardTitle.displayName = 'CardTitle'

const CardDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <p
    ref={ref}
    className={cn('text-sm text-gray-500', className)}
    {...props}
  />
))
CardDescription.displayName = 'CardDescription'

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn('p-6 pt-0', className)} {...props} />
))
CardContent.displayName = 'CardContent'

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn('flex items-center p-6 pt-0', className)}
    {...props}
  />
))
CardFooter.displayName = 'CardFooter'

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/ui/index.ts
════════════════════════════════════════════════════════════════

// shadcn/ui components
export * from './button'
export * from './card'
export * from './input'


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/shared/ui/input.tsx
════════════════════════════════════════════════════════════════

import * as React from 'react'

import { cn } from '@/shared/lib'

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          'flex h-10 w-full rounded-md border border-input bg-white px-3 py-2 text-sm ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-gray-500 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50',
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = 'Input'

export { Input }


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/stores/analysis.ts
════════════════════════════════════════════════════════════════

import { create } from 'zustand'
import type { AgentName, AgentStatus, AnalysisResult } from '@/shared/types'

interface AgentState {
  name: AgentName
  status: AgentStatus
  progress: number
  message?: string
  completedAt?: string
}

interface AnalysisState {
  // Current analysis
  currentAnalysis: AnalysisResult | null
  isAnalyzing: boolean
  
  // Agent progress
  agents: Record<AgentName, AgentState>
  
  // Overall progress
  overallProgress: number
  
  // Actions
  setCurrentAnalysis: (analysis: AnalysisResult | null) => void
  startAnalysis: () => void
  updateAgentStatus: (
    agent: AgentName,
    status: AgentStatus,
    message?: string
  ) => void
  updateAgentProgress: (agent: AgentName, progress: number) => void
  completeAgent: (agent: AgentName, message?: string) => void
  completeAnalysis: (result: AnalysisResult) => void
  resetAnalysis: () => void
}

const initialAgents: Record<AgentName, AgentState> = {
  expert: {
    name: 'expert',
    status: 'pending',
    progress: 0,
  },
  provocateur: {
    name: 'provocateur',
    status: 'pending',
    progress: 0,
  },
  validator: {
    name: 'validator',
    status: 'pending',
    progress: 0,
  },
  synthesizer: {
    name: 'synthesizer',
    status: 'pending',
    progress: 0,
  },
}

export const useAnalysisStore = create<AnalysisState>((set, get) => ({
  currentAnalysis: null,
  isAnalyzing: false,
  agents: initialAgents,
  overallProgress: 0,

  setCurrentAnalysis: (analysis) => 
    set({ currentAnalysis: analysis }),

  startAnalysis: () =>
    set({
      isAnalyzing: true,
      agents: {
        expert: { ...initialAgents.expert, status: 'running' },
        provocateur: initialAgents.provocateur,
        validator: initialAgents.validator,
        synthesizer: initialAgents.synthesizer,
      },
      overallProgress: 0,
    }),

  updateAgentStatus: (agent, status, message) =>
    set((state) => ({
      agents: {
        ...state.agents,
        [agent]: {
          ...state.agents[agent],
          status,
          message,
        },
      },
    })),

  updateAgentProgress: (agent, progress) =>
    set((state) => {
      const newAgents = {
        ...state.agents,
        [agent]: {
          ...state.agents[agent],
          progress,
        },
      }

      // Calculate overall progress
      const totalProgress = Object.values(newAgents).reduce(
        (sum, a) => sum + a.progress,
        0
      )
      const overallProgress = totalProgress / 4

      return {
        agents: newAgents,
        overallProgress,
      }
    }),

  completeAgent: (agent, message) =>
    set((state) => {
      const newAgents = {
        ...state.agents,
        [agent]: {
          ...state.agents[agent],
          status: 'completed' as AgentStatus,
          progress: 100,
          message,
          completedAt: new Date().toISOString(),
        },
      }

      // Start next agent
      const agentOrder: AgentName[] = ['expert', 'provocateur', 'validator', 'synthesizer']
      const currentIndex = agentOrder.indexOf(agent)
      const nextAgent = agentOrder[currentIndex + 1]

      if (nextAgent) {
        newAgents[nextAgent] = {
          ...newAgents[nextAgent],
          status: 'running',
        }
      }

      return { agents: newAgents }
    }),

  completeAnalysis: (result) =>
    set({
      currentAnalysis: result,
      isAnalyzing: false,
      overallProgress: 100,
    }),

  resetAnalysis: () =>
    set({
      currentAnalysis: null,
      isAnalyzing: false,
      agents: initialAgents,
      overallProgress: 0,
    }),
}))


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/src/stores/ui.ts
════════════════════════════════════════════════════════════════

import { create } from 'zustand'

interface UIState {
  // Theme
  theme: 'light' | 'dark'
  setTheme: (theme: 'light' | 'dark') => void
  toggleTheme: () => void

  // Sidebar
  sidebarCollapsed: boolean
  setSidebarCollapsed: (collapsed: boolean) => void
  toggleSidebar: () => void

  // Active module
  activeModule: 'review' | 'generation' | 'analytics' | 'history'
  setActiveModule: (module: UIState['activeModule']) => void
}

export const useUIStore = create<UIState>((set) => ({
  theme: 'light',
  setTheme: (theme) => set({ theme }),
  toggleTheme: () =>
    set((state) => ({
      theme: state.theme === 'light' ? 'dark' : 'light',
    })),

  sidebarCollapsed: false,
  setSidebarCollapsed: (collapsed) => set({ sidebarCollapsed: collapsed }),
  toggleSidebar: () =>
    set((state) => ({
      sidebarCollapsed: !state.sidebarCollapsed,
    })),

  activeModule: 'review',
  setActiveModule: (module) => set({ activeModule: module }),
}))


════════════════════════════════════════════════════════════════
FILE: agentis-law-base/scripts/03-categorize.js
════════════════════════════════════════════════════════════════

/**
 * Station 3: Категоризація статей
 * 
 * Додає категорії, теги та пріоритет до кожної статті
 * на основі структури кодексу (книга/глава) та ключових слів.
 * 
 * FIX M1 (Feb 14, 2026): Added article-number-range fallback
 *   — Chapter 58 (ст. 810-826) was categorized as 'loan' instead of 'lease'
 *   — Root cause: chapter extraction regex failed for some parsed articles
 *   — Fix: explicit article-number ranges as safety net
 * 
 * Запуск: node scripts/03-categorize.js
 * Вхід:  data/parsed/cku-parsed.json + data/parsed/kzpp-parsed.json
 * Вихід: data/categorized/all-articles-categorized.json
 */

const fs = require('fs');
const path = require('path');

// ═══════════════════════════════════════════
//  CONTRACT TYPE CATEGORIES
// ═══════════════════════════════════════════

const CATEGORIES = {
  general_contract: 'Загальні положення про договори',
  sale: 'Купівля-продаж',
  lease: 'Оренда / Найм',
  service: 'Послуги',
  work: 'Підряд',
  loan: 'Позика / Кредит',
  storage: 'Зберігання',
  transportation: 'Перевезення',
  insurance: 'Страхування',
  agency: 'Доручення / Комісія / Управління',
  partnership: 'Спільна діяльність',
  employment: 'Трудові відносини',
  employment_termination: 'Припинення трудового договору',
  wages: 'Оплата праці',
  working_time: 'Робочий час і відпочинок',
  labor_protection: 'Охорона праці',
  labor_discipline: 'Трудова дисципліна',
  labor_disputes: 'Трудові спори',
  material_liability: 'Матеріальна відповідальність',
  women_youth: 'Праця жінок та молоді',
  obligations_general: 'Загальні положення зобов\'язань',
  liability: 'Відповідальність за порушення',
  property: 'Право власності',
  persons: 'Фізичні та юридичні особи',
  intellectual_property: 'Інтелектуальна власність',
  inheritance: 'Спадкування',
  personal_rights: 'Особисті немайнові права',
  collective_agreement: 'Колективний договір',
  social_insurance: 'Соціальне страхування',
  education_benefits: 'Пільги (робота + навчання)',
  domestic_workers: 'Праця домашніх працівників',
  simplified_labor: 'Спрощений режим трудових відносин',
};

// ═══════════════════════════════════════════
//  ЦКУ MAPPING: Book + Chapter → Categories
// ═══════════════════════════════════════════

const CKU_BOOK_CATEGORIES = {
  '1': ['persons'],
  '2': ['personal_rights'],
  '3': ['property'],
  '4': ['intellectual_property'],
  '5': ['obligations_general'],
  '6': ['inheritance'],
};

const CKU_CHAPTER_CATEGORIES = {
  // Book 5: Obligations
  '47': ['obligations_general'],
  '48': ['obligations_general'],
  '49': ['obligations_general'],
  '50': ['obligations_general'],
  '51': ['liability'],
  '52': ['general_contract'],
  '53': ['general_contract'],
  '54': ['sale'],
  '55': ['sale'],
  '56': ['sale'],
  '57': ['lease'],
  '58': ['lease'],          // FIX M1: was already 'lease' in map, but regex missed it
  '59': ['loan'],
  '60': ['storage'],
  '61': ['work'],
  '62': ['work'],
  '63': ['service'],
  '64': ['transportation'],
  '65': ['storage'],
  '66': ['insurance'],
  '67': ['agency'],
  '68': ['agency'],
  '69': ['agency'],
  '70': ['loan'],
  '71': ['loan'],
  '72': ['loan'],
  '73': ['loan'],
  '74': ['partnership'],
  '75': ['general_contract'],
  '76': ['liability'],
  '77': ['liability'],
  // Book 1
  '3': ['persons'],
  '4': ['persons'],
  '5': ['persons'],
  '7': ['persons'],
  '8': ['persons'],
  '18': ['persons'],
  '19': ['persons'],
};

// ═══════════════════════════════════════════
//  FIX M1: Article-number-range fallback
//  Safety net for when chapter regex fails
// ═══════════════════════════════════════════

const CKU_ARTICLE_RANGE_CATEGORIES = [
  { from: 626, to: 654, categories: ['general_contract'] },
  { from: 655, to: 711, categories: ['sale'] },
  { from: 717, to: 730, categories: ['sale'] },       // Дарування
  { from: 731, to: 743, categories: ['sale'] },       // Рента
  { from: 759, to: 809, categories: ['lease'] },      // Ch. 57 Найм (оренда)
  { from: 810, to: 826, categories: ['lease'] },      // Ch. 58 Найм житла ← FIX M1
  { from: 827, to: 836, categories: ['loan'] },       // Ch. 59 Позичка
  { from: 837, to: 891, categories: ['work'] },       // Ch. 61 Підряд
  { from: 901, to: 907, categories: ['service'] },    // Ch. 63 Послуги
  { from: 908, to: 935, categories: ['transportation'] },
  { from: 936, to: 978, categories: ['storage'] },
  { from: 979, to: 999, categories: ['insurance'] },
  { from: 1000, to: 1045, categories: ['agency'] },
  { from: 1046, to: 1097, categories: ['loan'] },     // Ch. 70-73
  { from: 1166, to: 1215, categories: ['liability'] },
];

function getCategoriesByArticleRange(articleNumber) {
  const num = parseInt(articleNumber, 10);
  if (isNaN(num)) return null;
  for (const range of CKU_ARTICLE_RANGE_CATEGORIES) {
    if (num >= range.from && num <= range.to) {
      return range.categories;
    }
  }
  return null;
}

// ═══════════════════════════════════════════
//  КЗпП MAPPING: Chapter → Categories
// ═══════════════════════════════════════════

const KZPP_CHAPTER_CATEGORIES = {
  'I': ['employment'],
  'II': ['collective_agreement'],
  'III': ['employment', 'employment_termination'],
  'III-А': ['employment_termination'],
  'III-Б': ['simplified_labor'],
  'IV': ['working_time'],
  'V': ['working_time'],
  'VI': ['wages'],
  'VII': ['wages'],
  'VIII': ['employment'],
  'IX': ['material_liability'],
  'X': ['labor_discipline'],
  'XI': ['labor_protection'],
  'XI-А': ['domestic_workers'],
  'XII': ['women_youth'],
  'XIII': ['women_youth'],
  'XIV': ['education_benefits'],
  'XV': ['labor_disputes'],
  'XVI': ['employment'],
  'XVI-А': ['employment'],
  'XVII': ['social_insurance'],
  'XVIII': ['labor_protection'],
  'XIX': ['employment'],
};

// ═══════════════════════════════════════════
//  IMPORTANCE / PRIORITY RULES
// ═══════════════════════════════════════════

const CRITICAL_CKU_ARTICLES = new Set([
  '203', '215', '216', '217', '218', '229', '230', '231', '232', '233', '234',
  '509', '525', '526', '527', '530', '533', '546', '549', '550', '551',
  '610', '611', '612', '613', '614', '615', '616', '617', '623', '624',
  '626', '627', '628', '629', '631', '632', '638', '639', '640', '641',
  '642', '643', '651', '652', '653', '654',
  '655', '656', '662', '665', '668', '669', '670', '671', '672',
  '759', '760', '762', '763', '773', '774',
  '810', '813', '815', '825',  // FIX M1: Added critical housing lease articles
  '837', '839', '843', '846', '849',
  '901', '902', '903', '905',
  '1046', '1054', '1057',
]);

const CRITICAL_KZPP_ARTICLES = new Set([
  '21', '22', '23', '24', '26', '28', '29', '30', '31', '32', '33',
  '36', '38', '39', '40', '41', '42', '43', '44', '46', '47', '48',
  '49-5', '49-6', '49-8',
  '50', '51', '56',
  '94', '95', '96', '97', '103', '105', '106', '107',
  '115', '116', '117',
  '130', '132', '133', '134', '135', '136',
  '139', '140', '141', '142', '147', '148',
  '153', '155', '157', '158', '159',
  '175', '176', '177', '178', '179', '180', '181', '182', '184',
  '221', '222', '223', '225', '228', '229', '232', '233', '234', '235',
  '265',
]);

// ═══════════════════════════════════════════
//  KEYWORD-BASED TAGGING
// ═══════════════════════════════════════════

const KEYWORD_TAGS = [
  { keywords: ['істотні умови', 'істотних умов', 'предмет договору'], tag: 'essential_terms' },
  { keywords: ['недійсн', 'нікчемн', 'оспорюван'], tag: 'invalidity' },
  { keywords: ['відповідальність', 'штраф', 'пеня', 'неустойк', 'збитк'], tag: 'liability' },
  { keywords: ['строк', 'термін', 'давність'], tag: 'deadlines' },
  { keywords: ['розірван', 'припинен', 'скасуван'], tag: 'termination' },
  { keywords: ['форма договору', 'письмова форма', 'нотаріальн'], tag: 'form_requirements' },
  { keywords: ['гарантія', 'забезпечен', 'заставу', 'порук', 'завдат'], tag: 'guarantees' },
  { keywords: ['ціна', 'оплат', 'розрахунк', 'плат'], tag: 'payment' },
  { keywords: ['передач', 'приймання', 'акт'], tag: 'delivery' },
  { keywords: ['якість', 'недолік', 'дефект', 'гарантійн'], tag: 'quality' },
  { keywords: ['звільнен', 'вивільнен', 'скороченн'], tag: 'dismissal' },
  { keywords: ['відпустк'], tag: 'vacation' },
  { keywords: ['випробуванн'], tag: 'probation' },
  { keywords: ['дискримінац', 'мобінг', 'цькуванн'], tag: 'discrimination' },
  { keywords: ['вагітн', 'жінк', 'материнств'], tag: 'maternity' },
  { keywords: ['неповнолітн', 'молод'], tag: 'youth_labor' },
  { keywords: ['конфіденцій', 'комерційна таємниця'], tag: 'confidentiality' },
  { keywords: ['форс-мажор', 'непереборн', 'непередбачуван'], tag: 'force_majeure' },
];

// ═══════════════════════════════════════════
//  MAIN PROCESSING
// ═══════════════════════════════════════════

function categorizeArticle(article) {
  let categories = [];
  let tags = [];
  let importance = 'normal';

  if (article.code === 'ЦКУ') {
    const chapterStr = article.chapter || '';
    const chapterNumMatch = chapterStr.match(/Глава\s+(\d+)/i);
    const chapterNum = chapterNumMatch ? chapterNumMatch[1] : null;

    const bookStr = article.book || '';
    let bookNum = null;
    if (bookStr.includes('ПЕРША')) bookNum = '1';
    else if (bookStr.includes('ДРУГА')) bookNum = '2';
    else if (bookStr.includes('ТРЕТЯ')) bookNum = '3';
    else if (bookStr.includes('ЧЕТВЕРТА')) bookNum = '4';
    else if (bookStr.includes("П'ЯТА")) bookNum = '5';
    else if (bookStr.includes('ШОСТА')) bookNum = '6';

    // 1. Categories: Article range (most reliable) → Chapter → Book fallback
    // FIX M1: Range check runs FIRST because parser sometimes assigns wrong
    // chapter to articles (e.g. ст.810-826 got chapter 59 instead of 58)
    const rangeCats = getCategoriesByArticleRange(article.article_number);
    if (rangeCats) {
      categories = [...rangeCats];
    } else if (chapterNum && CKU_CHAPTER_CATEGORIES[chapterNum]) {
      categories = [...CKU_CHAPTER_CATEGORIES[chapterNum]];
    } else if (bookNum && CKU_BOOK_CATEGORIES[bookNum]) {
      categories = [...CKU_BOOK_CATEGORIES[bookNum]];
    }

    // 2. Importance
    if (CRITICAL_CKU_ARTICLES.has(article.article_number)) {
      importance = 'critical';
    } else if (bookNum === '5') {
      importance = 'high';
    }

  } else if (article.code === 'КЗпП') {
    const chapter = article.chapter;
    if (chapter && KZPP_CHAPTER_CATEGORIES[chapter]) {
      categories = [...KZPP_CHAPTER_CATEGORIES[chapter]];
    }

    if (chapter === 'III') {
      const num = parseInt(article.article_number);
      if (num >= 36 && num <= 49) {
        categories = ['employment_termination'];
      }
    }

    if (CRITICAL_KZPP_ARTICLES.has(article.article_number)) {
      importance = 'critical';
    } else {
      importance = 'high';
    }
  }

  // 3. Keyword-based tags
  const textToSearch = `${article.title || ''} ${article.text || ''}`.toLowerCase();
  for (const { keywords, tag } of KEYWORD_TAGS) {
    if (keywords.some(kw => textToSearch.includes(kw))) {
      tags.push(tag);
    }
  }

  // 4. Default categories
  if (categories.length === 0) {
    categories = article.code === 'ЦКУ' ? ['general_contract'] : ['employment'];
  }

  return {
    categories: [...new Set(categories)],
    tags: [...new Set(tags)],
    importance,
  };
}

// ═══════════════════════════════════════════
//  LOAD & PROCESS
// ═══════════════════════════════════════════

const DATA_DIR = path.join(__dirname, '..', 'data');

const ckuRaw = JSON.parse(fs.readFileSync(path.join(DATA_DIR, 'parsed', 'cku-parsed.json'), 'utf-8'));
const ckuArticles = ckuRaw.articles || ckuRaw;

const kzppArticles = JSON.parse(fs.readFileSync(path.join(DATA_DIR, 'parsed', 'kzpp-parsed.json'), 'utf-8'));

console.log(`📖 Loaded ЦКУ: ${ckuArticles.length} articles`);
console.log(`📖 Loaded КЗпП: ${kzppArticles.length} articles`);

const activeKzpp = kzppArticles.filter(a => !a.is_excluded);
console.log(`   КЗпП active: ${activeKzpp.length}`);

const allCategorized = [];

for (const art of ckuArticles) {
  const { categories, tags, importance } = categorizeArticle(art);
  allCategorized.push({
    id: `cku_${art.article_number.replace(/-/g, '_')}`,
    code: 'ЦКУ',
    article_number: art.article_number,
    title: art.title || '',
    text: art.text || '',
    book: art.book || null,
    book_title: art.book_title || null,
    section: art.section || null,
    chapter: art.chapter || null,
    chapter_title: art.chapter_title || null,
    paragraph: art.paragraph || null,
    categories,
    tags,
    importance,
    metadata: {
      code_full_name: 'Цивільний кодекс України',
      source: 'zakon.rada.gov.ua',
      categorized_at: new Date().toISOString(),
    }
  });
}

for (const art of activeKzpp) {
  const { categories, tags, importance } = categorizeArticle(art);
  allCategorized.push({
    id: art.id || `kzpp_${art.article_number.replace(/-/g, '_')}`,
    code: 'КЗпП',
    article_number: art.article_number,
    title: art.title || '',
    text: art.text || '',
    book: null,
    book_title: null,
    section: null,
    chapter: art.chapter || null,
    chapter_title: art.chapter_title || null,
    paragraph: null,
    categories,
    tags,
    importance,
    metadata: {
      code_full_name: 'Кодекс законів про працю України',
      source: 'zakon.rada.gov.ua',
      categorized_at: new Date().toISOString(),
    }
  });
}

// ═══════════════════════════════════════════
//  STATISTICS
// ═══════════════════════════════════════════

console.log('\n═══════════════════════════════════════════');
console.log('  CATEGORIZATION RESULTS');
console.log('═══════════════════════════════════════════\n');
console.log(`Total articles: ${allCategorized.length}`);

const byCrit = allCategorized.filter(a => a.importance === 'critical').length;
const byHigh = allCategorized.filter(a => a.importance === 'high').length;
const byNorm = allCategorized.filter(a => a.importance === 'normal').length;
console.log(`\n📊 By importance:`);
console.log(`  🔴 Critical: ${byCrit}`);
console.log(`  🟡 High:     ${byHigh}`);
console.log(`  ⚪ Normal:   ${byNorm}`);

const catCounts = {};
for (const art of allCategorized) {
  for (const cat of art.categories) {
    catCounts[cat] = (catCounts[cat] || 0) + 1;
  }
}
const sortedCats = Object.entries(catCounts).sort((a, b) => b[1] - a[1]);
console.log(`\n📋 By category (top 15):`);
for (const [cat, count] of sortedCats.slice(0, 15)) {
  const label = CATEGORIES[cat] || cat;
  console.log(`  ${cat.padEnd(25)} ${String(count).padStart(4)} articles  (${label})`);
}

const tagCounts = {};
for (const art of allCategorized) {
  for (const tag of art.tags) {
    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
  }
}
const sortedTags = Object.entries(tagCounts).sort((a, b) => b[1] - a[1]);
console.log(`\n🏷️  By tag (top 10):`);
for (const [tag, count] of sortedTags.slice(0, 10)) {
  console.log(`  ${tag.padEnd(20)} ${String(count).padStart(4)} articles`);
}

// FIX M1: Verify Chapter 58 articles are correctly categorized
const ch58Check = allCategorized.filter(a => {
  const num = parseInt(a.article_number, 10);
  return a.code === 'ЦКУ' && num >= 810 && num <= 826;
});
const ch58Wrong = ch58Check.filter(a => !a.categories.includes('lease'));
if (ch58Wrong.length > 0) {
  console.warn(`\n⚠️  FIX M1 FAILED: ${ch58Wrong.length} articles in 810-826 NOT categorized as 'lease':`);
  for (const a of ch58Wrong) {
    console.warn(`   ст.${a.article_number}: ${a.categories.join(', ')}`);
  }
} else {
  console.log(`\n✅ FIX M1: All ${ch58Check.length} articles in 810-826 correctly categorized as 'lease'`);
}

// ═══════════════════════════════════════════
//  SAVE OUTPUT
// ═══════════════════════════════════════════

const outputDir = path.join(DATA_DIR, 'categorized');
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

const outputFile = path.join(outputDir, 'all-articles-categorized.json');
fs.writeFileSync(outputFile, JSON.stringify(allCategorized, null, 2), 'utf-8');

const fileSizeMB = (fs.statSync(outputFile).size / (1024 * 1024)).toFixed(2);
console.log(`\n💾 Saved: ${outputFile}`);
console.log(`   Size: ${fileSizeMB} MB`);
console.log(`   Articles: ${allCategorized.length}`);

const compactIndex = allCategorized.map(a => ({
  id: a.id,
  code: a.code,
  article_number: a.article_number,
  title: a.title,
  categories: a.categories,
  tags: a.tags,
  importance: a.importance,
  text_length: a.text.length,
}));
fs.writeFileSync(
  path.join(outputDir, 'articles-index.json'),
  JSON.stringify(compactIndex, null, 2),
  'utf-8'
);
console.log(`   Index: articles-index.json (${compactIndex.length} entries)`);


════════════════════════════════════════════════════════════════
FILE: agentis-law-base/scripts/04-embed-and-upload.py
════════════════════════════════════════════════════════════════

#!/usr/bin/env python3
"""
Station 4+5: Embeddings + Pinecone Upload
Python, zero dependencies (only stdlib).

Run:
  export OPENAI_API_KEY=sk-...
  export PINECONE_API_KEY=pcsk_...
  python3 scripts/04-embed-and-upload.py
"""

import json, os, sys, time, urllib.request, urllib.error

OPENAI_KEY = os.environ.get('OPENAI_API_KEY', '')
PINECONE_KEY = os.environ.get('PINECONE_API_KEY', '')

INDEX_NAME = 'agentis-law'
NAMESPACE = 'ua-law-v1'
MAX_CHUNK = 6000
BATCH_SIZE = 30

SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
INPUT_FILE = os.path.join(SCRIPT_DIR, '..', 'data', 'categorized', 'all-articles-categorized.json')


def http_json(method, url, body=None, headers=None):
    hdrs = {'Content-Type': 'application/json'}
    if headers:
        hdrs.update(headers)
    data = json.dumps(body).encode('utf-8') if body else None
    req = urllib.request.Request(url, data=data, headers=hdrs, method=method)
    try:
        with urllib.request.urlopen(req, timeout=120) as resp:
            text = resp.read().decode('utf-8')
            return json.loads(text) if text.strip() else {}
    except urllib.error.HTTPError as e:
        error_body = e.read().decode('utf-8')[:300]
        raise Exception(f"HTTP {e.code}: {error_body}")


def openai_embed(texts):
    return http_json('POST', 'https://api.openai.com/v1/embeddings',
        body={'model': 'text-embedding-3-small', 'input': texts},
        headers={'Authorization': f'Bearer {OPENAI_KEY}'})


def pinecone_api(method, url, body=None):
    return http_json(method, url, body=body, headers={'Api-Key': PINECONE_KEY})


def ensure_pinecone_index():
    indexes = pinecone_api('GET', 'https://api.pinecone.io/indexes')
    idx = next((i for i in (indexes.get('indexes') or []) if i['name'] == INDEX_NAME), None)
    if not idx:
        print('  Creating Pinecone index (wait ~60s)...')
        try:
            pinecone_api('POST', 'https://api.pinecone.io/indexes', {
                'name': INDEX_NAME, 'dimension': 1536, 'metric': 'cosine',
                'spec': {'serverless': {'cloud': 'aws', 'region': 'us-east-1'}}
            })
        except Exception as e:
            if '409' not in str(e): raise
        for _ in range(12):
            time.sleep(10)
            sys.stdout.write('.')
            sys.stdout.flush()
            check = pinecone_api('GET', 'https://api.pinecone.io/indexes')
            idx = next((i for i in (check.get('indexes') or []) if i['name'] == INDEX_NAME), None)
            if idx and idx.get('status', {}).get('ready'): break
        print(' Ready')
    if not idx or not idx.get('host'):
        raise Exception('Could not get Pinecone host')
    return f"https://{idx['host']}"


def article_to_chunks(art):
    header = f"{art['code']} Стаття {art['article_number']}. {art.get('title', '')}"
    full = f"{header}\n\n{art.get('text', '')}"
    meta = {
        'article_id': art['id'], 'code': art['code'],
        'article_number': art['article_number'],
        'title': (art.get('title') or '')[:200],
        'chapter': art.get('chapter') or '',
        'chapter_title': (art.get('chapter_title') or '')[:200],
        'categories': ','.join(art.get('categories', [])),
        'tags': ','.join(art.get('tags', [])),
        'importance': art.get('importance', 'normal'),
        'text_length': len(art.get('text', '')),
    }

    if len(full) <= MAX_CHUNK:
        return [{'id': art['id'], 'text': full,
                 'metadata': {**meta, 'chunk_index': 0, 'total_chunks': 1}}]

    # Split long articles
    chunks = []
    max_len = MAX_CHUNK - len(header) - 30
    if max_len < 500:
        max_len = 500
    text = art.get('text', '')
    start = 0
    idx = 0
    overlap = 200

    while start < len(text):
        end = min(start + max_len, len(text))

        # Try to break at sentence boundary
        if end < len(text):
            bp = max(text.rfind('.', start, end), text.rfind('\n', start, end))
            if bp > start + max_len * 0.5:
                end = bp + 1

        chunks.append({
            'id': f"{art['id']}_chunk{idx}",
            'text': f"{header} [ч.{idx+1}]\n\n{text[start:end].strip()}",
            'metadata': {**meta, 'chunk_index': idx, 'total_chunks': 0}
        })
        idx += 1

        # FIXED: if we reached the end, stop
        if end >= len(text):
            break

        # Advance with overlap, but ALWAYS move forward
        new_start = end - overlap
        if new_start <= start:
            new_start = start + 1  # force progress
        start = new_start

    for c in chunks:
        c['metadata']['total_chunks'] = len(chunks)
    return chunks


def main():
    print('=' * 45)
    print('  AGENTIS LAW — Embeddings + Pinecone')
    print('=' * 45)
    print()

    if not OPENAI_KEY:
        print('❌ export OPENAI_API_KEY=sk-...'); sys.exit(1)
    if not PINECONE_KEY:
        print('❌ export PINECONE_API_KEY=pcsk_...'); sys.exit(1)

    # 1. Load & chunk
    print('📖 Loading articles...')
    with open(INPUT_FILE, 'r', encoding='utf-8') as f:
        articles = json.load(f)
    print(f'   {len(articles)} articles')

    print('✂️  Chunking...')
    all_chunks = []
    for art in articles:
        all_chunks.extend(article_to_chunks(art))
    print(f'   {len(all_chunks)} chunks')
    del articles

    # 2. Pinecone
    print('\n📌 Pinecone...')
    host = ensure_pinecone_index()
    print(f'   {host}')

    # 3. Embed + upload
    total = len(all_chunks)
    total_batches = (total + BATCH_SIZE - 1) // BATCH_SIZE
    total_tokens = 0
    uploaded = 0

    print(f'\n🚀 {total} chunks in {total_batches} batches...\n')

    for i in range(0, total, BATCH_SIZE):
        batch = all_chunks[i:i+BATCH_SIZE]
        bnum = i // BATCH_SIZE + 1
        sys.stdout.write(f'  [{bnum}/{total_batches}] ')
        sys.stdout.flush()

        # Embed
        emb = None
        for r in range(3):
            try:
                emb = openai_embed([c['text'] for c in batch])
                break
            except Exception as e:
                sys.stdout.write(f'retry...')
                sys.stdout.flush()
                time.sleep(3 * (r + 1))
        if not emb:
            print('❌ skip'); continue

        total_tokens += emb.get('usage', {}).get('total_tokens', 0)

        vectors = [{'id': batch[j]['id'], 'values': emb['data'][j]['embedding'],
                     'metadata': batch[j]['metadata']} for j in range(len(batch))]

        # Upload
        for r in range(3):
            try:
                pinecone_api('POST', f'{host}/vectors/upsert',
                             {'vectors': vectors, 'namespace': NAMESPACE})
                break
            except Exception as e:
                sys.stdout.write('pine-retry...')
                sys.stdout.flush()
                time.sleep(3 * (r + 1))

        uploaded += len(vectors)
        cost = (total_tokens / 1_000_000) * 0.02
        print(f'✅ {uploaded}/{total} (${cost:.4f})')
        time.sleep(0.3)

    # 4. Stats
    time.sleep(3)
    try:
        stats = pinecone_api('POST', f'{host}/describe_index_stats', {})
        print()
        print('=' * 45)
        print('  ✅ DONE')
        print(f'  Uploaded: {uploaded}')
        print(f'  Pinecone vectors: {stats.get("totalVectorCount", "?")}')
        ns = stats.get('namespaces', {}).get(NAMESPACE, {})
        print(f'  Namespace "{NAMESPACE}": {json.dumps(ns)}')
        print(f'  Tokens: {total_tokens:,}')
        print(f'  Cost: ~${(total_tokens / 1_000_000) * 0.02:.4f}')
        print('=' * 45)
    except:
        print(f'\n✅ Uploaded {uploaded} vectors')


if __name__ == '__main__':
    main()


════════════════════════════════════════════════════════════════
FILE: agentis-law-base/scripts/parse-cku.js
════════════════════════════════════════════════════════════════

#!/usr/bin/env node
/**
 * AGENTIS Law Database — Парсер ЦКУ
 * 
 * Що робить:
 * 1. Читає cku.txt (весь текст Цивільного кодексу)
 * 2. Знаходить кожну статтю
 * 3. Витягує номер, назву, текст
 * 4. Визначає до якої книги/розділу/глави належить
 * 5. Зберігає у структурований JSON
 * 
 * Запуск: node scripts/parse-cku.js
 */

const fs = require('fs');
const path = require('path');

// === НАЛАШТУВАННЯ ===
const INPUT_FILE = path.join(__dirname, '..', 'data', 'raw', 'cku.txt');
const OUTPUT_FILE = path.join(__dirname, '..', 'data', 'parsed', 'cku-parsed.json');

// Створити папку якщо немає
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

console.log('📚 AGENTIS — Парсер Цивільного кодексу України');
console.log('================================================\n');

// === КРОК 1: Прочитати файл ===
console.log('📖 Читаю файл...');
const raw = fs.readFileSync(INPUT_FILE, 'utf-8');
const lines = raw.split('\n');
console.log(`   Рядків у файлі: ${lines.length}\n`);

// === КРОК 2: Пройтись по рядках, знайти структуру ===
console.log('🔍 Шукаю статті, книги, розділи, глави...\n');

let currentBook = '';      // "КНИГА ПЕРША ЗАГАЛЬНІ ПОЛОЖЕННЯ"
let currentSection = '';   // "Розділ I ОСНОВНІ ПОЛОЖЕННЯ"
let currentChapter = '';   // "Глава 1 ЦИВІЛЬНЕ ЗАКОНОДАВСТВО УКРАЇНИ"
let currentParagraph = ''; // "§ 2. Роздрібна купівля-продаж"

const articles = [];
let currentArticle = null;

for (let i = 0; i < lines.length; i++) {
  const line = lines[i];
  const trimmed = line.trim();

  // --- Знайшли КНИГУ ---
  // Формат: "КНИГА ПЕРША " (наступний рядок — назва великими)
  if (/^КНИГА\s/.test(trimmed)) {
    // Назва книги може бути на тому ж рядку або наступному
    const nextLine = (lines[i + 1] || '').trim();
    if (nextLine && /^[А-ЯІЇЄҐ\s]+$/.test(nextLine)) {
      currentBook = trimmed + ' ' + nextLine;
    } else {
      currentBook = trimmed;
    }
    currentSection = '';
    currentChapter = '';
    currentParagraph = '';
    continue;
  }

  // --- Знайшли РОЗДІЛ ---
  // Формат: "Розділ I " або "Розділ II" (наступний рядок — назва великими)
  if (/^Розділ\s+[IVXLC]+\s*/.test(trimmed)) {
    const nextLine = (lines[i + 1] || '').trim();
    if (nextLine && /^[А-ЯІЇЄҐ\s''.]+$/.test(nextLine)) {
      currentSection = trimmed + ' ' + nextLine;
    } else {
      currentSection = trimmed;
    }
    currentChapter = '';
    currentParagraph = '';
    continue;
  }

  // --- Знайшли ГЛАВУ ---
  // Формат: "Глава 1 " (наступний рядок — назва великими)
  if (/^Глава\s+\d+/.test(trimmed)) {
    const nextLine = (lines[i + 1] || '').trim();
    if (nextLine && /^[А-ЯІЇЄҐ\s''.()]+$/.test(nextLine)) {
      currentChapter = trimmed + ' ' + nextLine;
    } else {
      currentChapter = trimmed;
    }
    currentParagraph = '';
    continue;
  }

  // --- Знайшли ПАРАГРАФ ---
  // Формат: "§ 2. Роздрібна купівля-продаж"
  if (/^§\s*\d+/.test(trimmed)) {
    currentParagraph = trimmed;
    continue;
  }

  // --- Знайшли СТАТТЮ ---
  // Формат: "Стаття 626. Поняття та види договору"
  // Або:    "Стаття 48-1. Правові наслідки..."
  const articleMatch = trimmed.match(/^Стаття\s+(\d+(?:-\d+)?)\.\s*(.+)$/);
  if (articleMatch) {
    // Зберегти попередню статтю (якщо є)
    if (currentArticle) {
      currentArticle.text = cleanText(currentArticle.text);
      articles.push(currentArticle);
    }

    // Почати нову статтю
    currentArticle = {
      id: `ЦКУ-${articleMatch[1]}`,
      code: 'ЦКУ',
      article_number: articleMatch[1], // "626" або "48-1"
      title: articleMatch[2].trim(),
      text: '',
      book: currentBook,
      section: currentSection,
      chapter: currentChapter,
      paragraph: currentParagraph || undefined,
      source_url: `https://zakon.rada.gov.ua/laws/show/435-15#Text`,
      last_verified: new Date().toISOString().split('T')[0]
    };
    continue;
  }

  // --- Звичайний рядок (текст статті) ---
  if (currentArticle) {
    currentArticle.text += line + '\n';
  }
}

// Не забути останню статтю
if (currentArticle) {
  currentArticle.text = cleanText(currentArticle.text);
  articles.push(currentArticle);
}

// === КРОК 3: Очистити тексти ===
function cleanText(text) {
  return text
    // Прибрати порожні рядки на початку та кінці
    .trim()
    // Прибрати рядки що є заголовками наступної книги/розділу/глави
    // (вони потрапили в текст останньої статті перед ними)
    .replace(/\n(КНИГА\s.+)/g, '')
    .replace(/\n(Розділ\s+[IVXLC]+\s*)/g, '')
    .replace(/\n(Глава\s+\d+\s*)/g, '')
    // Прибрати зайві порожні рядки (більше 2 підряд → 1)
    .replace(/\n{3,}/g, '\n\n')
    .trim();
}

// === КРОК 4: Статистика ===
console.log(`✅ Знайдено статей: ${articles.length}\n`);

// Порахувати по книгах
const byBook = {};
for (const a of articles) {
  const bookShort = a.book.substring(0, 30) + '...';
  byBook[bookShort] = (byBook[bookShort] || 0) + 1;
}
console.log('📖 По книгах:');
for (const [book, count] of Object.entries(byBook)) {
  console.log(`   ${book}: ${count} статей`);
}

// Показати приклади
console.log('\n📋 Приклади (перші 3 статті):');
for (const a of articles.slice(0, 3)) {
  console.log(`\n   ${a.id}: ${a.title}`);
  console.log(`   Книга: ${a.book.substring(0, 40)}`);
  console.log(`   Глава: ${a.chapter.substring(0, 40)}`);
  console.log(`   Текст: ${a.text.substring(0, 80)}...`);
}

// Показати статтю 626 як контроль
const art626 = articles.find(a => a.article_number === '626');
if (art626) {
  console.log(`\n📋 Контрольна перевірка — Стаття 626:`);
  console.log(`   Назва: ${art626.title}`);
  console.log(`   Книга: ${art626.book.substring(0, 50)}`);
  console.log(`   Глава: ${art626.chapter}`);
  console.log(`   Текст (перші 150 символів):`);
  console.log(`   ${art626.text.substring(0, 150)}...`);
}

// === КРОК 5: Зберегти ===
const output = {
  code: 'ЦКУ',
  full_name: 'Цивільний кодекс України',
  document_id: '435-IV',
  source_url: 'https://zakon.rada.gov.ua/laws/show/435-15',
  parsed_date: new Date().toISOString().split('T')[0],
  total_articles: articles.length,
  articles: articles
};

fs.writeFileSync(OUTPUT_FILE, JSON.stringify(output, null, 2), 'utf-8');

console.log(`\n✅ ГОТОВО!`);
console.log(`📁 Збережено: data/parsed/cku-parsed.json`);
console.log(`📊 Всього: ${articles.length} статей`);
console.log(`📦 Розмір файлу: ${(fs.statSync(OUTPUT_FILE).size / 1024 / 1024).toFixed(2)} MB`);


════════════════════════════════════════════════════════════════
FILE: agentis-law-base/scripts/parse-kzpp.js
════════════════════════════════════════════════════════════════

/**
 * КЗпП (Кодекс законів про працю України) Parser
 * Parses the full text of the Labor Code from txt file into structured JSON
 * 
 * Structure: Глава (Chapter) → Стаття (Article)
 * No Books (Книга), Sections (Розділ), or Paragraphs (§) unlike ЦКУ
 */

const fs = require('fs');
const path = require('path');

// Input/output paths
const INPUT_FILE = path.join(__dirname, '..', 'data', 'raw', 'kzpp.txt');
const OUTPUT_FILE = path.join(__dirname, '..', 'data', 'parsed', 'kzpp-parsed.json');

// Read the file
const text = fs.readFileSync(INPUT_FILE, 'utf-8');
const lines = text.split('\n');

console.log(`📄 КЗпП file: ${lines.length} lines`);

// State tracking
let currentChapter = null;
let currentChapterTitle = null;
let articles = [];
let currentArticle = null;

// Regex patterns
const chapterRegex = /^(?:Глава|ГЛАВА)\s+([IVXLC][\-IVXLCАБВГД]*)\s*$/i;
const articleRegex = /^Стаття\s+([\d\-]+)\.\s*(.+)$/;

function cleanText(text) {
  return text
    // Remove editorial comments {Із змінами...}
    .replace(/\{[^}]*\}/g, '')
    // Remove multiple spaces
    .replace(/\s+/g, ' ')
    .trim();
}

function saveCurrentArticle() {
  if (currentArticle) {
    const fullText = currentArticle.isExcluded 
      ? currentArticle.title  // For excluded articles, the title contains the exclusion info
      : cleanText(currentArticle.rawLines.join('\n'));
    
    if (fullText.length > 0) {
      articles.push({
        id: `kzpp_${currentArticle.number.replace(/-/g, '_')}`,
        code: 'КЗпП',
        article_number: currentArticle.number,
        title: currentArticle.title,
        text: fullText,
        chapter: currentChapter,
        chapter_title: currentChapterTitle,
        is_excluded: currentArticle.isExcluded,
        metadata: {
          source: 'zakon.rada.gov.ua',
          parsed_at: new Date().toISOString(),
          code_full_name: 'Кодекс законів про працю України'
        }
      });
    }
  }
}

// Parse line by line
for (let i = 0; i < lines.length; i++) {
  const line = lines[i].trim();
  
  // Skip empty lines
  if (!line) continue;
  
  // Check for Chapter header
  const chapterMatch = line.match(chapterRegex);
  if (chapterMatch) {
    currentChapter = chapterMatch[1].trim();
    
    // Next non-empty line should be the chapter title
    for (let j = i + 1; j < lines.length; j++) {
      const nextLine = lines[j].trim();
      if (nextLine) {
        // Chapter title is typically in ALL CAPS
        if (nextLine === nextLine.toUpperCase() && nextLine.length > 3 && !nextLine.match(articleRegex)) {
          currentChapterTitle = nextLine;
        }
        break;
      }
    }
    continue;
  }
  
  // Check for Article header
  const articleMatch = line.match(articleRegex);
  if (articleMatch) {
    // Save previous article
    saveCurrentArticle();
    
    const articleNumber = articleMatch[1];
    let title = articleMatch[2].trim();
    
    // Check if article is excluded
    const isExcluded = /виключено/.test(title);
    
    // For excluded articles, keep the original title with exclusion info
    // For active articles, clean the title
    const cleanedTitle = isExcluded ? title.replace(/[{}]/g, '').trim() : cleanText(title);
    
    currentArticle = {
      number: articleNumber,
      title: cleanedTitle,
      rawLines: [],
      isExcluded: isExcluded
    };
    
    // If excluded, the title contains the full info, no body needed
    if (!isExcluded) {
      // Don't add the header line to rawLines - the body starts from next lines
    }
    
    continue;
  }
  
  // If we're inside an article, accumulate text
  if (currentArticle && !currentArticle.isExcluded) {
    // Skip chapter title lines (ALL CAPS)
    if (line === line.toUpperCase() && line.length > 3 && !line.match(/^\d/)) {
      continue;
    }
    currentArticle.rawLines.push(line);
  }
}

// Save the last article
saveCurrentArticle();

// Stats
const activeArticles = articles.filter(a => !a.is_excluded);
const excludedArticles = articles.filter(a => a.is_excluded);

console.log(`\n✅ Parsing complete!`);
console.log(`📊 Total articles found: ${articles.length}`);
console.log(`   ├── Active: ${activeArticles.length}`);
console.log(`   └── Excluded (виключено): ${excludedArticles.length}`);

// Chapter breakdown
const chapters = {};
for (const article of articles) {
  const key = `${article.chapter} - ${article.chapter_title}`;
  if (!chapters[key]) chapters[key] = 0;
  chapters[key]++;
}

console.log(`\n📋 Articles by Chapter:`);
for (const [chapter, count] of Object.entries(chapters)) {
  console.log(`   Глава ${chapter}: ${count} articles`);
}

// Ensure output directory exists
const outputDir = path.dirname(OUTPUT_FILE);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Write output
fs.writeFileSync(OUTPUT_FILE, JSON.stringify(articles, null, 2), 'utf-8');

const fileSizeMB = (fs.statSync(OUTPUT_FILE).size / (1024 * 1024)).toFixed(2);
console.log(`\n💾 Output: ${OUTPUT_FILE}`);
console.log(`   Size: ${fileSizeMB} MB`);

// Quick verification - show a sample article
const sampleArticle = articles.find(a => a.article_number === '21' && !a.is_excluded);
if (sampleArticle) {
  console.log(`\n🔍 Sample - Стаття ${sampleArticle.article_number}: ${sampleArticle.title}`);
  console.log(`   Chapter: Глава ${sampleArticle.chapter} - ${sampleArticle.chapter_title}`);
  console.log(`   Text preview: ${sampleArticle.text.substring(0, 200)}...`);
}


════════════════════════════════════════════════════════════════
FILE: agentis-law-base/scripts/test-rag.py
════════════════════════════════════════════════════════════════

#!/usr/bin/env python3
"""
Test RAG: search Pinecone for relevant articles given sample contract text.

Run:
  export OPENAI_API_KEY=sk-...
  export PINECONE_API_KEY=pcsk_...
  python3 scripts/test-rag.py
"""

import json, os, sys, urllib.request, urllib.error

OPENAI_KEY = os.environ.get('OPENAI_API_KEY', '')
PINECONE_KEY = os.environ.get('PINECONE_API_KEY', '')
PINECONE_HOST = os.environ.get('PINECONE_HOST', '')  # will auto-detect
NAMESPACE = 'ua-law-v1'


def http_json(method, url, body=None, headers=None):
    hdrs = {'Content-Type': 'application/json'}
    if headers: hdrs.update(headers)
    data = json.dumps(body).encode('utf-8') if body else None
    req = urllib.request.Request(url, data=data, headers=hdrs, method=method)
    with urllib.request.urlopen(req, timeout=30) as resp:
        return json.loads(resp.read().decode('utf-8'))


def get_host():
    if PINECONE_HOST: return PINECONE_HOST
    indexes = http_json('GET', 'https://api.pinecone.io/indexes', headers={'Api-Key': PINECONE_KEY})
    idx = next((i for i in (indexes.get('indexes') or []) if i['name'] == 'agentis-law'), None)
    if not idx: raise Exception('Index not found')
    return f"https://{idx['host']}"


def embed(text):
    res = http_json('POST', 'https://api.openai.com/v1/embeddings',
        body={'model': 'text-embedding-3-small', 'input': text},
        headers={'Authorization': f'Bearer {OPENAI_KEY}'})
    return res['data'][0]['embedding']


def search(host, vector, top_k=10):
    res = http_json('POST', f'{host}/query',
        body={'vector': vector, 'topK': top_k, 'includeMetadata': True, 'namespace': NAMESPACE},
        headers={'Api-Key': PINECONE_KEY})
    return res.get('matches', [])


# ═══════════════════════════════════════════
#  TEST CASES
# ═══════════════════════════════════════════

TESTS = [
    {
        'name': '🏠 Договір оренди квартири',
        'text': '''Договір оренди житлового приміщення. 
        Орендодавець передає, а Орендар приймає у тимчасове платне користування квартиру. 
        Орендна плата складає 15000 грн на місяць. Строк оренди 12 місяців.
        Орендар зобов\'язаний своєчасно сплачувати орендну плату та комунальні послуги.''',
        'expect': ['lease', 'оренд', 'найм'],
    },
    {
        'name': '👷 Трудовий договір',
        'text': '''Трудовий договір. Роботодавець приймає Працівника на посаду менеджера з продажу.
        Випробувальний строк 3 місяці. Заробітна плата 25000 грн.
        Режим роботи: понеділок-п\'ятниця, з 9:00 до 18:00.
        Працівник має право на щорічну відпустку 24 календарних дні.''',
        'expect': ['employment', 'трудов', 'КЗпП'],
    },
    {
        'name': '🛒 Договір купівлі-продажу',
        'text': '''Договір купівлі-продажу товару. Продавець зобов\'язується передати у власність 
        Покупця товар, а Покупець зобов\'язується прийняти товар та оплатити його вартість.
        Ціна товару 500000 грн. Доставка за рахунок Продавця.
        Гарантійний строк 12 місяців з дати поставки.''',
        'expect': ['sale', 'купівл', 'продаж'],
    },
]


def main():
    print('=' * 50)
    print('  AGENTIS RAG — Test Search')
    print('=' * 50)

    host = get_host()
    print(f'Pinecone: {host}\n')

    for test in TESTS:
        print(f'\n{test["name"]}')
        print('-' * 50)

        # Embed query
        vector = embed(test['text'])

        # Search
        matches = search(host, vector, top_k=10)

        if not matches:
            print('  ❌ No results!')
            continue

        print(f'  Top 10 results (score = cosine similarity):\n')
        for m in matches:
            meta = m.get('metadata', {})
            score = m.get('score', 0)
            code = meta.get('code', '?')
            art_num = meta.get('article_number', '?')
            title = meta.get('title', '')[:60]
            importance = meta.get('importance', '')
            categories = meta.get('categories', '')

            icon = '🔴' if importance == 'critical' else '🟡' if importance == 'high' else '⚪'
            print(f'  {icon} {score:.3f}  {code} ст.{art_num} — {title}')
            print(f'          [{categories}]')

        # Check expectations
        all_text = ' '.join(
            f"{m.get('metadata',{}).get('code','')} {m.get('metadata',{}).get('title','')} {m.get('metadata',{}).get('categories','')}"
            for m in matches[:5]
        ).lower()
        
        found = [e for e in test['expect'] if e.lower() in all_text]
        if found:
            print(f'\n  ✅ Знайдено очікуване: {found}')
        else:
            print(f'\n  ⚠️  Очікувалось: {test["expect"]}')


if __name__ == '__main__':
    main()


════════════════════════════════════════════════════════════════
FILE: package.json
════════════════════════════════════════════════════════════════

{
  "name": "legal-council",
  "version": "0.1.0",
  "private": true,
  "description": "Multi-agent AI platform for Ukrainian legal work - Contract Review & Document Generation",
  "author": "Oleksandr",
  "license": "MIT",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:integration": "LEGAL_COUNCIL_ENV=testing jest --testPathPattern=integration"
  },
  "dependencies": {
    "@anthropic-ai/sdk": "^0.20.0",
    "@google/generative-ai": "^0.2.0",
    "next": "^14.1.0",
    "node-cache": "^5.1.2",
    "openai": "^4.104.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^6.2.0",
    "@testing-library/react": "^14.1.2",
    "@types/node": "^20.11.0",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "@typescript-eslint/eslint-plugin": "^6.19.0",
    "@typescript-eslint/parser": "^6.19.0",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.1.0",
    "jest": "^29.7.0",
    "ts-jest": "^29.1.1",
    "typescript": "^5.3.3"
  },
  "engines": {
    "node": ">=18.0.0",
    "npm": ">=9.0.0"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/legal-council.git"
  },
  "keywords": [
    "legal-tech",
    "ai",
    "multi-agent",
    "contract-review",
    "document-generation",
    "ukrainian-law",
    "claude",
    "gpt-4",
    "gemini"
  ]
}


════════════════════════════════════════════════════════════════
FILE: tsconfig.json
════════════════════════════════════════════════════════════════

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "jsx": "preserve",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "allowJs": true,
    "checkJs": false,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "incremental": true,
    "isolatedModules": true,
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "@/*": ["./*"],
      "@/core/*": ["./packages/core/*"],
      "@/legal-council/*": ["./packages/legal-council/*"],
      "@/ui-shared/*": ["./packages/ui-shared/*"]
    },
    "plugins": [
      {
        "name": "next"
      }
    ]
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    "packages/**/*.ts"
  ],
  "exclude": [
    "node_modules",
    ".next",
    "out",
    "build",
    "dist"
  ]
}


════════════════════════════════════════════════════════════════
FILE: middleware.ts
════════════════════════════════════════════════════════════════

/**
 * Next.js Middleware — CORS Support
 * 
 * FIX #19 (Feb 13, 2026): Adds CORS headers to /api/* routes
 * so the frontend on a different port/domain can reach the backend.
 * 
 * Place this file at the root of the backend project: middleware.ts
 */

import { NextRequest, NextResponse } from 'next/server';

// Allowed origins — add production domain when deploying
const ALLOWED_ORIGINS = [
  'http://localhost:3000',
  'http://localhost:3001',
  'http://localhost:3002',
  // Add production origins here:
  // 'https://agentis.legal',
  // 'https://app.agentis.legal',
];

export function middleware(request: NextRequest) {
  const origin = request.headers.get('origin') || '';

  // Only apply to API routes
  if (!request.nextUrl.pathname.startsWith('/api/')) {
    return NextResponse.next();
  }

  // Handle preflight OPTIONS requests
  if (request.method === 'OPTIONS') {
    const response = new NextResponse(null, { status: 204 });
    setCorsHeaders(response, origin);
    return response;
  }

  // Normal requests: add CORS headers to response
  const response = NextResponse.next();
  setCorsHeaders(response, origin);
  return response;
}

function setCorsHeaders(response: NextResponse, origin: string): void {
  // Allow specific origins (or wildcard for dev)
  if (ALLOWED_ORIGINS.includes(origin)) {
    response.headers.set('Access-Control-Allow-Origin', origin);
  } else if (process.env.NODE_ENV === 'development') {
    // In development, allow any origin
    response.headers.set('Access-Control-Allow-Origin', '*');
  }

  response.headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');
  response.headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization');
  response.headers.set('Access-Control-Max-Age', '86400'); // Cache preflight for 24h
}

// Only run on API routes
export const config = {
  matcher: '/api/:path*',
};


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/package.json
════════════════════════════════════════════════════════════════

{
  "name": "legal-council-ui",
  "version": "1.0.0",
  "description": "Ukrainian Legal Contract Analysis - Frontend",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "next": "^14.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "typescript": "^5.3.3",
    
    "@radix-ui/react-accordion": "^1.1.2",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-select": "^2.0.0",
    "@radix-ui/react-tabs": "^1.0.4",
    "@radix-ui/react-tooltip": "^1.0.7",
    "@radix-ui/react-slot": "^1.0.2",
    
    "@tanstack/react-query": "^5.17.19",
    "@tanstack/react-virtual": "^3.0.1",
    "zustand": "^4.5.0",
    
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.0",
    "tailwindcss-animate": "^1.0.7",
    
    "lucide-react": "^0.309.0",
    "date-fns": "^3.2.0",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/node": "^20.11.5",
    "@types/react": "^18.2.48",
    "@types/react-dom": "^18.2.18",
    "autoprefixer": "^10.4.17",
    "postcss": "^8.4.33",
    "tailwindcss": "^3.4.1",
    "eslint": "^8.56.0",
    "eslint-config-next": "^14.1.0"
  },
  "engines": {
    "node": ">=18.17.0",
    "npm": ">=9.0.0"
  }
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/tsconfig.json
════════════════════════════════════════════════════════════════

{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/tailwind.config.ts
════════════════════════════════════════════════════════════════

import type { Config } from 'tailwindcss'

const config: Config = {
  darkMode: ['class'],
  content: [
    './src/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        // Simple direct colors - no HSL variables!
        navy: '#1E3A8A',        // Primary brand color
        teal: '#0F766E',        // Secondary
        crimson: '#BE123C',     // Critical risk
        orange: '#D97706',      // High risk  
        gold: '#B8860B',        // Medium risk
        green: '#15803D',       // Low/Safe risk
      },
      fontFamily: {
        sans: ['Inter', 'system-ui', 'sans-serif'],
        serif: ['IBM Plex Serif', 'Georgia', 'serif'],
        mono: ['JetBrains Mono', 'Consolas', 'monospace'],
      },
      borderRadius: {
        sm: '4px',
        DEFAULT: '6px',
        md: '6px',
        lg: '8px',
      },
      spacing: {
        xs: '4px',
        sm: '8px',
        md: '16px',
        lg: '24px',
        xl: '32px',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
}

export default config


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/next.config.js
════════════════════════════════════════════════════════════════

/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  
  // Experimental features
  experimental: {
    // Server actions enabled for forms
    serverActions: {
      bodySizeLimit: '5mb', // For contract uploads
    },
  },
  
  // Optimize fonts
  optimizeFonts: true,
  
  // Compiler options
  compiler: {
    removeConsole: process.env.NODE_ENV === 'production',
  },
  
  // Environment variables available on client
  env: {
    NEXT_PUBLIC_APP_NAME: 'Legal Council',
    NEXT_PUBLIC_APP_VERSION: '1.0.0',
  },
}

module.exports = nextConfig


════════════════════════════════════════════════════════════════
FILE: legal-council-ui-clean/postcss.config.js
════════════════════════════════════════════════════════════════

module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}


════════════════════════════════════════════════════════════════
FILE: env.example
════════════════════════════════════════════════════════════════

# Legal Council (AGENTIS) - Environment Variables
# Copy this file to .env and fill in your actual values

# ==========================================
# LLM API KEYS (Required)
# ==========================================

# Anthropic Claude API Key
# Get from: https://console.anthropic.com/
# FIX #5: Using safe placeholder instead of real prefix format
ANTHROPIC_API_KEY=YOUR_ANTHROPIC_API_KEY_HERE

# OpenAI GPT API Key
# Get from: https://platform.openai.com/api-keys
OPENAI_API_KEY=YOUR_OPENAI_API_KEY_HERE

# Google Gemini API Key
# Get from: https://aistudio.google.com/apikey
GOOGLE_API_KEY=YOUR_GOOGLE_API_KEY_HERE

# ==========================================
# ENVIRONMENT MODE
# ==========================================

# Options: production | testing | development
# - production: Best quality, highest cost (Opus as Expert)
# - testing: Good quality, 70% cheaper (Sonnet as Expert) ← RECOMMENDED for MVP
# - development: Max savings (Gemini where possible)
LEGAL_COUNCIL_ENV=testing

# ==========================================
# NEXT.JS CONFIGURATION
# ==========================================

# Application URL (for CORS, webhooks, etc.)
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Backend API URL (for frontend proxy — if frontend is separate from backend)
# If running monorepo with both in same Next.js app, leave commented out
# NEXT_PUBLIC_API_URL=http://localhost:3000
# BACKEND_URL=http://localhost:3000

# Node environment
NODE_ENV=development

# ==========================================
# OPTIONAL: DATABASE (Future)
# ==========================================

# PostgreSQL connection (if using database for audit logs)
# DATABASE_URL=postgresql://user:password@localhost:5432/legal_council

# ==========================================
# OPTIONAL: MONITORING (Future)
# ==========================================

# Sentry DSN for error tracking
# SENTRY_DSN=YOUR_SENTRY_DSN_HERE

# ==========================================
# COST LIMITS (Optional Safety)
# ==========================================

# Maximum cost per query in USD (safety limit)
# MAX_COST_PER_QUERY=1.00

# Daily cost limit in USD
# DAILY_COST_LIMIT=50.00

# ==========================================
# FEATURE FLAGS (Optional)
# ==========================================

# Enable audit trail logging (true | false)
ENABLE_AUDIT_TRAIL=true

# Enable cost tracking (true | false)
ENABLE_COST_TRACKING=true

# ==========================================
# NOTES
# ==========================================

# 1. NEVER commit .env to Git (it's in .gitignore)
# 2. Keep .env.example up to date when adding new variables
# 3. For production deployment:
#    - Set LEGAL_COUNCIL_ENV=production
#    - Use environment variables in hosting platform (Vercel, Railway, etc.)
#    - Rotate API keys regularly
# 4. Cost estimates (testing mode):
#    - Contract Review: ~$0.14 per query
#    - Document Generation: ~$0.18 per query
#    - 100 queries/day = ~$16/day = ~$500/month



════════════════════════════════════════════════════════════════
  END OF PROJECT CODE
════════════════════════════════════════════════════════════════

Total Files: 62
Total Lines: 9798
Generated: 2026-02-14 14:36:51
Project: AGENTIS Legal Council v2.1.0

════════════════════════════════════════════════════════════════
