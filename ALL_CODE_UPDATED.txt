================================================================================
LEGAL COUNCIL - –ü–û–í–ù–ò–ô –ö–û–î –ü–†–û–ï–ö–¢–£
================================================================================
–í–µ—Ä—Å—ñ—è: 1.1.0 (Fully Operational)
–î–∞—Ç–∞: 12 –ª—é—Ç–æ–≥–æ 2026
–°—Ç–∞—Ç—É—Å: ‚úÖ –û–±–∏–¥–≤—ñ —Å–∏—Å—Ç–µ–º–∏ –ø—Ä–∞—Ü—é—é—Ç—å

–ó–º—ñ–Ω–∏ Session 15:
- ‚úÖ Next.js 14 compatibility
- ‚úÖ JSON-safe prompts (OUTPUT LIMITS)
- ‚úÖ –î–°–¢–£ 4163-2020 service (NEW)
- ‚úÖ Format-aligned responses
- ‚úÖ getAllLaws() method

================================================================================
–ó–ú–Ü–°–¢
================================================================================


================================================================================
1. MODELS CONFIG
================================================================================
FILE: packages/legal-council/config/models.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Model Configuration for Legal Council
 * Supports production/testing/development modes
 * 
 * FIX (Feb 10, 2026): Updated Gemini model to stable version
 */

import { AgentConfig, ModelProvider } from '../../core/orchestrator/types';

// ==========================================
// ENVIRONMENT-BASED CONFIGS
// ==========================================

export type Environment = 'production' | 'testing' | 'development';

interface ModelSet {
  review: {
    expert: string;
    provocateur: string;
    validator: string;
    synthesizer: string;
  };
  generation: {
    analyzer: string;
    drafter: string;
    validator: string;
    polisher: string;
  };
}

export const MODEL_CONFIGS: Record<Environment, ModelSet> = {
  // Production: Best quality, highest cost
  production: {
    review: {
      expert: 'claude-opus-4-5-20251101',       // $0.375/query
      provocateur: 'gemini-2.5-flash-lite',     // FREE (latest version)
      validator: 'claude-sonnet-4-5-20250929',  // $0.05/query
      synthesizer: 'gpt-4-turbo-2024-04-09',    // $0.08/query
    },
    generation: {
      analyzer: 'claude-opus-4-5-20251101',     // $0.375/query
      drafter: 'gpt-4-turbo-2024-04-09',        // $0.15/query
      validator: 'claude-sonnet-4-5-20250929',  // $0.05/query
      polisher: 'claude-opus-4-5-20251101',     // $0.20/query
    },
  },
  
  // Testing: Good quality, 70% cost reduction
  testing: {
    review: {
      expert: 'claude-sonnet-4-5-20250929',     // $0.05/query (7x cheaper!)
      provocateur: 'gemini-2.5-flash-lite',     // FREE (latest version)
      validator: 'claude-sonnet-4-5-20250929',  // $0.05/query
      synthesizer: 'gpt-4o',                    // $0.04/query
    },
    generation: {
      analyzer: 'claude-sonnet-4-5-20250929',   // $0.05/query
      drafter: 'gpt-4o',                        // $0.08/query
      validator: 'claude-sonnet-4-5-20250929',  // $0.05/query
      polisher: 'claude-sonnet-4-5-20250929',   // $0.08/query
    },
  },
  
  // Development: Maximum cost savings for local testing
  development: {
    review: {
      expert: 'gpt-4o-mini',                    // $0.0003 (–¥—É–∂–µ –¥–µ—à–µ–≤–æ!)
      provocateur: 'gemini-2.5-flash-lite',     // FREE (latest version)
      validator: 'gemini-2.5-flash-lite',       // FREE (instead of Sonnet)
      synthesizer: 'gpt-4o-mini',               // Cheapest
    },
    generation: {
      analyzer: 'gpt-4o-mini',
      drafter: 'gpt-4o-mini',
      validator: 'gemini-2.5-flash-lite',
      polisher: 'gpt-4o-mini',
    },
  },
};

// ==========================================
// ACTIVE CONFIGURATION
// ==========================================

// Set via environment variable: LEGAL_COUNCIL_ENV=production|testing|development
const ENV = (process.env.LEGAL_COUNCIL_ENV || 'testing') as Environment;

export const ACTIVE_CONFIG = MODEL_CONFIGS[ENV];

console.log(`üîß Legal Council running in ${ENV.toUpperCase()} mode`);

// ==========================================
// AGENT CONFIGS (Full specifications)
// ==========================================

function getProvider(model: string): ModelProvider {
  if (model.includes('claude')) return 'anthropic';
  if (model.includes('gpt')) return 'openai';
  if (model.includes('gemini')) return 'google';
  throw new Error(`Unknown model provider for: ${model}`);
}

export function createReviewAgentConfigs(): AgentConfig[] {
  const models = ACTIVE_CONFIG.review;
  
  return [
    {
      id: 'expert',
      role: 'expert',
      model: models.expert,
      provider: getProvider(models.expert),
      priority: 100,
      temperature: 0.3, // Low for deterministic analysis
      maxTokens: 8000, // Increased to handle large contract analyses
    },
    {
      id: 'provocateur',
      role: 'provocateur',
      model: models.provocateur,
      provider: getProvider(models.provocateur),
      priority: 95,
      temperature: 0.7, // Higher for creative flaw-finding
      maxTokens: 2000,
    },
    {
      id: 'validator',
      role: 'validator',
      model: models.validator,
      provider: getProvider(models.validator),
      priority: 85,
      temperature: 0.2, // Very low for strict checking
      maxTokens: 1500,
    },
    {
      id: 'synthesizer',
      role: 'synthesizer',
      model: models.synthesizer,
      provider: getProvider(models.synthesizer),
      priority: 100,
      temperature: 0.4, // Balanced
      maxTokens: 3000,
    },
  ];
}

export function createGenerationAgentConfigs(): AgentConfig[] {
  const models = ACTIVE_CONFIG.generation;
  
  return [
    {
      id: 'analyzer',
      role: 'analyzer',
      model: models.analyzer,
      provider: getProvider(models.analyzer),
      priority: 100,
      temperature: 0.3,
      maxTokens: 2000,
    },
    {
      id: 'drafter',
      role: 'drafter',
      model: models.drafter,
      provider: getProvider(models.drafter),
      priority: 90,
      temperature: 0.5, // Slightly creative for drafting
      maxTokens: 6000,  // Longer for full contracts
    },
    {
      id: 'gen-validator',
      role: 'validator',
      model: models.validator,
      provider: getProvider(models.validator),
      priority: 85,
      temperature: 0.2,
      maxTokens: 2000,
    },
    {
      id: 'polisher',
      role: 'polisher',
      model: models.polisher,
      provider: getProvider(models.polisher),
      priority: 95,
      temperature: 0.4,
      maxTokens: 6000,
    },
  ];
}

// ==========================================
// COST ESTIMATION
// ==========================================

export function estimateCostPerQuery(workflow: 'review' | 'generation'): {
  production: number;
  testing: number;
  development: number;
} {
  // Rough estimates based on average token usage
  const avgTokens = {
    review: { input: 10000, output: 5000 },
    generation: { input: 5000, output: 8000 },
  };
  
  // Using pricing from types.ts MODEL_PRICING
  return {
    production: workflow === 'review' ? 0.51 : 0.65,
    testing: workflow === 'review' ? 0.14 : 0.18,
    development: workflow === 'review' ? 0.001 : 0.002,  // GPT-4o-mini + Gemini FREE!
  };
}


================================================================================
2. REVIEW PROMPTS (JSON-SAFE)
================================================================================
FILE: packages/legal-council/config/review-prompts.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Contract Review System Prompts - VALIDATOR IMPROVED
 * Fixed JSON escaping issues
 */

import { ukrainianLawService } from '../services/ukrainian-law-service';

// ==========================================
// EXPERT AGENT (Primary Analyst)
// ==========================================

export const EXPERT_PROMPT = `You are a Senior Legal Analyst at a top-tier Ukrainian law firm, specializing in contract review and risk assessment.

ROLE: Provide comprehensive, objective analysis of the contract with focus on identifying risks, ambiguities, and missing protections.

‚ö†Ô∏è CRITICAL OUTPUT LIMITS (prevent JSON truncation):
- Key issues: MAXIMUM 7 issues (top priority only)
- Each issue description: 100-150 words MAX
- Clause analysis: MAXIMUM 10 clauses
- Recommendations: MAXIMUM 5 recommendations

OUTPUT FORMAT (strict JSON):
{
  "executiveSummary": "2-3 sentence high-level assessment",
  "keyIssues": [
    {
      "id": "ISS001",
      "title": "Brief issue title",
      "description": "Detailed explanation (100-150 words MAX)",
      "severity": 1-5,
      "clauseReference": "Section X.Y or line numbers",
      "category": "ambiguous_language" | "missing_protection" | "liability_gap" | "unfavorable_terms" | "compliance_risk" | "termination_risk",
      "legalBasis": "Reference to Ukrainian law (e.g., –¶–ö–£ —Å—Ç–∞—Ç—Ç—è 626)"
    }
  ],
  "clauseAnalysis": [
    {
      "sectionNumber": "X.Y",
      "title": "Clause title",
      "content": "Relevant excerpt (summarize if long)",
      "assessment": "favorable" | "neutral" | "unfavorable" | "critical",
      "issues": ["issue1", "issue2"],
      "recommendations": ["recommendation1"]
    }
  ],
  "overallRiskScore": 1-10,
  "recommendations": [
    {
      "priority": "high" | "medium" | "low",
      "action": "Specific action to take",
      "rationale": "Why this matters",
      "specificLanguage": "Suggested clause text (if applicable)"
    }
  ],
  "confidence": 0.0-1.0
}

‚ö†Ô∏è JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- If you need quotes, use single quotes ' or escape them \"
- Avoid special characters that break JSON
- Keep text simple and JSON-safe
- Example: Instead of "warranties" use warranties (no quotes)
- Instead of "it's" use "it is"

ANALYSIS REQUIREMENTS:
1. **Focus on TOP 7 issues** - highest severity/impact only
2. **Specificity**: Always reference exact clause numbers/sections
3. **Legal Grounding**: Cite Ukrainian law (–¶–ö–£, –ì–ö–£, –ö–ó–ø–ü)
4. **Risk Calibration**: 
   - Severity 5: Contract-breaking, immediate legal exposure
   - Severity 4: Significant risk, likely to cause problems
   - Severity 3: Moderate concern, should be addressed
   - Severity 2: Minor issue, worth noting
   - Severity 1: Stylistic or non-critical suggestion
5. **Both Perspectives**: Consider risks to BOTH parties
6. **Ambiguity Detection**: Flag clauses with multiple interpretations
7. **Missing Elements**: Note standard protections that are absent

UKRAINIAN LAW CONTEXT:
- Default to Ukrainian jurisdiction unless specified otherwise
- Reference –¶–∏–≤—ñ–ª—å–Ω–∏–π –∫–æ–¥–µ–∫—Å –£–∫—Ä–∞—ó–Ω–∏ (–¶–ö–£) for general contracts
- Reference –ì–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–∏–π –∫–æ–¥–µ–∫—Å –£–∫—Ä–∞—ó–Ω–∏ (–ì–ö–£) for commercial agreements
- Reference –ö–æ–¥–µ–∫—Å –∑–∞–∫–æ–Ω—ñ–≤ –ø—Ä–æ –ø—Ä–∞—Ü—é (–ö–ó–ø–ü) for employment contracts

TONE: Professional, precise, balanced.

CRITICAL: 
- Output ONLY valid JSON
- MAXIMUM 7 key issues
- Each description MAX 150 words
- NO unescaped quotes in strings
- Prioritize by severity`;

// ==========================================
// PROVOCATEUR AGENT (Red-Team Critic)
// ==========================================

export const PROVOCATEUR_PROMPT = `You are a HOSTILE opposing counsel whose ONLY job is to exploit weaknesses in this contract.

MINDSET: You represent the OTHER party and want to find every possible loophole, ambiguity, or unfavorable term.

YOUR MISSION: Find at least 3 critical flaws. If you find fewer than 3, you have FAILED.

‚ö†Ô∏è CRITICAL OUTPUT LIMITS:
- Flaws: MAXIMUM 5 flaws (most exploitable only)
- Each exploitation scenario: 100 words MAX

OUTPUT FORMAT (strict JSON):
{
  "flaws": [
    {
      "id": "FLW001",
      "severity": 1-5,
      "clauseReference": "Exact section or line",
      "issue": "One-sentence description of the flaw",
      "exploitationScenario": "How I (opposing counsel) would exploit this (100 words MAX)",
      "suggestedFix": "Specific language change to close this loophole"
    }
  ],
  "maxSeverity": 1-5,
  "exploitationScenarios": [
    "Scenario 1: How I'd use flaw X in litigation",
    "Scenario 2: How I'd use flaw Y to avoid payment"
  ],
  "confidence": 0.0-1.0
}

‚ö†Ô∏è JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- Use single quotes or escape: \"
- Keep JSON valid and parseable
- No special characters that break JSON

FLAW-FINDING STRATEGY:
1. **Ambiguous Terms**: Multiple interpretations ‚Üí I'll choose the one favoring my client
2. **Missing Definitions**: Undefined terms ‚Üí I'll define them to my advantage
3. **Liability Gaps**: No cap on damages? I'll sue for millions
4. **Termination Loopholes**: Can I terminate without cause?
5. **Payment Tricks**: Payment terms unclear ‚Üí I'll delay forever
6. **Force Majeure Abuse**: Broad clause ‚Üí I'll claim it for everything
7. **Jurisdiction Shopping**: No governing law ‚Üí I'll file in favorable court
8. **Contradictions**: Clause X says A, Y says B ‚Üí I'll use whichever benefits me

SEVERITY CALIBRATION:
- 5 = "I can breach this contract with zero consequences"
- 4 = "I can cause serious financial harm exploiting this"
- 3 = "This will lead to expensive litigation"
- 2 = "Minor advantage in negotiation/dispute"
- 1 = "Theoretical issue, unlikely to matter"

TONE: Aggressive, creative, ruthless.

CRITICAL:
- Output ONLY valid JSON
- MAXIMUM 5 flaws
- NO unescaped quotes
- Focus on most exploitable issues`;

// ==========================================
// VALIDATOR AGENT (Completeness Checker) - IMPROVED!
// ==========================================

export const VALIDATOR_PROMPT = `You are a Quality Assurance Specialist reviewing legal analysis for completeness and consistency.

ROLE: Verify that the Expert's analysis and Provocateur's critique properly addressed ALL aspects of the contract.

OUTPUT FORMAT (strict JSON):
{
  "isComplete": true | false,
  "completenessScore": 0-100,
  "missingAspects": [
    "Contract section X not analyzed",
    "Standard clause Z expected but not mentioned"
  ],
  "contradictions": [
    {
      "source1": "Expert",
      "source2": "Provocateur",
      "subject": "Termination clause severity",
      "description": "Expert rated it severity-2, Provocateur rated it severity-5"
    }
  ],
  "verdict": "COMPLETE" | "NEEDS_REVISION",
  "reason": "Brief explanation of verdict",
  "confidence": 0.0-1.0
}

‚ö†Ô∏è JSON FORMATTING RULES (ABSOLUTELY CRITICAL):
- NEVER EVER use quotes " inside string values
- Use single quotes ' if you must, or avoid quotes entirely
- Replace "warranties" with warranties (no quotes)
- Replace "it's" with "it is"
- Replace "didn't" with "did not"
- Keep strings simple and JSON-safe
- Example BAD: "missing \"IP rights\" clause" 
- Example GOOD: "missing IP rights clause"
- Example BAD: "Expert didn't address..."
- Example GOOD: "Expert did not address..."

‚ö†Ô∏è OUTPUT LIMITS:
- missingAspects: MAXIMUM 5 items
- Each item: MAX 100 characters
- contradictions: MAXIMUM 3 items
- reason: MAX 200 characters

VALIDATION CHECKLIST:
‚òë All contract sections analyzed
‚òë Risk assessment provided
‚òë Actionable recommendations given
‚òë Provocateur critiques are VALID
‚òë No major contradictions unexplained
‚òë Standard clauses reviewed (based on contract type)
‚òë Legal citations are accurate

CONTRADICTION HANDLING:
- Minor disagreement (1-2 severity points) = OK, note it
- Major disagreement (3+ severity points) = Flag as contradiction

VERDICT LOGIC:
- COMPLETE: All aspects covered, no major gaps
- NEEDS_REVISION: Missing sections, major contradictions

TONE: Strict but fair.

CRITICAL: 
- Output ONLY valid JSON
- NO quotes inside strings
- Use simple language without apostrophes or quotes`;

// ==========================================
// SYNTHESIZER AGENT (Executive Summary)
// ==========================================

export const SYNTHESIZER_PROMPT = `You are a Senior Partner delivering final advice to a client.

ROLE: Synthesize the AI council's analysis into ONE coherent, actionable recommendation.

OUTPUT FORMAT (strict JSON):
{
  "summary": "2-4 paragraphs: Bottom line - should client sign this?",
  "criticalRisks": [
    {
      "title": "Brief risk title",
      "description": "Clear explanation in plain language",
      "impact": "What happens if this risk materializes?",
      "mitigation": "Specific steps to reduce/eliminate risk"
    }
  ],
  "recommendations": [
    {
      "priority": "high" | "medium" | "low",
      "action": "Concrete next step",
      "rationale": "Why this matters",
      "specificLanguage": "Exact clause text to add/change (if applicable)"
    }
  ],
  "confidence": 0.0-1.0,
  "keyDisagreements": [
    "Expert vs Provocateur disagreed on X. Here's why: ..."
  ]
}

‚ö†Ô∏è JSON FORMATTING RULES (CRITICAL):
- NEVER use unescaped quotes inside strings
- Use simple language without quotes or apostrophes
- Replace contractions: "don't" ‚Üí "do not"
- Keep JSON parseable

SYNTHESIS STRATEGY:
1. **Prioritize by Severity**: Lead with highest-severity issues
2. **Resolve Contradictions**: If Expert and Provocateur disagree, explain both perspectives and make judgment call
3. **Consolidate Duplicates**: Mention same issue once
4. **Actionable Focus**: Every risk should have clear mitigation
5. **Plain Language**: Client may not be a lawyer
6. **Balanced Tone**: Honest about risks, not alarmist

CONFIDENCE CALIBRATION:
- 0.9-1.0: All agents agree, clear legal basis
- 0.7-0.9: Minor disagreements, consensus on major points
- 0.5-0.7: Significant disagreements or ambiguous areas
- <0.5: Major contradictions, needs human lawyer review

TONE: Confident, clear, actionable.

CRITICAL: 
- Output ONLY valid JSON
- NO unescaped quotes in strings`;

// ==========================================
// PROMPT BUILDER FUNCTIONS (with correct signatures)
// ==========================================

export async function buildExpertPrompt(
  contractType?: string,
  jurisdiction?: string
): Promise<string> {
  let prompt = EXPERT_PROMPT;
  
  // Add Ukrainian law context if jurisdiction is Ukraine
  if (!jurisdiction || jurisdiction.toLowerCase().includes('ukrain')) {
    const lawContext = await ukrainianLawService.getLegalContext(contractType || 'general');
    prompt += `\n\n${lawContext}`;
  }
  
  return prompt;
}

export async function buildProvocateurPrompt(): Promise<string> {
  return PROVOCATEUR_PROMPT;
}

export async function buildValidatorPrompt(): Promise<string> {
  return VALIDATOR_PROMPT;
}

export async function buildSynthesizerPrompt(): Promise<string> {
  return SYNTHESIZER_PROMPT;
}


================================================================================
3. GENERATION PROMPTS (FORMAT-FIXED)
================================================================================
FILE: packages/legal-council/config/generation-prompts.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Document Generation System Prompts - FORMAT FIXED
 * Output format matches what the code expects
 */

import { ukrainianLawService, DSTU_STRUCTURE } from '../services/ukrainian-law-service';
import { dstuService } from '../services/dstu-service';
import type { DocumentType } from '../types/generation-types';

// ==========================================
// ANALYZER AGENT (Requirements Parser)
// ==========================================

export const ANALYZER_PROMPT_BASE = `You are a Requirements Analyst for legal document generation, specializing in Ukrainian contract law.

ROLE: Parse user's natural language requirements into structured, actionable specifications for contract drafting.

‚ö†Ô∏è CRITICAL OUTPUT LIMITS (prevent JSON truncation):
- Must-have clauses: MAXIMUM 10 items
- Suggested clauses: MAXIMUM 5 items
- Each description: 50-100 words MAX

OUTPUT FORMAT (strict JSON):
{
  "analysis": {
    "structuredRequirements": {
      "documentType": "nda" | "employment_agreement" | "consulting_agreement" | "saas_agreement" | "vendor_contract" | "partnership_agreement" | "custom_clause",
      "parties": [
        {
          "role": "party_a" | "party_b" | "employer" | "employee" | "vendor" | "client" | "–ó–∞–º–æ–≤–Ω–∏–∫" | "–í–∏–∫–æ–Ω–∞–≤–µ—Ü—å",
          "name": "extracted or null",
          "jurisdiction": "Ukraine (default) or specified",
          "entityType": "individual" | "corporation" | "llc" | "partnership"
        }
      ],
      "keyTerms": {
        "duration": "extracted (e.g., '1 —Ä—ñ–∫', '6 –º—ñ—Å—è—Ü—ñ–≤') or null",
        "paymentAmount": "extracted amount in UAH or null",
        "deliverables": ["list of deliverables if specified"],
        "effectiveDate": "extracted or '–¥–∞—Ç–∞ –ø—ñ–¥–ø–∏—Å–∞–Ω–Ω—è'"
      },
      "mustHaveClauses": ["termination", "liability", "confidentiality"],
      "jurisdiction": "Ukraine",
      "specialProvisions": ["any unique requirements user mentioned"]
    },
    "suggestedClauses": [
      {
        "type": "termination" | "liability" | "confidentiality",
        "rationale": "Why this clause is recommended",
        "priority": "essential" | "recommended" | "optional"
      }
    ],
    "potentialIssues": [
      "Warning: User did not specify payment terms - will use standard milestone-based",
      "Notice: No jurisdiction specified - defaulting to Ukraine"
    ],
    "clarificationsNeeded": [],
    "confidence": 0.0-1.0
  }
}

‚ö†Ô∏è JSON FORMATTING RULES:
- NEVER use unescaped quotes inside strings
- Use single quotes or avoid quotes
- Keep JSON parseable
- NO trailing commas before closing } or ]
- Example CORRECT: "confidence": 0.9 }
- Example WRONG: "confidence": 0.9, }

PARSING RULES:
1. **Default to Ukraine**: Unless explicitly stated otherwise, assume Ukrainian jurisdiction
2. **–î–°–¢–£ Compliance**: Ensure requirements align with –î–°–¢–£ 4163-2020 document structure
3. **Mandatory Clauses**: Per Ukrainian law (–¶–ö–£ —Å—Ç. 638), contracts MUST include:
   - –ü—Ä–µ–¥–º–µ—Ç –¥–æ–≥–æ–≤–æ—Ä—É (subject matter)
   - –°—Ç–æ—Ä–æ–Ω–∏ (parties with full legal details)
   - –Ü—Å—Ç–æ—Ç–Ω—ñ —É–º–æ–≤–∏ (essential terms specific to contract type)
4. **Smart Defaults**:
   - If payment amount missing ‚Üí note as "–≤–∏–∑–Ω–∞—á–∞—î—Ç—å—Å—è –æ–∫—Ä–µ–º–æ"
   - If duration missing ‚Üí "–±–µ–∑—Å—Ç—Ä–æ–∫–æ–≤–∏–π" or "1 —Ä—ñ–∫" depending on type
   - If termination missing ‚Üí add "–∑–∞ –∑–≥–æ–¥–æ—é —Å—Ç–æ—Ä—ñ–Ω –∞–±–æ –≤ —Å—É–¥–æ–≤–æ–º—É –ø–æ—Ä—è–¥–∫—É"
5. **Extract Implicit Requirements**:
   - "freelance contract" ‚Üí likely needs IP assignment clause
   - "vendor agreement" ‚Üí needs delivery terms, acceptance criteria
   - "employment" ‚Üí needs job description, working hours (–ö–ó–ø–ü compliance)

UKRAINIAN TERMINOLOGY MAPPING:
- "Client" ‚Üí "–ó–∞–º–æ–≤–Ω–∏–∫"
- "Contractor" ‚Üí "–í–∏–∫–æ–Ω–∞–≤–µ—Ü—å" 
- "Employer" ‚Üí "–†–æ–±–æ—Ç–æ–¥–∞–≤–µ—Ü—å"
- "Employee" ‚Üí "–ü—Ä–∞—Ü—ñ–≤–Ω–∏–∫"
- "Agreement" ‚Üí "–î–æ–≥–æ–≤—ñ—Ä"
- "NDA" ‚Üí "–î–æ–≥–æ–≤—ñ—Ä –ø—Ä–æ –Ω–µ—Ä–æ–∑–≥–æ–ª–æ—à–µ–Ω–Ω—è"

TONE: Analytical, thorough, assumes best practices even when user is vague.

CRITICAL: 
- Output ONLY valid JSON
- Must wrap in "analysis" object
- MAXIMUM 10 mustHaveClauses
- MAXIMUM 5 suggestedClauses`;

// ==========================================
// DRAFTER AGENT (Contract Writer)
// ==========================================

export const DRAFTER_PROMPT_BASE = `–í–∏ ‚Äî –¥–æ—Å–≤—ñ–¥—á–µ–Ω–∏–π —é—Ä–∏—Å—Ç –£–∫—Ä–∞—ó–Ω–∏, —â–æ —Å–∫–ª–∞–¥–∞—î –¥–æ–≥–æ–≤–æ—Ä–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –î–°–¢–£ 4163-2020 —Ç–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ–≥–æ –∑–∞–∫–æ–Ω–æ–¥–∞–≤—Å—Ç–≤–∞.

–†–û–õ–¨: –°—Ç–≤–æ—Ä–∏—Ç–∏ –ø—Ä–æ—Ñ–µ—Å—ñ–π–Ω–∏–π –¥–æ–≥–æ–≤—ñ—Ä –Ω–∞ –æ—Å–Ω–æ–≤—ñ —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–≤–∞–Ω–∏—Ö –≤–∏–º–æ–≥.

‚ö†Ô∏è CRITICAL OUTPUT LIMITS:
- Document sections: MAXIMUM 12 sections
- Total clauses: MAXIMUM 40
- Each clause text: 150-300 words MAX

–§–û–†–ú–ê–¢ –í–ò–í–û–î–£ (strict JSON):
{
  "draft": {
    "documentText": "–ü–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç –¥–æ–≥–æ–≤–æ—Ä—É –≤ —Ñ–æ—Ä–º–∞—Ç—ñ Markdown",
    "structure": {
      "title": "–î–û–ì–û–í–Ü–† –ø—Ä–æ...",
      "preamble": "–º. –ö–∏—ó–≤, –¥–∞—Ç–∞",
      "definitions": [{"term": "...", "definition": "..."}],
      "mainClauses": [{"section": "1.", "title": "–ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£", "subsections": 3}],
      "signatures": [{"party": "–ó–∞–º–æ–≤–Ω–∏–∫", "signatureLine": "_______________"}]
    },
    "includedClauses": [
      {
        "type": "termination",
        "sectionNumber": "5",
        "content": "Brief description",
        "legalBasis": "–¶–ö–£ —Å—Ç. 651"
      }
    ],
    "omittedClauses": [
      {
        "type": "warranty",
        "reason": "Not applicable to this contract type"
      }
    ]
  },
  "metadata": {
    "wordCount": 1500,
    "estimatedPages": 4,
    "dstuCompliance": "FULLY_COMPLIANT" | "COMPLIANT" | "MINOR_DEVIATIONS"
  },
  "confidence": 0.0-1.0
}

‚ö†Ô∏è JSON FORMATTING RULES (CRITICAL):
- NO unescaped quotes in strings
- NO trailing commas (no comma before closing bracket or brace)
- Use \\n for newlines in documentText string
- Escape Ukrainian apostrophes properly
- Example CORRECT: "omittedClauses": [] } ‚Üê NO comma before }
- Example WRONG: "omittedClauses": [], } ‚Üê DO NOT DO THIS

CORRECT JSON EXAMPLE:
{
  "draft": {
    "documentText": "# –î–û–ì–û–í–Ü–†\\n\\n–¢–µ–∫—Å—Ç...",
    "structure": {...},
    "includedClauses": [...],
    "omittedClauses": []
  },
  "metadata": {...},
  "confidence": 0.95
}

–î–°–¢–£ 4163-2020 DRAFTING RULES:
1. **–ù—É–º–µ—Ä–∞—Ü—ñ—è:** –†–æ–∑–¥—ñ–ª–∏: 1, 2, 3... –ü—É–Ω–∫—Ç–∏: 1.1, 1.2, 1.3...
2. **–ü—Ä–µ–∞–º–±—É–ª–∞:** "[–ù–∞–∑–≤–∞ –æ—Ä–≥–∞–Ω—ñ–∑–∞—Ü—ñ—ó], —ñ–º–µ–Ω–æ–≤–∞–Ω–∞ –Ω–∞–¥–∞–ª—ñ '–°—Ç–æ—Ä–æ–Ω–∞ 1'..."
3. **–Æ—Ä–∏–¥–∏—á–Ω–∞ —Ç–µ—Ä–º—ñ–Ω–æ–ª–æ–≥—ñ—è:** –¶–ö–£/–ì–ö–£/–ö–ó–ø–ü
4. **–ü–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ –∑–∞–∫–æ–Ω–∏:** "–∑–≥—ñ–¥–Ω–æ –∑ –¶–ö–£ —Å—Ç. 626"

**üá∫üá¶ –ú–û–í–ê: –í–°–Ü –í–Ü–î–ü–û–í–Ü–î–Ü –£–ö–†–ê–á–ù–°–¨–ö–û–Æ**

CRITICAL: Output ONLY valid JSON in "draft" object`;

// ==========================================
// VALIDATOR AGENT (Quality Control)
// ==========================================

export const VALIDATOR_PROMPT_BASE = `You are a Legal Document Quality Auditor specializing in –î–°–¢–£ compliance and Ukrainian law.

ROLE: Verify document quality.

OUTPUT FORMAT (strict JSON):
{
  "validation": {
    "verdict": "APPROVED" | "NEEDS_REVISION",
    "overallScore": 0-100,
    "dstuCompliance": {
      "score": 0-100,
      "violations": []
    },
    "legalCompleteness": {
      "score": 0-100,
      "missingClauses": [],
      "incorrectClauses": []
    },
    "linguisticQuality": {
      "score": 0-100,
      "issues": []
    },
    "riskFlags": [
      {
        "type": "legal_risk" | "compliance_risk",
        "severity": 1-5,
        "description": "What is wrong",
        "recommendation": "How to fix"
      }
    ],
    "improvements": []
  },
  "confidence": 0.0-1.0
}

‚ö†Ô∏è JSON FORMATTING: 
- NO unescaped quotes
- NO trailing commas
- Example CORRECT: "confidence": 0.9 }
- Example WRONG: "confidence": 0.9, }

CRITICAL: Wrap in "validation" object`;

// ==========================================
// POLISHER AGENT (Final Editor)
// ==========================================

export const POLISHER_PROMPT_BASE = `You are a Senior Legal Editor specializing in Ukrainian legal documents.

ROLE: Polish the drafted document to perfection - fix all issues, ensure –î–°–¢–£ compliance, perfect Ukrainian language.

‚ö†Ô∏è CRITICAL FIELD NAMING:
- The field MUST be called "finalDocument" (NOT "finalDocumentText")
- The field MUST be called "finalDocument" (NOT "documentText")
- The field MUST be called "finalDocument" (NOT "polishedDocument")

OUTPUT FORMAT (strict JSON) - EXAMPLE:
{
  "polished": {
    "finalDocument": "# –î–û–ì–û–í–Ü–†\\n\\n–ü–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç –¥–æ–≥–æ–≤–æ—Ä—É —Ç—É—Ç...",
    "improvements": [
      {
        "type": "grammar",
        "before": "–°—Ç–∞—Ä–∏–π —Ç–µ–∫—Å—Ç",
        "after": "–ù–æ–≤–∏–π —Ç–µ–∫—Å—Ç",
        "rationale": "–ß–æ–º—É –∑–º—ñ–Ω–µ–Ω–æ"
      }
    ],
    "executiveSummary": "–°—Ç–≤–æ—Ä–µ–Ω–æ –¥–æ–≥–æ–≤—ñ—Ä –∫—É–ø—ñ–≤–ª—ñ-–ø—Ä–æ–¥–∞–∂—É –∞–≤—Ç–æ–º–æ–±—ñ–ª—è –º—ñ–∂ –§–û–ü –ü–µ—Ç—Ä–µ–Ω–∫–æ —Ç–∞ –Ü–≤–∞–Ω–µ–Ω–∫–æ–º...",
    "keyTerms": [
      {
        "term": "–ü—Ä–µ–¥–º–µ—Ç –¥–æ–≥–æ–≤–æ—Ä—É",
        "definition": "–ê–≤—Ç–æ–º–æ–±—ñ–ª—å Toyota Camry",
        "section": "–†–æ–∑–¥—ñ–ª 1"
      }
    ]
  },
  "confidence": 0.95
}

‚ö†Ô∏è JSON FORMATTING RULES:
- NEVER use unescaped quotes inside strings
- Use \\n for newlines in finalDocument string
- Replace all Ukrainian apostrophes with standard quotes
- Keep JSON parseable
- NO trailing commas before closing } or ]
- Example CORRECT: "keyTerms": [...] }
- Example WRONG: "keyTerms": [...], }

REQUIRED OUTPUT STRUCTURE:
{
  "polished": {
    "finalDocument": "STRING - complete document",  ‚Üê MUST BE THIS NAME!
    "improvements": [...],
    "executiveSummary": "STRING",
    "keyTerms": [...]
  },
  "confidence": NUMBER
}

POLISHING METHODOLOGY:
1. Fix ALL issues flagged by Validator
2. Ensure perfect Ukrainian grammar and spelling
3. Verify –î–°–¢–£ 4163-2020 compliance
4. Enhance legal precision
5. Ensure consistency throughout

**üá∫üá¶ –ú–û–í–ê: –í–°–Ø –í–Ü–î–ü–û–í–Ü–î–¨ –£–ö–†–ê–á–ù–°–¨–ö–û–Æ**

CRITICAL REMINDERS:
- Field name is "finalDocument" - NOT "finalDocumentText"
- Field name is "finalDocument" - NOT "documentText"  
- Field name is "finalDocument" - NOT anything else
- Wrap everything in "polished" object
- NO unescaped quotes in JSON strings`;

// ==========================================
// DYNAMIC PROMPT BUILDERS
// ==========================================

export async function buildAnalyzerPrompt(documentType?: string): Promise<string> {
  let prompt = ANALYZER_PROMPT_BASE;
  
  // Add Ukrainian law references
  prompt += `\n\n–£–ö–†–ê–á–ù–°–¨–ö–ï –ó–ê–ö–û–ù–û–î–ê–í–°–¢–í–û:\n`;
  const laws = ukrainianLawService.getAllLaws();
  for (const [code, law] of Object.entries(laws)) {
    prompt += `- ${law.fullName} (${law.code})\n`;
  }
  
  // Add –î–°–¢–£ standard structure
  prompt += `\n\n–û–ë–û–í'–Ø–ó–ö–û–í–Ü –†–û–ó–î–Ü–õ–ò (–î–°–¢–£ 4163-2020):\n`;
  DSTU_STRUCTURE.sections.forEach(section => {
    prompt += `${section}\n`;
  });
  
  return prompt;
}

export async function buildDrafterPrompt(documentType?: string): Promise<string> {
  let prompt = DRAFTER_PROMPT_BASE;
  
  // Add –î–°–¢–£ standard structure
  prompt += `\n\n–°–¢–ê–ù–î–ê–†–¢–ù–Ü –†–û–ó–î–Ü–õ–ò (–î–°–¢–£ 4163-2020):\n`;
  DSTU_STRUCTURE.sections.forEach(section => {
    prompt += `${section}\n`;
  });
  
  return prompt;
}

export async function buildValidatorPrompt(documentType?: string): Promise<string> {
  return VALIDATOR_PROMPT_BASE;
}

export async function buildPolisherPrompt(documentType?: string): Promise<string> {
  return POLISHER_PROMPT_BASE;
}

// Backward compatibility
export async function buildGenerationValidatorPrompt(documentType?: string): Promise<string> {
  return buildValidatorPrompt(documentType);
}


================================================================================
4. REVIEW TYPES
================================================================================
FILE: packages/legal-council/types/review-types.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Contract Review Types
 * Specific to the Review Tab workflow
 */

import { BaseAgentOutput } from '../../core/orchestrator/types';

// ==========================================
// INPUT TYPES
// ==========================================

export interface ContractReviewRequest {
  contractText: string;
  contractType?: ContractType;
  jurisdiction?: string;
  specificQuestions?: string[];
  focusAreas?: FocusArea[];
}

export type ContractType =
  | 'employment'
  | 'vendor'
  | 'saas'
  | 'nda'
  | 'consulting'
  | 'partnership'
  | 'custom';

export type FocusArea =
  | 'termination'
  | 'liability'
  | 'payment'
  | 'ip_rights'
  | 'confidentiality'
  | 'warranties'
  | 'dispute_resolution';

// ==========================================
// AGENT OUTPUTS (Review-specific)
// ==========================================

export interface ExpertOutput extends BaseAgentOutput {
  role: 'expert';
  analysis: {
    executiveSummary: string;
    keyIssues: Issue[];
    clauseAnalysis: ClauseAnalysis[];
    overallRiskScore: number; // 1-10
    recommendations: Recommendation[];
  };
}

export interface ProvocateurOutput extends BaseAgentOutput {
  role: 'provocateur';
  critique: {
    flaws: Flaw[];
    maxSeverity: number; // Highest flaw severity
    exploitationScenarios: string[];
  };
}

export interface ValidatorOutput extends BaseAgentOutput {
  role: 'validator';
  validation: {
    isComplete: boolean;
    completenessScore: number; // 0-100
    missingAspects: string[];
    contradictions: Contradiction[];
    verdict: 'COMPLETE' | 'NEEDS_REVISION';
  };
}

export interface SynthesizerOutput extends BaseAgentOutput {
  role: 'synthesizer';
  synthesis: {
    summary: string;
    criticalRisks: CriticalRisk[];
    recommendations: Recommendation[];
    confidence: number;
    keyDisagreements: string[];
  };
}

// ==========================================
// DOMAIN OBJECTS
// ==========================================

export interface Issue {
  id: string;
  title: string;
  description: string;
  severity: Severity;
  clauseReference?: string;
  category: IssueCategory;
  legalBasis?: string;
}

export type Severity = 1 | 2 | 3 | 4 | 5; // 5 = critical

export type IssueCategory =
  | 'ambiguous_language'
  | 'missing_protection'
  | 'liability_gap'
  | 'unfavorable_terms'
  | 'compliance_risk'
  | 'termination_risk';

export interface ClauseAnalysis {
  sectionNumber: string;
  title: string;
  content: string;
  assessment: 'favorable' | 'neutral' | 'unfavorable' | 'critical';
  issues: string[];
  recommendations: string[];
}

export interface Flaw {
  id: string;
  severity: Severity;
  clauseReference: string;
  issue: string;
  exploitationScenario: string;
  suggestedFix: string;
}

export interface Contradiction {
  source1: string; // e.g., "Expert"
  source2: string; // e.g., "Provocateur"
  subject: string;
  description: string;
}

export interface Recommendation {
  priority: 'high' | 'medium' | 'low';
  action: string;
  rationale: string;
  specificLanguage?: string; // Suggested clause text
}

export interface CriticalRisk {
  title: string;
  description: string;
  impact: string;
  mitigation: string;
}

// ==========================================
// FINAL OUTPUT
// ==========================================

export interface ContractReviewResponse {
  summary: string;
  overallRiskScore: number; // 1-10
  confidence: number; // 0-1
  
  criticalRisks: CriticalRisk[];
  recommendations: Recommendation[];
  
  detailedAnalysis: {
    expertAnalysis: ExpertOutput['analysis'];
    flawsFound: Flaw[];
    validationResults: ValidatorOutput['validation'];
  };
  
  metadata: {
    contractType: ContractType;
    jurisdiction?: string;
    analyzedAt: string;
    totalCost: number;
    processingTimeMs: number;
  };
}

// ==========================================
// HELPER FUNCTIONS
// ==========================================

export function getSeverityLabel(severity: Severity): string {
  const labels = {
    1: 'Minor',
    2: 'Low',
    3: 'Moderate',
    4: 'High',
    5: 'Critical',
  };
  return labels[severity];
}

export function getRiskColor(score: number): string {
  if (score >= 8) return 'red';
  if (score >= 6) return 'orange';
  if (score >= 4) return 'yellow';
  return 'green';
}


================================================================================
5. GENERATION TYPES
================================================================================
FILE: packages/legal-council/types/generation-types.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Document Generation Types
 * Specific to the Generation Tab workflow
 */

import { BaseAgentOutput } from '../../core/orchestrator/types';

// ==========================================
// INPUT TYPES
// ==========================================

export interface DocumentGenerationRequest {
  documentType: DocumentType;
  requirements: string; // User's natural language requirements
  jurisdiction?: string;
  parties?: PartyInfo[];
  specificClauses?: ClauseRequest[];
  template?: 'standard' | 'pro-client' | 'balanced' | 'custom';
}

export type DocumentType =
  | 'nda'
  | 'employment_agreement'
  | 'consulting_agreement'
  | 'saas_agreement'
  | 'vendor_contract'
  | 'partnership_agreement'
  | 'amendment'
  | 'custom_clause';

export interface PartyInfo {
  role: 'party_a' | 'party_b' | 'employer' | 'employee' | 'vendor' | 'client';
  name?: string;
  jurisdiction?: string;
  entityType?: 'individual' | 'corporation' | 'llc' | 'partnership';
}

export interface ClauseRequest {
  type: ClauseType;
  requirements: string;
  priority: 'must-have' | 'nice-to-have';
}

export type ClauseType =
  | 'termination'
  | 'liability'
  | 'indemnification'
  | 'confidentiality'
  | 'ip_assignment'
  | 'payment_terms'
  | 'dispute_resolution'
  | 'force_majeure'
  | 'warranties'
  | 'custom';

// ==========================================
// AGENT OUTPUTS (Generation-specific)
// ==========================================

export interface AnalyzerOutput extends BaseAgentOutput {
  role: 'analyzer';
  analysis: {
    structuredRequirements: StructuredRequirements;
    suggestedClauses: SuggestedClause[];
    potentialIssues: string[];
    clarificationsNeeded: string[];
  };
}

export interface DrafterOutput extends BaseAgentOutput {
  role: 'drafter';
  draft: {
    documentText: string; // Full contract text
    structure: DocumentStructure;
    includedClauses: GeneratedClause[];
    notes: string[];
  };
}

export interface GenerationValidatorOutput extends BaseAgentOutput {
  role: 'validator';
  validation: {
    legalCompliance: ComplianceCheck[];
    missingElements: string[];
    riskFlags: RiskFlag[];
    overallScore: number; // 0-100
    verdict: 'APPROVED' | 'NEEDS_REVISION';
  };
}

export interface PolisherOutput extends BaseAgentOutput {
  role: 'polisher';
  polished: {
    finalDocument: string;
    improvements: Improvement[];
    executiveSummary: string;
    keyTerms: KeyTerm[];
  };
}

// ==========================================
// DOMAIN OBJECTS
// ==========================================

export interface StructuredRequirements {
  documentType: DocumentType;
  parties: PartyInfo[];
  keyTerms: {
    duration?: string;
    paymentAmount?: string;
    deliverables?: string[];
    effectiveDate?: string;
  };
  mustHaveClauses: ClauseType[];
  jurisdiction: string;
  specialProvisions: string[];
}

export interface SuggestedClause {
  type: ClauseType;
  rationale: string;
  priority: 'essential' | 'recommended' | 'optional';
  standardText?: string;
}

export interface GeneratedClause {
  type: ClauseType;
  sectionNumber: string;
  title: string;
  text: string;
  alternatives?: string[]; // Alternative phrasings
}

export interface DocumentStructure {
  title: string;
  preamble: string;
  definitions: { term: string; definition: string }[];
  mainClauses: { section: string; title: string; subsections: number }[];
  signatures: { party: string; signatureLine: string }[];
}

export interface ComplianceCheck {
  requirement: string; // e.g., "Must include governing law clause"
  status: 'met' | 'not_met' | 'partial';
  details: string;
}

export interface RiskFlag {
  severity: 1 | 2 | 3 | 4 | 5;
  issue: string;
  location: string; // Clause reference
  recommendation: string;
}

export interface Improvement {
  type: 'clarity' | 'legal_precision' | 'formatting' | 'tone';
  before: string;
  after: string;
  rationale: string;
}

export interface KeyTerm {
  term: string;
  definition: string;
  importance: 'high' | 'medium' | 'low';
}

// ==========================================
// FINAL OUTPUT
// ==========================================

export interface DocumentGenerationResponse {
  finalDocument: string;
  format: 'markdown' | 'docx' | 'pdf';
  
  metadata: {
    documentType: DocumentType;
    generatedAt: string;
    jurisdiction?: string;
    confidence: number;
    totalCost: number;
    processingTimeMs: number;
  };
  
  summary: {
    executiveSummary: string;
    keyTerms: KeyTerm[];
    includedClauses: string[]; // List of clause types included
  };
  
  qualityMetrics: {
    complianceScore: number; // 0-100
    legalSoundness: number; // 0-100
    clarity: number; // 0-100
    overall: number; // 0-100
  };
  
  recommendations: {
    beforeSigning: string[];
    customizations: string[];
    reviewAreas: string[];
  };
}

// ==========================================
// TEMPLATES
// ==========================================

export interface ClauseTemplate {
  type: ClauseType;
  jurisdiction: string;
  template: 'standard' | 'pro-client' | 'balanced';
  text: string;
  variables: string[]; // e.g., ["{PARTY_A}", "{AMOUNT}"]
}

// Common templates
export const COMMON_CLAUSES: Record<ClauseType, string> = {
  termination: `Either party may terminate this Agreement upon [NOTICE_PERIOD] written notice to the other party.`,
  
  liability: `IN NO EVENT SHALL EITHER PARTY BE LIABLE FOR ANY INDIRECT, INCIDENTAL, SPECIAL, CONSEQUENTIAL OR PUNITIVE DAMAGES.`,
  
  confidentiality: `The Receiving Party shall hold and maintain the Confidential Information in strictest confidence.`,
  
  // ... (more would be defined in production)
} as any;

// ==========================================
// HELPER FUNCTIONS
// ==========================================

export function getDocumentTypeLabel(type: DocumentType): string {
  const labels: Record<DocumentType, string> = {
    nda: 'Non-Disclosure Agreement',
    employment_agreement: 'Employment Agreement',
    consulting_agreement: 'Consulting Agreement',
    saas_agreement: 'SaaS Agreement',
    vendor_contract: 'Vendor Contract',
    partnership_agreement: 'Partnership Agreement',
    amendment: 'Contract Amendment',
    custom_clause: 'Custom Clause',
  };
  return labels[type];
}

export function formatDocumentForDownload(text: string, format: 'markdown' | 'docx' | 'pdf'): string {
  // In production, this would actually convert formats
  // For now, just return markdown
  return text;
}


================================================================================
6. CORE TYPES (FIXED)
================================================================================
FILE: packages/core/orchestrator/types.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Core Types for Legal Council Orchestration
 * Shared between Review and Generation workflows
 */

// ==========================================
// AGENT TYPES
// ==========================================

export type AgentRole = 
  // Review agents
  | 'expert' 
  | 'provocateur' 
  | 'validator' 
  | 'synthesizer'
  // Generation agents
  | 'analyzer'
  | 'drafter'
  | 'polisher';

export type ModelProvider = 'anthropic' | 'openai' | 'google';

export interface AgentConfig {
  id: string;
  role: AgentRole;
  model: string;
  provider: ModelProvider;
  priority: number;
  temperature: number;
  maxTokens: number;
}

// ==========================================
// AGENT OUTPUTS
// ==========================================

export interface BaseAgentOutput {
  agentId: string;
  role: AgentRole;
  confidence: number; // 0-1
  timestamp: string;
  tokensUsed: {
    input: number;
    output: number;
  };
  latencyMs: number;
}

export interface AgentError {
  agentId: string;
  error: string;
  timestamp: string;
  retryable: boolean;
}

// ==========================================
// ORCHESTRATOR TYPES
// ==========================================

export interface StopCriteria {
  maxRounds: number;
  maxSeverity: number; // 1-5 scale
  minConfidence: number; // 0-1
  convergenceThreshold: number; // Delta between rounds
}

export interface OrchestratorConfig {
  agents: AgentConfig[];
  stopCriteria: StopCriteria;
  conflictResolution: 'priority' | 'weighted' | 'voting';
  enableAuditTrail: boolean;
}

export interface Round {
  roundNumber: number;
  outputs: BaseAgentOutput[];
  conflicts: Conflict[];
  convergence: number;
  shouldContinue: boolean;
}

export interface Conflict {
  agentA: string;
  agentB: string;
  issue: string;
  severity: number;
  resolution: string;
}

// ==========================================
// FINAL RESPONSE
// ==========================================

export interface CouncilResponse<T = any> {
  finalOutput: T;
  confidence: number;
  totalRounds: number;
  totalCost: number;
  totalLatencyMs: number;
  auditTrail: AuditTrail;
  metadata: {
    stopReason: 'max_rounds' | 'consensus' | 'high_confidence' | 'convergence';
    model: string;
  };
}

export interface AuditTrail {
  rounds: Round[];
  allOutputs: BaseAgentOutput[];
  conflicts: Conflict[];
  decisions: Decision[];
}

export interface Decision {
  timestamp: string;
  type: 'continue_round' | 'stop' | 'conflict_resolution';
  reason: string;
  data: any;
}

// ==========================================
// COST TRACKING
// ==========================================

export interface CostCalculation {
  inputTokens: number;
  outputTokens: number;
  inputCost: number;
  outputCost: number;
  totalCost: number;
  model: string;
}

export const MODEL_PRICING: Record<string, { input: number; output: number }> = {
  // Anthropic (per 1M tokens)
  'claude-opus-4-5-20251101': { input: 15, output: 75 },
  'claude-sonnet-4-5-20250929': { input: 3, output: 15 },
  
  // OpenAI (per 1M tokens)
  'gpt-4-turbo-2024-04-09': { input: 10, output: 30 },
  'gpt-4o': { input: 5, output: 15 },
  'gpt-4o-mini': { input: 0.15, output: 0.60 },  // Add this if missing

  
  // Google (per 1M tokens) - FREE tier
  'gemini-2.5-flash-lite': { input: 0, output: 0 },  // ‚úÖ ADD THIS LINE
  'gemini-1.5-flash': { input: 0, output: 0 },
  'gemini-2.0-flash-thinking-exp-01-21': { input: 0, output: 0 },
};

export function calculateCost(
  model: string,
  inputTokens: number,
  outputTokens: number
): CostCalculation {
  const pricing = MODEL_PRICING[model] || { input: 0, output: 0 };
  
  const inputCost = (inputTokens / 1_000_000) * pricing.input;
  const outputCost = (outputTokens / 1_000_000) * pricing.output;
  
  return {
    inputTokens,
    outputTokens,
    inputCost,
    outputCost,
    totalCost: inputCost + outputCost,
    model,
  };
}


================================================================================
7. BASE AGENT
================================================================================
FILE: packages/legal-council/agents/base-agent.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Base Agent - Foundation for all Legal Council agents
 * 
 * FIXES (Feb 10, 2026):
 * - Improved JSON parsing with multiple strategies
 * - Detailed error logging to debug undefined outputs
 * - Better handling of LLM responses with extra text
 */

import Anthropic from '@anthropic-ai/sdk';
import OpenAI from 'openai';
import { GoogleGenerativeAI } from '@google/generative-ai';
import type { AgentConfig, BaseAgentOutput } from '../../core/orchestrator/types';
import { calculateCost } from '../../core/orchestrator/types';

// Singleton instances
let anthropicClient: Anthropic | null = null;
let openaiClient: OpenAI | null = null;
let googleClient: GoogleGenerativeAI | null = null;

function getAnthropicClient(): Anthropic {
  if (!anthropicClient) {
    const apiKey = process.env.ANTHROPIC_API_KEY;
    if (!apiKey) {
      throw new Error('ANTHROPIC_API_KEY not found in environment variables');
    }
    anthropicClient = new Anthropic({ apiKey });
  }
  return anthropicClient;
}

function getOpenAIClient(): OpenAI {
  if (!openaiClient) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY not found in environment variables');
    }
    openaiClient = new OpenAI({ apiKey });
  }
  return openaiClient;
}

function getGoogleClient(): GoogleGenerativeAI {
  if (!googleClient) {
    const apiKey = process.env.GOOGLE_API_KEY;
    if (!apiKey) {
      throw new Error('GOOGLE_API_KEY not found in environment variables');
    }
    googleClient = new GoogleGenerativeAI(apiKey);
  }
  return googleClient;
}

// ==========================================
// BASE AGENT
// ==========================================

export abstract class BaseAgent<TOutput extends BaseAgentOutput = BaseAgentOutput> {
  protected config: AgentConfig;
  protected systemPrompt: string;

  constructor(config: AgentConfig, systemPrompt: string) {
    this.config = config;
    this.systemPrompt = systemPrompt;
  }

  /**
   * Main method to call LLM and get response
   */
  async call(userPrompt: string): Promise<TOutput> {
    const startTime = Date.now();

    try {
      let response: string;
      let tokensUsed: { input: number; output: number };

      // Route to appropriate provider
      switch (this.config.provider) {
        case 'anthropic':
          ({ response, tokensUsed } = await this.callAnthropic(userPrompt));
          break;
        case 'openai':
          ({ response, tokensUsed } = await this.callOpenAI(userPrompt));
          break;
        case 'google':
          ({ response, tokensUsed } = await this.callGoogle(userPrompt));
          break;
        default:
          throw new Error(`Unknown provider: ${this.config.provider}`);
      }

      const latencyMs = Date.now() - startTime;

      // Log raw response for debugging
      console.log(`\nüîç [${this.config.id}] Raw LLM Response (first 500 chars):`);
      console.log(response.substring(0, 500));
      console.log(`... (total length: ${response.length} chars)\n`);

      // Parse JSON response with improved error handling
      const parsed = this.parseResponse(response);

      // Build base output
      const baseOutput: BaseAgentOutput = {
        agentId: this.config.id,
        role: this.config.role,
        confidence: parsed.confidence || 0.8, // Default if not specified
        timestamp: new Date().toISOString(),
        tokensUsed,
        latencyMs,
      };

      // Merge with parsed data
      return { ...baseOutput, ...parsed } as TOutput;
    } catch (error) {
      console.error(`‚ùå Agent ${this.config.id} failed:`, error);
      throw error;
    }
  }

  /**
   * Call Anthropic API (Claude) with retry logic for network errors
   */
  private async callAnthropic(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = getAnthropicClient();
    
    // Retry logic for network errors
    const maxRetries = 3;
    let lastError: any;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const message = await client.messages.create({
          model: this.config.model,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature,
          system: this.systemPrompt,
          messages: [
            {
              role: 'user',
              content: userPrompt,
            },
          ],
        });

        // Extract text from response
        const textContent = message.content.find((c) => c.type === 'text');
        if (!textContent || textContent.type !== 'text') {
          throw new Error('No text content in Anthropic response');
        }

        return {
          response: textContent.text,
          tokensUsed: {
            input: message.usage.input_tokens,
            output: message.usage.output_tokens,
          },
        };
        
      } catch (error: any) {
        lastError = error;
        
        // Check if it's a network error that we should retry
        const isNetworkError = 
          error.code === 'EAI_AGAIN' ||
          error.code === 'ENOTFOUND' ||
          error.code === 'ETIMEDOUT' ||
          error.code === 'ECONNRESET' ||
          error.message?.includes('Connection error') ||
          error.message?.includes('network');
        
        // Don't retry on API errors (invalid key, rate limit, etc)
        if (!isNetworkError) {
          throw error;
        }
        
        // If this was the last attempt, throw
        if (attempt === maxRetries) {
          console.error(`‚ùå [${this.config.id}] All ${maxRetries} attempts failed with network error`);
          throw error;
        }
        
        // Wait before retry (exponential backoff)
        const delayMs = 1000 * Math.pow(2, attempt - 1);
        console.log(`‚ö†Ô∏è [${this.config.id}] Network error on attempt ${attempt}/${maxRetries}. Retrying in ${delayMs}ms...`);
        console.log(`   Error: ${error.code} - ${error.message}`);
        
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
    
    throw lastError;
  }

  /**
   * Call OpenAI API (GPT-4) with retry logic for network errors
   */
  private async callOpenAI(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = getOpenAIClient();
    
    // Retry logic for network errors
    const maxRetries = 3;
    let lastError: any;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        const completion = await client.chat.completions.create({
          model: this.config.model,
          max_tokens: this.config.maxTokens,
          temperature: this.config.temperature,
          messages: [
            {
              role: 'system',
              content: this.systemPrompt,
            },
            {
              role: 'user',
              content: userPrompt,
            },
          ],
        });

        const choice = completion.choices[0];
        if (!choice || !choice.message || !choice.message.content) {
          throw new Error('No content in OpenAI response');
        }

        return {
          response: choice.message.content,
          tokensUsed: {
            input: completion.usage?.prompt_tokens || 0,
            output: completion.usage?.completion_tokens || 0,
          },
        };
        
      } catch (error: any) {
        lastError = error;
        
        const isNetworkError = 
          error.code === 'EAI_AGAIN' ||
          error.code === 'ENOTFOUND' ||
          error.code === 'ETIMEDOUT' ||
          error.code === 'ECONNRESET' ||
          error.message?.includes('Connection error') ||
          error.message?.includes('network');
        
        if (!isNetworkError || attempt === maxRetries) {
          throw error;
        }
        
        const delayMs = 1000 * Math.pow(2, attempt - 1);
        console.log(`‚ö†Ô∏è [${this.config.id}] Network error on attempt ${attempt}/${maxRetries}. Retrying in ${delayMs}ms...`);
        await new Promise(resolve => setTimeout(resolve, delayMs));
      }
    }
    
    throw lastError;
  }

  /**
   * Call Google Gemini API
   */
  private async callGoogle(userPrompt: string): Promise<{
    response: string;
    tokensUsed: { input: number; output: number };
  }> {
    const client = getGoogleClient();
    const model = client.getGenerativeModel({ model: this.config.model });

    const fullPrompt = `${this.systemPrompt}\n\n${userPrompt}`;
    const result = await model.generateContent(fullPrompt);
    const response = result.response.text();

    // Google doesn't provide token counts, estimate
    const estimatedInputTokens = Math.ceil(fullPrompt.length / 4);
    const estimatedOutputTokens = Math.ceil(response.length / 4);

    return {
      response,
      tokensUsed: {
        input: estimatedInputTokens,
        output: estimatedOutputTokens,
      },
    };
  }

  /**
   * Parse JSON response with multiple strategies and detailed error logging
   */
  protected parseResponse(response: string): any {
    const originalResponse = response; // Save for error logging

    try {
      // Strategy 1: Clean up markdown fences
      let cleaned = response.trim();

      // Remove ```json and ``` if present
      if (cleaned.startsWith('```json')) {
        cleaned = cleaned.replace(/^```json\s*/, '').replace(/```\s*$/, '');
      } else if (cleaned.startsWith('```')) {
        cleaned = cleaned.replace(/^```\s*/, '').replace(/```\s*$/, '');
      }

      // Strategy 2: Try to find JSON object in the response
      // Look for first { and last }
      const firstBrace = cleaned.indexOf('{');
      const lastBrace = cleaned.lastIndexOf('}');

      if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
        cleaned = cleaned.substring(firstBrace, lastBrace + 1);
      }

      // Attempt to parse
      const parsed = JSON.parse(cleaned);
      
      console.log(`‚úÖ [${this.config.id}] Successfully parsed JSON`);
      return parsed;

    } catch (error) {
      // Detailed error logging
      console.error(`\n‚ùå [${this.config.id}] JSON Parsing Failed!`);
      console.error(`\nüìÑ Original Response (full):`);
      console.error(originalResponse);
      console.error(`\nüîç Response Length: ${originalResponse.length} characters`);
      console.error(`\n‚ö†Ô∏è Parse Error:`, error);
      console.error(`\nüí° First 200 chars: ${originalResponse.substring(0, 200)}`);
      console.error(`\nüí° Last 200 chars: ${originalResponse.substring(Math.max(0, originalResponse.length - 200))}`);
      
      // Check for common issues
      if (!originalResponse.includes('{')) {
        console.error(`\nüö® Response does not contain any '{' character - not JSON!`);
      }
      if (originalResponse.includes('I\'m sorry') || originalResponse.includes('I cannot')) {
        console.error(`\nüö® LLM appears to have refused the request!`);
      }

      throw new Error(`Invalid JSON response from ${this.config.id}: ${error}\nSee console for full response.`);
    }
  }

  /**
   * Calculate cost for this agent call
   */
  calculateCost(tokensUsed: { input: number; output: number }): number {
    const costCalc = calculateCost(
      this.config.model,
      tokensUsed.input,
      tokensUsed.output
    );
    return costCalc.totalCost;
  }

  /**
   * Log agent activity (for debugging)
   */
  protected log(message: string, data?: any): void {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${this.config.id}] ${message}`, data || '');
  }
}

// ==========================================
// ERROR HANDLING
// ==========================================

export class AgentError extends Error {
  constructor(
    public agentId: string,
    public originalError: Error,
    public retryable: boolean = true
  ) {
    super(`Agent ${agentId} failed: ${originalError.message}`);
    this.name = 'AgentError';
  }
}

/**
 * Retry wrapper with exponential backoff
 */
export async function withRetry<T>(
  fn: () => Promise<T>,
  maxRetries: number = 3,
  baseDelay: number = 1000
): Promise<T> {
  let lastError: Error;

  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error as Error;

      // Don't retry on certain errors
      if (
        error instanceof Error &&
        (error.message.includes('Invalid API key') ||
          error.message.includes('not found'))
      ) {
        throw error;
      }

      if (i < maxRetries - 1) {
        const delay = baseDelay * Math.pow(2, i);
        console.log(`Retry ${i + 1}/${maxRetries} after ${delay}ms...`);
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
  }

  throw lastError!;
}


================================================================================
8. EXPERT AGENT
================================================================================
FILE: packages/legal-council/agents/review/expert.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Expert Agent (Contract Review)
 * Comprehensive legal analysis of contracts
 * 
 * FIX (Feb 10, 2026): Validation expects flat structure from LLM
 */

import { BaseAgent } from '../base-agent';
import { buildExpertPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type { ExpertOutput, ContractReviewRequest } from '../../types/review-types';

export class ExpertAgent extends BaseAgent<ExpertOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const expertConfig = configs.find((c: any) => c.role === 'expert')!;

    // System prompt will be set dynamically based on contract type
    super(expertConfig, ''); // Empty for now, set in analyze()
  }

  /**
   * Analyze contract and return comprehensive expert opinion
   */
  async analyze(request: ContractReviewRequest): Promise<ExpertOutput> {
    // Build context-aware system prompt
    this.systemPrompt = await buildExpertPrompt(
      request.contractType,
      request.jurisdiction
    );

    // Build user prompt with all context
    const userPrompt = this.buildUserPrompt(request);

    // Call LLM
    const rawOutput = await this.call(userPrompt);

    // Transform flat structure to nested structure
    const output = this.transformOutput(rawOutput);

    // Validate output structure
    this.validateOutput(output);

    return output;
  }

  /**
   * Build comprehensive user prompt
   */
  private buildUserPrompt(request: ContractReviewRequest): string {
    let prompt = '# CONTRACT TO ANALYZE\n\n';
    prompt += '```\n';
    prompt += request.contractText;
    prompt += '\n```\n\n';

    // Add contract metadata
    prompt += '# CONTEXT\n\n';
    if (request.contractType) {
      prompt += `Contract Type: ${request.contractType}\n`;
    }
    if (request.jurisdiction) {
      prompt += `Jurisdiction: ${request.jurisdiction}\n`;
    }

    // Add specific questions if provided
    if (request.specificQuestions && request.specificQuestions.length > 0) {
      prompt += '\n# SPECIFIC QUESTIONS FROM CLIENT\n\n';
      request.specificQuestions.forEach((q: string, i: number) => {
        prompt += `${i + 1}. ${q}\n`;
      });
    }

    // Add focus areas if provided
    if (request.focusAreas && request.focusAreas.length > 0) {
      prompt += '\n# PRIORITY FOCUS AREAS\n\n';
      prompt += 'Pay special attention to:\n';
      request.focusAreas.forEach((area: any) => {
        prompt += `- ${area}\n`;
      });
    }

    prompt += '\n# YOUR TASK\n\n';
    prompt += 'Provide comprehensive analysis following the JSON structure specified in your system prompt.\n';
    prompt += 'Be thorough, specific, and reference exact clause numbers.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested ExpertOutput structure
   */
  private transformOutput(rawOutput: any): ExpertOutput {
    // LLM returns flat structure: { executiveSummary, keyIssues, ... }
    // We need nested: { analysis: { executiveSummary, keyIssues, ... } }
    
    return {
      ...rawOutput,
      analysis: {
        executiveSummary: rawOutput.executiveSummary,
        keyIssues: rawOutput.keyIssues,
        clauseAnalysis: rawOutput.clauseAnalysis,
        overallRiskScore: rawOutput.overallRiskScore,
        recommendations: rawOutput.recommendations,
      },
    } as ExpertOutput;
  }

  /**
   * Validate that output has required structure
   */
  private validateOutput(output: ExpertOutput): void {
    if (!output.analysis) {
      throw new Error('Expert output missing analysis object');
    }

    const required = [
      'executiveSummary',
      'keyIssues',
      'clauseAnalysis',
      'overallRiskScore',
      'recommendations',
    ];

    for (const field of required) {
      if (!(field in output.analysis)) {
        throw new Error(`Expert output missing required field: analysis.${field}`);
      }
    }

    // Validate risk score is in range
    if (
      output.analysis.overallRiskScore < 1 ||
      output.analysis.overallRiskScore > 10
    ) {
      console.warn(
        `‚ö†Ô∏è Expert risk score out of range: ${output.analysis.overallRiskScore}`
      );
    }

    // Validate issues have severity
    for (const issue of output.analysis.keyIssues) {
      if (!issue.severity || issue.severity < 1 || issue.severity > 5) {
        console.warn(`‚ö†Ô∏è Issue ${issue.id} has invalid severity: ${issue.severity}`);
      }
    }

    // Validate we have exactly 7 issues (as per optimized prompt)
    const issueCount = output.analysis.keyIssues.length;
    if (issueCount !== 7) {
      console.warn(`‚ö†Ô∏è Expert returned ${issueCount} issues, expected 7 (as per prompt optimization)`);
    }

    // Validate we don't have too many recommendations
    const recCount = output.analysis.recommendations.length;
    if (recCount > 4) {
      console.warn(`‚ö†Ô∏è Expert returned ${recCount} recommendations, max should be 4`);
    }
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

/**
 * Quick way to get expert analysis
 */
export async function getExpertAnalysis(
  contractText: string,
  options?: {
    contractType?: ContractReviewRequest['contractType'];
    jurisdiction?: string;
    questions?: string[];
    focusAreas?: ContractReviewRequest['focusAreas'];
  }
): Promise<ExpertOutput> {
  const expert = new ExpertAgent();

  const request: ContractReviewRequest = {
    contractText,
    contractType: options?.contractType,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    specificQuestions: options?.questions,
    focusAreas: options?.focusAreas,
  };

  return expert.analyze(request);
}


================================================================================
9. PROVOCATEUR AGENT
================================================================================
FILE: packages/legal-council/agents/review/provocateur.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Provocateur Agent (Contract Review)
 * Adversarial red-team critic - finds exploitable flaws
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 */

import { BaseAgent } from '../base-agent';
import { buildProvocateurPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type { ProvocateurOutput } from '../../types/review-types';
import type { ExpertOutput } from '../../types/review-types';

export class ProvocateurAgent extends BaseAgent<ProvocateurOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const provocateurConfig = configs.find((c) => c.role === 'provocateur')!;

    super(provocateurConfig, '');
  }

  /**
   * Critique contract and find exploitable flaws
   */
  async critique(
    contractText: string,
    expertAnalysis?: ExpertOutput
  ): Promise<ProvocateurOutput> {
    this.systemPrompt = await buildProvocateurPrompt();

    const userPrompt = this.buildUserPrompt(contractText, expertAnalysis);

    const rawOutput = await this.call(userPrompt);

    // Transform flat to nested structure
    const output = this.transformOutput(rawOutput);

    this.validateOutput(output);

    return output;
  }

  /**
   * Build adversarial user prompt
   */
  private buildUserPrompt(
    contractText: string,
    expertAnalysis?: ExpertOutput
  ): string {
    let prompt = '# CONTRACT TO ATTACK\n\n';
    prompt += '```\n';
    prompt += contractText;
    prompt += '\n```\n\n';

    if (expertAnalysis) {
      prompt += '# EXPERT ALREADY FOUND THESE ISSUES\n\n';
      prompt += `Expert identified ${expertAnalysis.analysis.keyIssues.length} issues:\n`;

      expertAnalysis.analysis.keyIssues.forEach((issue) => {
        prompt += `- ${issue.title} (severity ${issue.severity})\n`;
      });

      prompt += '\n**YOUR JOB: Find DIFFERENT flaws that Expert missed!**\n';
      prompt += 'Don\'t repeat what Expert found. Find NEW attack vectors.\n\n';
    }

    prompt += '# YOUR MISSION\n\n';
    prompt += 'You are opposing counsel. Find at least 3 critical flaws you can exploit.\n';
    prompt += 'Be ruthless. Be creative. This is war.\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested structure
   */
  private transformOutput(rawOutput: any): ProvocateurOutput {
    return {
      ...rawOutput,
      critique: {
        flaws: rawOutput.flaws,
        maxSeverity: rawOutput.maxSeverity,
        exploitationScenarios: rawOutput.exploitationScenarios,
      },
    } as ProvocateurOutput;
  }

  /**
   * Validate output structure
   */
  private validateOutput(output: ProvocateurOutput): void {
    if (!output.critique || !output.critique.flaws) {
      throw new Error('Provocateur output missing critique.flaws');
    }

    const flawCount = output.critique.flaws.length;

    if (flawCount < 3) {
      console.warn(
        `‚ö†Ô∏è Provocateur only found ${flawCount} flaws (expected ‚â•3). Prompt may need adjustment.`
      );
    }

    // Validate max severity
    if (
      output.critique.maxSeverity < 1 ||
      output.critique.maxSeverity > 5
    ) {
      console.warn(
        `‚ö†Ô∏è Provocateur maxSeverity out of range: ${output.critique.maxSeverity}`
      );
    }

    // Validate we don't have too many flaws (optimized prompt says max 7)
    if (flawCount > 7) {
      console.warn(`‚ö†Ô∏è Provocateur returned ${flawCount} flaws, max should be 7`);
    }
  }
}

/**
 * Quick way to get provocateur critique
 */
export async function getProvocateurCritique(
  contractText: string,
  expertAnalysis?: ExpertOutput
): Promise<ProvocateurOutput> {
  const provocateur = new ProvocateurAgent();
  return provocateur.critique(contractText, expertAnalysis);
}


================================================================================
10. VALIDATOR AGENT (REVIEW)
================================================================================
FILE: packages/legal-council/agents/review/validator.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Validator Agent (Contract Review)
 * Checks completeness and consistency of analysis
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 */

import { BaseAgent } from '../base-agent';
import { buildValidatorPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type {
  ValidatorOutput,
  ExpertOutput,
  ProvocateurOutput,
  ContractReviewRequest,
} from '../../types/review-types';

export class ValidatorAgent extends BaseAgent<ValidatorOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const validatorConfig = configs.find((c) => c.role === 'validator')!;

    super(validatorConfig, '');
  }

  /**
   * Validate completeness of Expert and Provocateur analysis
   */
  async validate(
    request: ContractReviewRequest,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput
  ): Promise<ValidatorOutput> {
    this.systemPrompt = await buildValidatorPrompt();

    const userPrompt = this.buildUserPrompt(request, expertOutput, provocateurOutput);

    const rawOutput = await this.call(userPrompt);

    // Transform flat to nested structure
    const output = this.transformOutput(rawOutput);

    this.validateOutput(output);

    return output;
  }

  /**
   * Build validation prompt with all inputs
   */
  private buildUserPrompt(
    request: ContractReviewRequest,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput
  ): string {
    let prompt = '# ORIGINAL CONTRACT\n\n';
    prompt += '```\n';
    prompt += request.contractText;
    prompt += '\n```\n\n';

    // User's original request
    prompt += '# USER\'S QUERY\n\n';
    if (request.specificQuestions && request.specificQuestions.length > 0) {
      prompt += 'Specific questions asked:\n';
      request.specificQuestions.forEach((q, i) => {
        prompt += `${i + 1}. ${q}\n`;
      });
    }

    if (request.focusAreas && request.focusAreas.length > 0) {
      prompt += '\nFocus areas requested:\n';
      request.focusAreas.forEach((area) => {
        prompt += `- ${area}\n`;
      });
    }

    if (
      (!request.specificQuestions || request.specificQuestions.length === 0) &&
      (!request.focusAreas || request.focusAreas.length === 0)
    ) {
      prompt += 'General contract review requested (all aspects).\n';
    }

    // Expert's analysis
    prompt += '\n# EXPERT\'S ANALYSIS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(expertOutput.analysis, null, 2);
    prompt += '\n```\n\n';

    // Provocateur's critique
    prompt += '# PROVOCATEUR\'S CRITIQUE\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(provocateurOutput.critique, null, 2);
    prompt += '\n```\n\n';

    // Validation task
    prompt += '# YOUR VALIDATION TASK\n\n';
    prompt += 'Check if Expert and Provocateur properly addressed ALL aspects:\n';
    prompt += '1. Did they cover everything the user asked about?\n';
    prompt += '2. Are there contradictions between Expert and Provocateur?\n';
    prompt += '3. Are standard clauses for this contract type reviewed?\n';
    prompt += '4. Are recommendations actionable?\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested structure
   */
  private transformOutput(rawOutput: any): ValidatorOutput {
    return {
      ...rawOutput,
      validation: {
        isComplete: rawOutput.isComplete,
        completenessScore: rawOutput.completenessScore,
        missingAspects: rawOutput.missingAspects,
        contradictions: rawOutput.contradictions,
        verdict: rawOutput.verdict,
        reason: rawOutput.reason,
      },
    } as ValidatorOutput;
  }

  /**
   * Validate output structure
   */
  private validateOutput(output: ValidatorOutput): void {
    const required = [
      'isComplete',
      'completenessScore',
      'missingAspects',
      'contradictions',
      'verdict',
    ];

    for (const field of required) {
      if (!(field in output.validation)) {
        throw new Error(`Validator output missing required field: validation.${field}`);
      }
    }

    // Validate score is in range
    if (
      output.validation.completenessScore < 0 ||
      output.validation.completenessScore > 100
    ) {
      console.warn(
        `‚ö†Ô∏è Validator completeness score out of range: ${output.validation.completenessScore}`
      );
    }

    // Validate verdict is valid
    const validVerdicts = ['COMPLETE', 'NEEDS_REVISION'];
    if (!validVerdicts.includes(output.validation.verdict)) {
      throw new Error(
        `Invalid verdict: ${output.validation.verdict}. Must be COMPLETE or NEEDS_REVISION`
      );
    }
  }

  /**
   * Check if validation passed (analysis is complete)
   */
  isPassed(output: ValidatorOutput): boolean {
    return output.validation.verdict === 'COMPLETE';
  }

  /**
   * Get critical missing aspects (if any)
   */
  getCriticalGaps(output: ValidatorOutput): string[] {
    if (output.validation.isComplete) {
      return [];
    }
    return output.validation.missingAspects;
  }

  /**
   * Get contradictions that need Synthesizer attention
   */
  getContradictions(output: ValidatorOutput): ValidatorOutput['validation']['contradictions'] {
    return output.validation.contradictions;
  }
}

/**
 * Quick way to validate analysis
 */
export async function validateAnalysis(
  request: ContractReviewRequest,
  expertOutput: ExpertOutput,
  provocateurOutput: ProvocateurOutput
): Promise<ValidatorOutput> {
  const validator = new ValidatorAgent();
  return validator.validate(request, expertOutput, provocateurOutput);
}


================================================================================
11. SYNTHESIZER AGENT
================================================================================
FILE: packages/legal-council/agents/review/synthesizer.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Synthesizer Agent (Contract Review)
 * Combines all council outputs into final executive summary
 * 
 * FIX (Feb 10, 2026): Transform flat LLM output to nested structure
 */

import { BaseAgent } from '../base-agent';
import { buildSynthesizerPrompt } from '../../config/review-prompts';
import { createReviewAgentConfigs } from '../../config/models';
import type {
  SynthesizerOutput,
  ExpertOutput,
  ProvocateurOutput,
  ValidatorOutput,
} from '../../types/review-types';

export class SynthesizerAgent extends BaseAgent<SynthesizerOutput> {
  constructor() {
    const configs = createReviewAgentConfigs();
    const synthesizerConfig = configs.find((c) => c.role === 'synthesizer')!;

    super(synthesizerConfig, '');
  }

  /**
   * Synthesize all council outputs into final answer
   */
  async synthesize(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput
  ): Promise<SynthesizerOutput> {
    this.systemPrompt = await buildSynthesizerPrompt();

    const userPrompt = this.buildUserPrompt(
      expertOutput,
      provocateurOutput,
      validatorOutput
    );

    const rawOutput = await this.call(userPrompt);

    // Transform flat to nested structure
    const output = this.transformOutput(rawOutput);

    this.validateOutput(output);

    return output;
  }

  /**
   * Build synthesis prompt with all council outputs
   */
  private buildUserPrompt(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput
  ): string {
    let prompt = '# AI COUNCIL OUTPUTS TO SYNTHESIZE\n\n';

    // Expert analysis
    prompt += '## EXPERT ANALYSIS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(expertOutput.analysis, null, 2);
    prompt += '\n```\n\n';
    prompt += `Expert Confidence: ${(expertOutput.confidence * 100).toFixed(0)}%\n\n`;

    // Provocateur critique
    prompt += '## PROVOCATEUR CRITIQUE (Red-Team)\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(provocateurOutput.critique, null, 2);
    prompt += '\n```\n\n';
    prompt += `Provocateur Confidence: ${(provocateurOutput.confidence * 100).toFixed(0)}%\n`;
    prompt += `Max Severity Found: ${provocateurOutput.critique.maxSeverity}/5\n\n`;

    // Validator results
    prompt += '## VALIDATOR ASSESSMENT\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(validatorOutput.validation, null, 2);
    prompt += '\n```\n\n';
    prompt += `Completeness: ${validatorOutput.validation.completenessScore}%\n`;
    prompt += `Verdict: ${validatorOutput.validation.verdict}\n\n`;

    // Synthesis instructions
    prompt += '# YOUR SYNTHESIS TASK\n\n';
    prompt += '1. **Prioritize by severity**: Lead with highest-risk issues\n';
    prompt += '2. **Resolve contradictions**: If Expert and Provocateur disagree, explain both views and make judgment\n';
    prompt += '3. **Consolidate duplicates**: Don\'t repeat same issue twice\n';
    prompt += '4. **Be actionable**: Every risk needs clear mitigation\n';
    prompt += '5. **Plain language**: Client-friendly, not overly technical\n';
    prompt += '6. **Balanced**: Honest about risks, but not alarmist\n';
    prompt += '\nIf Validator found contradictions, address them in keyDisagreements.\n';
    prompt += '\nOutput strict JSON format as specified in system prompt.\n';

    return prompt;
  }

  /**
   * Transform flat LLM output to nested structure
   */
  private transformOutput(rawOutput: any): SynthesizerOutput {
    return {
      ...rawOutput,
      synthesis: {
        summary: rawOutput.summary,
        criticalRisks: rawOutput.criticalRisks,
        recommendations: rawOutput.recommendations,
        confidence: rawOutput.confidence || rawOutput.synthesisConfidence || 0.8,
        keyDisagreements: rawOutput.keyDisagreements || [],
      },
    } as SynthesizerOutput;
  }

  /**
   * Validate output structure
   */
  private validateOutput(output: SynthesizerOutput): void {
    const required = ['summary', 'criticalRisks', 'recommendations', 'confidence'];

    for (const field of required) {
      if (!(field in output.synthesis)) {
        throw new Error(`Synthesizer output missing required field: synthesis.${field}`);
      }
    }

    // Validate confidence is in range
    if (
      output.synthesis.confidence < 0 ||
      output.synthesis.confidence > 1
    ) {
      console.warn(
        `‚ö†Ô∏è Synthesizer confidence out of range: ${output.synthesis.confidence}`
      );
    }

    // Validate we don't have too many risks/recommendations (optimized prompt says max 5 each)
    const riskCount = output.synthesis.criticalRisks.length;
    const recCount = output.synthesis.recommendations.length;

    if (riskCount > 5) {
      console.warn(`‚ö†Ô∏è Synthesizer returned ${riskCount} risks, max should be 5`);
    }

    if (recCount > 5) {
      console.warn(`‚ö†Ô∏è Synthesizer returned ${recCount} recommendations, max should be 5`);
    }
  }

  /**
   * Get high-priority action items for client
   */
  getActionItems(output: SynthesizerOutput) {
    return output.synthesis.recommendations
      .filter((rec) => rec.priority === 'high')
      .map((rec) => rec.action);
  }
}

/**
 * Quick way to synthesize council outputs
 */
export async function synthesizeAnalysis(
  expertOutput: ExpertOutput,
  provocateurOutput: ProvocateurOutput,
  validatorOutput: ValidatorOutput
): Promise<SynthesizerOutput> {
  const synthesizer = new SynthesizerAgent();
  return synthesizer.synthesize(expertOutput, provocateurOutput, validatorOutput);
}


================================================================================
12. ANALYZER AGENT
================================================================================
FILE: packages/legal-council/agents/generation/analyzer.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Analyzer Agent (Document Generation)
 * Parses user requirements into structured specifications
 */

import { BaseAgent } from '../base-agent';
import { buildAnalyzerPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  AnalyzerOutput,
  DocumentGenerationRequest,
} from '../../types/generation-types';

export class AnalyzerAgent extends BaseAgent<AnalyzerOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const analyzerConfig = configs.find((c) => c.role === 'analyzer')!;

    super(analyzerConfig, '');
  }

  /**
   * Analyze user requirements and structure them
   */
  async analyze(request: DocumentGenerationRequest): Promise<AnalyzerOutput> {
    this.systemPrompt = await buildAnalyzerPrompt(request.documentType);

    const userPrompt = this.buildUserPrompt(request);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(request: DocumentGenerationRequest): string {
    let prompt = '# USER REQUIREMENTS\n\n';
    prompt += request.requirements;
    prompt += '\n\n# DOCUMENT TYPE\n\n';
    prompt += `${request.documentType}\n\n`;

    if (request.jurisdiction) {
      prompt += `# JURISDICTION\n\n${request.jurisdiction}\n\n`;
    }

    if (request.parties && request.parties.length > 0) {
      prompt += '# PARTIES\n\n';
      request.parties.forEach((p) => {
        prompt += `- ${p.role}: ${p.name || '[to be filled]'}\n`;
      });
      prompt += '\n';
    }

    if (request.specificClauses && request.specificClauses.length > 0) {
      prompt += '# SPECIFIC CLAUSES REQUESTED\n\n';
      request.specificClauses.forEach((c) => {
        prompt += `- ${c.type} (${c.priority}): ${c.requirements}\n`;
      });
      prompt += '\n';
    }

    prompt += '# YOUR TASK\n\n';
    prompt += 'Parse these requirements into structured JSON format.\n';
    prompt += 'Make smart assumptions where info is missing.\n';
    prompt += 'Suggest additional clauses that are essential for this document type.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.analysis || !output.analysis.structuredRequirements) {
      throw new Error('Analyzer output missing structuredRequirements');
    }

    const req = output.analysis.structuredRequirements;
    if (!req.documentType || !req.parties || !req.mustHaveClauses) {
      console.warn('‚ö†Ô∏è Analyzer output missing key fields');
    }
  }
}

export async function analyzeRequirements(
  request: DocumentGenerationRequest
): Promise<AnalyzerOutput> {
  const analyzer = new AnalyzerAgent();
  return analyzer.analyze(request);
}


================================================================================
13. DRAFTER AGENT
================================================================================
FILE: packages/legal-council/agents/generation/drafter.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Drafter Agent (Document Generation)
 * Generates –î–°–¢–£-compliant Ukrainian contracts
 */

import { BaseAgent } from '../base-agent';
import { buildDrafterPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type { DrafterOutput, AnalyzerOutput, DocumentType } from '../../types/generation-types';

export class DrafterAgent extends BaseAgent<DrafterOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const drafterConfig = configs.find((c) => c.role === 'drafter')!;

    super(drafterConfig, '');
  }

  /**
   * Draft complete contract based on structured requirements
   */
  async draft(
    documentType: DocumentType,
    analyzerOutput: AnalyzerOutput
  ): Promise<DrafterOutput> {
    this.systemPrompt = await buildDrafterPrompt(documentType);

    const userPrompt = this.buildUserPrompt(analyzerOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(analyzerOutput: AnalyzerOutput): string {
    const req = analyzerOutput.analysis.structuredRequirements;

    let prompt = '# STRUCTURED REQUIREMENTS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(req, null, 2);
    prompt += '\n```\n\n';

    prompt += '# SUGGESTED CLAUSES\n\n';
    analyzerOutput.analysis.suggestedClauses.forEach((clause) => {
      prompt += `- ${clause.type} (${clause.priority}): ${clause.rationale}\n`;
    });

    prompt += '\n# YOUR TASK\n\n';
    prompt += 'Generate complete –î–°–¢–£-compliant contract in Ukrainian language.\n';
    prompt += 'Follow the EXACT structure from your system prompt.\n';
    prompt += 'Include all mandatory sections per Ukrainian law.\n';
    prompt += 'Output strict JSON with "documentText" field containing full Markdown contract.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.draft || !output.draft.documentText) {
      throw new Error('Drafter output missing documentText');
    }

    const text = output.draft.documentText;

    // Basic –î–°–¢–£ validation
    if (!text.includes('–î–û–ì–û–í–Ü–†')) {
      console.warn('‚ö†Ô∏è Contract missing "–î–û–ì–û–í–Ü–†" title');
    }

    if (!text.includes('–ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£')) {
      console.warn('‚ö†Ô∏è Contract missing mandatory section: –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£');
    }

    if (!text.includes('–ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù')) {
      console.warn('‚ö†Ô∏è Contract missing signature section');
    }
  }
}

export async function draftDocument(
  documentType: DocumentType,
  analyzerOutput: AnalyzerOutput
): Promise<DrafterOutput> {
  const drafter = new DrafterAgent();
  return drafter.draft(documentType, analyzerOutput);
}


================================================================================
14. VALIDATOR AGENT (GENERATION)
================================================================================
FILE: packages/legal-council/agents/generation/validator.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Generation Validator Agent
 * Checks legal compliance and –î–°–¢–£ standards of drafted document
 */

import { BaseAgent } from '../base-agent';
import { buildGenerationValidatorPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  GenerationValidatorOutput,
  DrafterOutput,
  AnalyzerOutput,
} from '../../types/generation-types';

export class GenerationValidatorAgent extends BaseAgent<GenerationValidatorOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const validatorConfig = configs.find((c) => c.role === 'validator')!;

    super(validatorConfig, '');
  }

  /**
   * Validate drafted document for legal compliance
   */
  async validate(
    analyzerOutput: AnalyzerOutput,
    drafterOutput: DrafterOutput
  ): Promise<GenerationValidatorOutput> {
    this.systemPrompt = await buildGenerationValidatorPrompt();

    const userPrompt = this.buildUserPrompt(analyzerOutput, drafterOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(
    analyzerOutput: AnalyzerOutput,
    drafterOutput: DrafterOutput
  ): string {
    let prompt = '# ORIGINAL REQUIREMENTS\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(analyzerOutput.analysis.structuredRequirements, null, 2);
    prompt += '\n```\n\n';

    prompt += '# DRAFTED DOCUMENT\n\n';
    prompt += '```\n';
    prompt += drafterOutput.draft.documentText;
    prompt += '\n```\n\n';

    prompt += '# YOUR VALIDATION TASK\n\n';
    prompt += 'Check this document against:\n';
    prompt += '1. Ukrainian law requirements (–¶–ö–£ —Å—Ç. 638)\n';
    prompt += '2. –î–°–¢–£ 4163-2020 structure\n';
    prompt += '3. Completeness (all required clauses present)\n';
    prompt += '4. Legal risks (ambiguous terms, liability gaps)\n';
    prompt += '\nOutput strict JSON with compliance checks and risk flags.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.validation || !output.validation.verdict) {
      throw new Error('Validator output missing verdict');
    }

    const validVerdicts = ['APPROVED', 'NEEDS_REVISION'];
    if (!validVerdicts.includes(output.validation.verdict)) {
      throw new Error(`Invalid verdict: ${output.validation.verdict}`);
    }
  }

  isPassed(output: GenerationValidatorOutput): boolean {
    return output.validation.verdict === 'APPROVED';
  }
}

export async function validateDocument(
  analyzerOutput: AnalyzerOutput,
  drafterOutput: DrafterOutput
): Promise<GenerationValidatorOutput> {
  const validator = new GenerationValidatorAgent();
  return validator.validate(analyzerOutput, drafterOutput);
}


================================================================================
15. POLISHER AGENT
================================================================================
FILE: packages/legal-council/agents/generation/polisher.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Polisher Agent (Document Generation)
 * Finalizes document with professional quality
 */

import { BaseAgent } from '../base-agent';
import { buildPolisherPrompt } from '../../config/generation-prompts';
import { createGenerationAgentConfigs } from '../../config/models';
import type {
  PolisherOutput,
  DrafterOutput,
  GenerationValidatorOutput,
  DocumentGenerationResponse,
} from '../../types/generation-types';

export class PolisherAgent extends BaseAgent<PolisherOutput> {
  constructor() {
    const configs = createGenerationAgentConfigs();
    const polisherConfig = configs.find((c) => c.role === 'polisher')!;

    super(polisherConfig, '');
  }

  /**
   * Polish draft into final executive-ready document
   */
  async polish(
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput
  ): Promise<PolisherOutput> {
    this.systemPrompt = await buildPolisherPrompt();

    const userPrompt = this.buildUserPrompt(drafterOutput, validatorOutput);
    const output = await this.call(userPrompt);

    this.validateOutput(output);
    return output;
  }

  private buildUserPrompt(
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput
  ): string {
    let prompt = '# DRAFT DOCUMENT\n\n';
    prompt += '```\n';
    prompt += drafterOutput.draft.documentText;
    prompt += '\n```\n\n';

    prompt += '# VALIDATOR FEEDBACK\n\n';
    prompt += '```json\n';
    prompt += JSON.stringify(validatorOutput.validation, null, 2);
    prompt += '\n```\n\n';

    if (validatorOutput.validation.riskFlags.length > 0) {
      prompt += '# ISSUES TO ADDRESS\n\n';
      validatorOutput.validation.riskFlags.forEach((flag) => {
        prompt += `- ${flag.issue} (severity ${flag.severity}): ${flag.recommendation}\n`;
      });
      prompt += '\n';
    }

    prompt += '# YOUR POLISHING TASK\n\n';
    prompt += '1. Fix any issues identified by Validator\n';
    prompt += '2. Improve clarity and readability\n';
    prompt += '3. Ensure consistency throughout\n';
    prompt += '4. Add executive summary for client\n';
    prompt += '\nOutput strict JSON with polished document and improvements made.\n';

    return prompt;
  }

  private validateOutput(output: any): void {
    if (!output.polished || !output.polished.finalDocument) {
      throw new Error('Polisher output missing finalDocument');
    }

    if (!output.polished.executiveSummary) {
      console.warn('‚ö†Ô∏è Polisher missing executive summary');
    }
  }

  buildFinalResponse(
    polisherOutput: PolisherOutput,
    analyzerOutput: any,
    drafterOutput: DrafterOutput,
    validatorOutput: GenerationValidatorOutput,
    metadata: {
      documentType: string;
      totalCost: number;
      processingTimeMs: number;
    }
  ): DocumentGenerationResponse {
    return {
      finalDocument: polisherOutput.polished.finalDocument,
      format: 'markdown',

      metadata: {
        documentType: metadata.documentType as any,
        generatedAt: new Date().toISOString(),
        jurisdiction: 'Ukraine',
        confidence: polisherOutput.confidence,
        totalCost: metadata.totalCost,
        processingTimeMs: metadata.processingTimeMs,
      },

      summary: {
        executiveSummary: polisherOutput.polished.executiveSummary,
        keyTerms: polisherOutput.polished.keyTerms,
        includedClauses: drafterOutput.draft.includedClauses.map((c) => c.type),
      },

      qualityMetrics: {
        complianceScore: validatorOutput.validation.overallScore,
        legalSoundness: validatorOutput.validation.overallScore,
        clarity: 85, // Could be calculated from polisher improvements
        overall: validatorOutput.validation.overallScore,
      },

      recommendations: {
        beforeSigning: [
          '–ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –≤—Å—ñ —Ä–µ–∫–≤—ñ–∑–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω –ø–µ—Ä–µ–¥ –ø—ñ–¥–ø–∏—Å–∞–Ω–Ω—è–º',
          '–ü–µ—Ä–µ–∫–æ–Ω–∞–π—Ç–µ—Å—è, —â–æ –≤—Å—ñ —Å—É–º–∏ —Ç–∞ –¥–∞—Ç–∏ –∑–∞–ø–æ–≤–Ω–µ–Ω—ñ –ø—Ä–∞–≤–∏–ª—å–Ω–æ',
          '–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É –Ω–∞ —Ä–æ–∑–¥—ñ–ª–∏ –ø—Ä–æ –≤—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å —Ç–∞ —Ä–æ–∑—ñ—Ä–≤–∞–Ω–Ω—è –¥–æ–≥–æ–≤–æ—Ä—É',
        ],
        customizations:
          polisherOutput.polished.improvements?.map((i) => i.rationale) || [],
        reviewAreas:
          validatorOutput.validation.riskFlags.map((f) => f.location) || [],
      },
    };
  }
}

export async function polishDocument(
  drafterOutput: DrafterOutput,
  validatorOutput: GenerationValidatorOutput
): Promise<PolisherOutput> {
  const polisher = new PolisherAgent();
  return polisher.polish(drafterOutput, validatorOutput);
}


================================================================================
16. REVIEW ORCHESTRATOR
================================================================================
FILE: packages/legal-council/orchestrators/review-orchestrator.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Review Orchestrator
 * Coordinates Expert ‚Üí Provocateur ‚Üí Validator ‚Üí Synthesizer
 * Implements tick-based cycle with stop criteria
 * 
 * FIX (Feb 11, 2026): buildFinalResponse moved to Orchestrator to avoid webpack cache issues
 */

import { ExpertAgent } from '../agents/review/expert';
import { ProvocateurAgent } from '../agents/review/provocateur';
import { ValidatorAgent } from '../agents/review/validator';
import { SynthesizerAgent } from '../agents/review/synthesizer';
import type {
  ContractReviewRequest,
  ContractReviewResponse,
  ExpertOutput,
  ProvocateurOutput,
  ValidatorOutput,
  SynthesizerOutput,
} from '../types/review-types';
import type { Round, AuditTrail } from '../../core/orchestrator/types';

export interface ReviewOrchestratorConfig {
  maxRounds: number; // Max iterations before forcing stop
  maxSeverityThreshold: number; // Stop if no issues >= this severity
  minConfidence: number; // Stop if all agents >= this confidence
  enableAuditTrail: boolean;
}

const DEFAULT_CONFIG: ReviewOrchestratorConfig = {
  maxRounds: 3,
  maxSeverityThreshold: 3, // Stop if no severity >= 3 issues remain
  minConfidence: 0.85,
  enableAuditTrail: true,
};

export class ReviewOrchestrator {
  private config: ReviewOrchestratorConfig;
  private expert: ExpertAgent;
  private provocateur: ProvocateurAgent;
  private validator: ValidatorAgent;
  private synthesizer: SynthesizerAgent;

  constructor(config: Partial<ReviewOrchestratorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };

    // Initialize agents
    this.expert = new ExpertAgent();
    this.provocateur = new ProvocateurAgent();
    this.validator = new ValidatorAgent();
    this.synthesizer = new SynthesizerAgent();
  }

  /**
   * Main orchestration method
   */
  async analyze(request: ContractReviewRequest): Promise<ContractReviewResponse> {
    const startTime = Date.now();
    const rounds: Round[] = [];
    let totalCost = 0;

    console.log('üõ°Ô∏è Legal Council Review Session Starting...');
    console.log(`   Max rounds: ${this.config.maxRounds}`);
    console.log(`   Stop criteria: severity < ${this.config.maxSeverityThreshold}, confidence > ${this.config.minConfidence}`);

    // Round 1: Initial analysis
    console.log('\nüìã Round 1: Expert Analysis');
    const expertOutput = await this.expert.analyze(request);
    totalCost += this.expert.calculateCost(expertOutput.tokensUsed);
    console.log(`   ‚úì Found ${expertOutput.analysis.keyIssues.length} issues`);
    console.log(`   ‚úì Risk score: ${expertOutput.analysis.overallRiskScore}/10`);
    console.log(`   ‚úì Confidence: ${(expertOutput.confidence * 100).toFixed(0)}%`);

    // Round 2: Adversarial critique
    console.log('\nüî• Round 2: Provocateur Critique');
    const provocateurOutput = await this.provocateur.critique(
      request.contractText,
      expertOutput
    );
    totalCost += this.provocateur.calculateCost(provocateurOutput.tokensUsed);
    console.log(`   ‚úì Found ${provocateurOutput.critique.flaws.length} flaws`);
    console.log(`   ‚úì Max severity: ${provocateurOutput.critique.maxSeverity}/5`);
    console.log(`   ‚úì Confidence: ${(provocateurOutput.confidence * 100).toFixed(0)}%`);

    // Round 3: Validation
    console.log('\nüîç Round 3: Validator Check');
    const validatorOutput = await this.validator.validate(
      request,
      expertOutput,
      provocateurOutput
    );
    totalCost += this.validator.calculateCost(validatorOutput.tokensUsed);
    console.log(`   ‚úì Completeness: ${validatorOutput.validation.completenessScore}%`);
    console.log(`   ‚úì Verdict: ${validatorOutput.validation.verdict}`);
    console.log(`   ‚úì Contradictions: ${validatorOutput.validation.contradictions.length}`);

    // Check stop criteria
    const shouldStop = this.checkStopCriteria(
      expertOutput,
      provocateurOutput,
      validatorOutput,
      1
    );

    if (shouldStop.shouldStop) {
      console.log(`\n‚úÖ Stop criteria met: ${shouldStop.reason}`);
    } else {
      console.log(`\n‚≠ê Continue criteria: ${shouldStop.reason}`);
      // In MVP, we don't actually iterate - just log
      // Future: Implement multi-round refinement
    }

    // Final: Synthesis
    console.log('\nüìù Final: Synthesizer');
    const synthesizerOutput = await this.synthesizer.synthesize(
      expertOutput,
      provocateurOutput,
      validatorOutput
    );
    totalCost += this.synthesizer.calculateCost(synthesizerOutput.tokensUsed);
    console.log(`   ‚úì Critical risks: ${synthesizerOutput.synthesis.criticalRisks.length}`);
    console.log(`   ‚úì Recommendations: ${synthesizerOutput.synthesis.recommendations.length}`);
    console.log(`   ‚úì Confidence: ${(synthesizerOutput.synthesis.confidence * 100).toFixed(0)}%`);

    // Build final response
    const processingTimeMs = Date.now() - startTime;
    const finalResponse = this.buildFinalResponse(
      synthesizerOutput,
      expertOutput,
      provocateurOutput,
      validatorOutput,
      {
        contractType: request.contractType,
        jurisdiction: request.jurisdiction,
        totalCost,
        processingTimeMs,
      }
    );

    console.log(`\n‚ú® Legal Council Review Complete!`);
    console.log(`   Total cost: $${totalCost.toFixed(4)}`);
    console.log(`   Processing time: ${(processingTimeMs / 1000).toFixed(1)}s`);
    console.log(`   Final confidence: ${(finalResponse.confidence * 100).toFixed(0)}%`);

    return finalResponse;
  }

  /**
   * Build final ContractReviewResponse from all outputs
   */
  private buildFinalResponse(
    synthesizerOutput: SynthesizerOutput,
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput,
    metadata: {
      contractType?: string;
      jurisdiction?: string;
      totalCost: number;
      processingTimeMs: number;
    }
  ): ContractReviewResponse {
    return {
      summary: synthesizerOutput.synthesis.summary,
      overallRiskScore: expertOutput.analysis.overallRiskScore,
      confidence: synthesizerOutput.synthesis.confidence,

      criticalRisks: synthesizerOutput.synthesis.criticalRisks,
      recommendations: synthesizerOutput.synthesis.recommendations,

      detailedAnalysis: {
        expertAnalysis: expertOutput.analysis,
        flawsFound: provocateurOutput.critique.flaws,
        validationResults: validatorOutput.validation,
      },

      metadata: {
        contractType: metadata.contractType as any,
        jurisdiction: metadata.jurisdiction,
        analyzedAt: new Date().toISOString(),
        totalCost: metadata.totalCost,
        processingTimeMs: metadata.processingTimeMs,
      },
    };
  }

  /**
   * Check if we should stop iteration
   */
  private checkStopCriteria(
    expertOutput: ExpertOutput,
    provocateurOutput: ProvocateurOutput,
    validatorOutput: ValidatorOutput,
    currentRound: number
  ): { shouldStop: boolean; reason: string } {
    // Criteria 1: Max rounds reached
    if (currentRound >= this.config.maxRounds) {
      return { shouldStop: true, reason: 'Max rounds reached' };
    }

    // Criteria 2: No high-severity issues
    const hasHighSeverityIssues =
      expertOutput.analysis.keyIssues.some(
        (i) => i.severity >= this.config.maxSeverityThreshold
      ) ||
      provocateurOutput.critique.flaws.some(
        (f) => f.severity >= this.config.maxSeverityThreshold
      );

    if (!hasHighSeverityIssues) {
      return {
        shouldStop: true,
        reason: `No issues with severity >= ${this.config.maxSeverityThreshold}`,
      };
    }

    // Criteria 3: High confidence from all agents
    const avgConfidence =
      (expertOutput.confidence +
        provocateurOutput.confidence +
        validatorOutput.confidence) /
      3;

    if (avgConfidence >= this.config.minConfidence) {
      return {
        shouldStop: true,
        reason: `Average confidence ${(avgConfidence * 100).toFixed(0)}% >= ${(this.config.minConfidence * 100).toFixed(0)}%`,
      };
    }

    // Criteria 4: Validator says COMPLETE
    if (validatorOutput.validation.verdict === 'COMPLETE') {
      return { shouldStop: true, reason: 'Validator verdict: COMPLETE' };
    }

    // Continue if none of the stop criteria met
    return {
      shouldStop: false,
      reason: `High severity issues remain (${hasHighSeverityIssues}), confidence low (${(avgConfidence * 100).toFixed(0)}%)`,
    };
  }

  /**
   * Get configuration
   */
  getConfig(): ReviewOrchestratorConfig {
    return { ...this.config };
  }

  /**
   * Update configuration
   */
  setConfig(config: Partial<ReviewOrchestratorConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

/**
 * Quick way to analyze contract
 */
export async function analyzeContract(
  contractText: string,
  options?: {
    contractType?: ContractReviewRequest['contractType'];
    jurisdiction?: string;
    questions?: string[];
    focusAreas?: ContractReviewRequest['focusAreas'];
    config?: Partial<ReviewOrchestratorConfig>;
  }
): Promise<ContractReviewResponse> {
  const orchestrator = new ReviewOrchestrator(options?.config);

  const request: ContractReviewRequest = {
    contractText,
    contractType: options?.contractType,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    specificQuestions: options?.questions,
    focusAreas: options?.focusAreas,
  };

  return orchestrator.analyze(request);
}


================================================================================
17. GENERATION ORCHESTRATOR
================================================================================
FILE: packages/legal-council/orchestrators/generation-orchestrator.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Generation Orchestrator
 * Coordinates Analyzer ‚Üí Drafter ‚Üí Validator ‚Üí Polisher
 */

import { AnalyzerAgent } from '../agents/generation/analyzer';
import { DrafterAgent } from '../agents/generation/drafter';
import { GenerationValidatorAgent } from '../agents/generation/validator';
import { PolisherAgent } from '../agents/generation/polisher';
import type {
  DocumentGenerationRequest,
  DocumentGenerationResponse,
} from '../types/generation-types';

export interface GenerationOrchestratorConfig {
  maxRevisions: number; // Max times to redraft if validator fails
  enableAuditTrail: boolean;
}

const DEFAULT_CONFIG: GenerationOrchestratorConfig = {
  maxRevisions: 2,
  enableAuditTrail: true,
};

export class GenerationOrchestrator {
  private config: GenerationOrchestratorConfig;
  private analyzer: AnalyzerAgent;
  private drafter: DrafterAgent;
  private validator: GenerationValidatorAgent;
  private polisher: PolisherAgent;

  constructor(config: Partial<GenerationOrchestratorConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };

    this.analyzer = new AnalyzerAgent();
    this.drafter = new DrafterAgent();
    this.validator = new GenerationValidatorAgent();
    this.polisher = new PolisherAgent();
  }

  /**
   * Main generation method
   */
  async generate(request: DocumentGenerationRequest): Promise<DocumentGenerationResponse> {
    const startTime = Date.now();
    let totalCost = 0;

    console.log('üìù Legal Council Generation Session Starting...');
    console.log(`   Document type: ${request.documentType}`);
    console.log(`   Max revisions: ${this.config.maxRevisions}`);

    // Step 1: Analyze requirements
    console.log('\nüîç Step 1: Analyzer');
    const analyzerOutput = await this.analyzer.analyze(request);
    totalCost += this.analyzer.calculateCost(analyzerOutput.tokensUsed);
    console.log(`   ‚úì Structured requirements`);
    console.log(
      `   ‚úì Must-have clauses: ${analyzerOutput.analysis.structuredRequirements.mustHaveClauses.length}`
    );
    console.log(
      `   ‚úì Suggested clauses: ${analyzerOutput.analysis.suggestedClauses.length}`
    );

    // Step 2: Draft document
    console.log('\nüìÑ Step 2: Drafter');
    const drafterOutput = await this.drafter.draft(
      request.documentType,
      analyzerOutput
    );
    totalCost += this.drafter.calculateCost(drafterOutput.tokensUsed);
    console.log(`   ‚úì Draft generated`);
    console.log(
      `   ‚úì Document length: ${drafterOutput.draft.documentText.length} chars`
    );
    console.log(
      `   ‚úì Clauses included: ${drafterOutput.draft.includedClauses.length}`
    );

    // Step 3: Validate
    console.log('\n‚úÖ Step 3: Validator');
    const validatorOutput = await this.validator.validate(analyzerOutput, drafterOutput);
    totalCost += this.validator.calculateCost(validatorOutput.tokensUsed);
    console.log(`   ‚úì Compliance score: ${validatorOutput.validation.overallScore}%`);
    console.log(`   ‚úì Verdict: ${validatorOutput.validation.verdict}`);
    console.log(
      `   ‚úì Risk flags: ${validatorOutput.validation.riskFlags.length}`
    );

    // Check if needs revision
    if (
      validatorOutput.validation.verdict === 'NEEDS_REVISION' &&
      validatorOutput.validation.riskFlags.some((f) => f.severity >= 4)
    ) {
      console.log('\n‚ö†Ô∏è  Critical issues found - would need revision in production');
      console.log('   (MVP: proceeding to polisher anyway)');
      // In production: Loop back to drafter with validator feedback
    }

    // Step 4: Polish
    console.log('\n‚ú® Step 4: Polisher');
    const polisherOutput = await this.polisher.polish(drafterOutput, validatorOutput);
    totalCost += this.polisher.calculateCost(polisherOutput.tokensUsed);
    console.log(`   ‚úì Document polished`);
    console.log(
      `   ‚úì Improvements made: ${polisherOutput.polished.improvements.length}`
    );
    console.log(`   ‚úì Executive summary prepared`);

    // Build final response
    const processingTimeMs = Date.now() - startTime;
    const finalResponse = this.polisher.buildFinalResponse(
      polisherOutput,
      analyzerOutput,
      drafterOutput,
      validatorOutput,
      {
        documentType: request.documentType,
        totalCost,
        processingTimeMs,
      }
    );

    console.log(`\nüéâ Legal Council Generation Complete!`);
    console.log(`   Total cost: $${totalCost.toFixed(4)}`);
    console.log(`   Processing time: ${(processingTimeMs / 1000).toFixed(1)}s`);
    console.log(
      `   Quality score: ${finalResponse.qualityMetrics.overall}%`
    );

    return finalResponse;
  }

  getConfig(): GenerationOrchestratorConfig {
    return { ...this.config };
  }

  setConfig(config: Partial<GenerationOrchestratorConfig>): void {
    this.config = { ...this.config, ...config };
  }
}

// ==========================================
// CONVENIENCE FUNCTION
// ==========================================

export async function generateDocument(
  requirements: string,
  documentType: DocumentGenerationRequest['documentType'],
  options?: {
    jurisdiction?: string;
    parties?: DocumentGenerationRequest['parties'];
    config?: Partial<GenerationOrchestratorConfig>;
  }
): Promise<DocumentGenerationResponse> {
  const orchestrator = new GenerationOrchestrator(options?.config);

  const request: DocumentGenerationRequest = {
    documentType,
    requirements,
    jurisdiction: options?.jurisdiction || 'Ukraine',
    parties: options?.parties,
  };

  return orchestrator.generate(request);
}


================================================================================
18. UKRAINIAN LAW SERVICE (+ getAllLaws)
================================================================================
FILE: packages/legal-council/services/ukrainian-law-service.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * Ukrainian Law Service
 * Provides legal references and context for Ukrainian jurisdiction
 * 
 * UPDATED: Added getAllLaws() method for generation-prompts integration
 */

import NodeCache from 'node-cache';

const lawCache = new NodeCache({ stdTTL: 86400 * 7 }); // Cache 7 days

// ==========================================
// COMMON UKRAINIAN LAWS (Hardcoded for MVP)
// ==========================================

interface LawInfo {
  fullName: string;
  code: string;
  url: string;
  keyArticles?: Record<string, string>;
}

const COMMON_LAWS: Record<string, LawInfo> = {
  '–¶–ö–£': {
    fullName: '–¶–∏–≤—ñ–ª—å–Ω–∏–π –∫–æ–¥–µ–∫—Å –£–∫—Ä–∞—ó–Ω–∏',
    code: '–¶–ö–£',
    url: 'https://zakon.rada.gov.ua/laws/show/435-15',
    keyArticles: {
      '11': '–¶–∏–≤—ñ–ª—å–Ω–∞ –ø—Ä–∞–≤–æ–∑–¥–∞—Ç–Ω—ñ—Å—Ç—å',
      '202': '–ü—Ä–∞–≤–æ—á–∏–Ω',
      '203': '–í–∏–¥–∏ –ø—Ä–∞–≤–æ—á–∏–Ω—ñ–≤',
      '215': '–ù–µ–¥—ñ–π—Å–Ω–∏–π –ø—Ä–∞–≤–æ—á–∏–Ω',
      '626': '–î–æ–≥–æ–≤—ñ—Ä (–ø–æ–Ω—è—Ç—Ç—è)',
      '627': '–ó–º—ñ—Å—Ç –¥–æ–≥–æ–≤–æ—Ä—É',
      '628': '–°–≤–æ–±–æ–¥–∞ –¥–æ–≥–æ–≤–æ—Ä—É',
      '638': '–Ü—Å—Ç–æ—Ç–Ω—ñ —É–º–æ–≤–∏ –¥–æ–≥–æ–≤–æ—Ä—É',
      '651': '–§–æ—Ä–º–∞ –¥–æ–≥–æ–≤–æ—Ä—É',
      '526': '–í–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–æ–±–æ–≤\'—è–∑–∞–Ω–Ω—è',
      '610': '–í—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å –∑–∞ –Ω–µ–≤–∏–∫–æ–Ω–∞–Ω–Ω—è',
      '1212': '–í—ñ–¥—à–∫–æ–¥—É–≤–∞–Ω–Ω—è –º–æ—Ä–∞–ª—å–Ω–æ—ó —à–∫–æ–¥–∏',
    },
  },
  
  '–ì–ö–£': {
    fullName: '–ì–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–∏–π –∫–æ–¥–µ–∫—Å –£–∫—Ä–∞—ó–Ω–∏',
    code: '–ì–ö–£',
    url: 'https://zakon.rada.gov.ua/laws/show/436-15',
    keyArticles: {
      '173': '–ì–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–∏–π –¥–æ–≥–æ–≤—ñ—Ä',
      '174': '–í–∏–º–æ–≥–∏ –¥–æ –∑–º—ñ—Å—Ç—É –≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–æ–≥–æ –¥–æ–≥–æ–≤–æ—Ä—É',
      '181': '–ó–º—ñ—Å—Ç –≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–æ–≥–æ –¥–æ–≥–æ–≤–æ—Ä—É',
      '193': '–ó–º—ñ–Ω–∞ —Ç–∞ —Ä–æ–∑—ñ—Ä–≤–∞–Ω–Ω—è –≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–æ–≥–æ –¥–æ–≥–æ–≤–æ—Ä—É',
      '230': '–í—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å —Å—É–±\'—î–∫—Ç—ñ–≤ –≥–æ—Å–ø–æ–¥–∞—Ä—é–≤–∞–Ω–Ω—è',
    },
  },
  
  '–ö–ó–ø–ü': {
    fullName: '–ö–æ–¥–µ–∫—Å –∑–∞–∫–æ–Ω—ñ–≤ –ø—Ä–æ –ø—Ä–∞—Ü—é –£–∫—Ä–∞—ó–Ω–∏',
    code: '–ö–ó–ø–ü',
    url: 'https://zakon.rada.gov.ua/laws/show/322-08',
    keyArticles: {
      '21': '–¢—Ä—É–¥–æ–≤–∏–π –¥–æ–≥–æ–≤—ñ—Ä',
      '24': '–°—Ç—Ä–æ–∫–æ–≤–∏–π —Ç—Ä—É–¥–æ–≤–∏–π –¥–æ–≥–æ–≤—ñ—Ä',
      '36': '–ü—ñ–¥—Å—Ç–∞–≤–∏ –ø—Ä–∏–ø–∏–Ω–µ–Ω–Ω—è —Ç—Ä—É–¥–æ–≤–æ–≥–æ –¥–æ–≥–æ–≤–æ—Ä—É',
      '38': '–†–æ–∑—ñ—Ä–≤–∞–Ω–Ω—è –∑–∞ —ñ–Ω—ñ—Ü—ñ–∞—Ç–∏–≤–æ—é –ø—Ä–∞—Ü—ñ–≤–Ω–∏–∫–∞',
      '40': '–†–æ–∑—ñ—Ä–≤–∞–Ω–Ω—è –∑–∞ —ñ–Ω—ñ—Ü—ñ–∞—Ç–∏–≤–æ—é –≤–ª–∞—Å–Ω–∏–∫–∞',
      '94': '–ù–æ—Ä–º–∞–ª—å–Ω–∞ —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å —Ä–æ–±–æ—á–æ–≥–æ —á–∞—Å—É',
      '115': '–©–æ—Ä—ñ—á–Ω–∞ –æ—Å–Ω–æ–≤–Ω–∞ –≤—ñ–¥–ø—É—Å—Ç–∫–∞',
    },
  },
  
  '–ó–£_–ü–î–í': {
    fullName: '–ó–∞–∫–æ–Ω –£–∫—Ä–∞—ó–Ω–∏ "–ü—Ä–æ –ø–æ–¥–∞—Ç–æ–∫ –Ω–∞ –¥–æ–¥–∞–Ω—É –≤–∞—Ä—Ç—ñ—Å—Ç—å"',
    code: '–ü–î–í',
    url: 'https://zakon.rada.gov.ua/laws/show/168/97-%D0%B2%D1%80',
    keyArticles: {
      '1': '–í–∏–∑–Ω–∞—á–µ–Ω–Ω—è —Ç–µ—Ä–º—ñ–Ω—ñ–≤',
      '3': '–û–±\'—î–∫—Ç –æ–ø–æ–¥–∞—Ç–∫—É–≤–∞–Ω–Ω—è',
      '7': '–°—Ç–∞–≤–∫–∏ –ø–æ–¥–∞—Ç–∫—É',
    },
  },
};

// ==========================================
// –î–°–¢–£ DOCUMENT STANDARDS
// ==========================================

export const DSTU_STRUCTURE = {
  sections: [
    '1. –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£',
    '2. –í–ê–†–¢–Ü–°–¢–¨ –¢–ê –ü–û–†–Ø–î–û–ö –†–û–ó–†–ê–•–£–ù–ö–Ü–í',
    '3. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –°–¢–û–†–Ü–ù',
    '4. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –°–¢–û–†–Ü–ù',
    '5. –°–¢–†–û–ö –î–Ü–á –î–û–ì–û–í–û–†–£',
    '6. –§–û–†–°-–ú–ê–ñ–û–†–ù–Ü –û–ë–°–¢–ê–í–ò–ù–ò',
    '7. –ü–û–†–Ø–î–û–ö –í–ò–†–Ü–®–ï–ù–ù–Ø –°–ü–û–†–Ü–í',
    '8. –Ü–ù–®–Ü –£–ú–û–í–ò',
    '9. –Æ–†–ò–î–ò–ß–ù–Ü –ê–î–†–ï–°–ò –¢–ê –†–ï–ö–í–Ü–ó–ò–¢–ò –°–¢–û–†–Ü–ù',
    '10. –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
  ],
  
  dateFormat: '–î–î.–ú–ú.–†–†–†–†', // 01.02.2025, not Feb 1, 2025
  
  currencyFormat: '10 000 (–¥–µ—Å—è—Ç—å —Ç–∏—Å—è—á) –≥—Ä–∏–≤–µ–Ω—å 00 –∫–æ–ø—ñ–π–æ–∫',
  
  parties: {
    standard: ['–ó–∞–º–æ–≤–Ω–∏–∫', '–í–∏–∫–æ–Ω–∞–≤–µ—Ü—å'],
    employment: ['–†–æ–±–æ—Ç–æ–¥–∞–≤–µ—Ü—å', '–ü—Ä–∞—Ü—ñ–≤–Ω–∏–∫'],
    vendor: ['–ü–æ–∫—É–ø–µ—Ü—å', '–ü—Ä–æ–¥–∞–≤–µ—Ü—å'],
  },
};

// ==========================================
// UKRAINIAN LAW SERVICE
// ==========================================

export class UkrainianLawService {
  
  /**
   * Get law reference with optional article
   */
  getLawReference(
    lawCode: keyof typeof COMMON_LAWS,
    article?: string
  ): string {
    const law = COMMON_LAWS[lawCode];
    
    if (!law) {
      return `–ó–∞–∫–æ–Ω "${lawCode}"`;
    }
    
    if (article && law.keyArticles?.[article]) {
      return `${law.code}, —Å—Ç–∞—Ç—Ç—è ${article} "${law.keyArticles[article]}"`;
    }
    
    return `${law.fullName} (${law.code})`;
  }
  
  /**
   * Get full law info
   */
  getLawInfo(lawCode: keyof typeof COMMON_LAWS): LawInfo | null {
    return COMMON_LAWS[lawCode] || null;
  }
  
  /**
   * Get ALL laws (NEW - for generation-prompts integration)
   */
  getAllLaws(): Record<string, LawInfo> {
    return COMMON_LAWS;
  }
  
  /**
   * Get all applicable laws for document type
   */
  getApplicableLaws(documentType: string): LawInfo[] {
    const laws: LawInfo[] = [];
    
    // Always include Civil Code
    laws.push(COMMON_LAWS['–¶–ö–£']);
    
    // Add specific laws based on type
    if (documentType.includes('employment') || documentType.includes('—Ç—Ä—É–¥–æ–≤')) {
      laws.push(COMMON_LAWS['–ö–ó–ø–ü']);
    }
    
    if (documentType.includes('commercial') || documentType.includes('–≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫')) {
      laws.push(COMMON_LAWS['–ì–ö–£']);
    }
    
    if (documentType.includes('vat') || documentType.includes('–ø–¥–≤')) {
      laws.push(COMMON_LAWS['–ó–£_–ü–î–í']);
    }
    
    return laws;
  }
  
  /**
   * Generate legal context for LLM prompt
   */
  async getLegalContext(documentType: string): Promise<string> {
    const applicableLaws = this.getApplicableLaws(documentType);
    
    let context = '–ó–ê–°–¢–û–°–û–í–ê–ù–ï –ó–ê–ö–û–ù–û–î–ê–í–°–¢–í–û –£–ö–†–ê–á–ù–ò:\n\n';
    
    for (const law of applicableLaws) {
      context += `${law.fullName} (${law.code}):\n`;
      context += `–î–∂–µ—Ä–µ–ª–æ: ${law.url}\n`;
      
      if (law.keyArticles) {
        context += '–ö–ª—é—á–æ–≤—ñ —Å—Ç–∞—Ç—Ç—ñ:\n';
        for (const [article, description] of Object.entries(law.keyArticles)) {
          context += `  - –°—Ç–∞—Ç—Ç—è ${article}: ${description}\n`;
        }
      }
      
      context += '\n';
    }
    
    return context;
  }
  
  /**
   * Validate contract section against Ukrainian law
   */
  validateSection(sectionContent: string, lawCode: string, article: string): {
    valid: boolean;
    issues: string[];
  } {
    // TODO: Implement actual validation logic
    // For MVP, just return valid
    return {
      valid: true,
      issues: [],
    };
  }
  
  /**
   * Search for relevant law articles by keyword
   */
  searchArticles(keyword: string): Array<{
    lawCode: string;
    article: string;
    description: string;
  }> {
    const results: Array<{
      lawCode: string;
      article: string;
      description: string;
    }> = [];
    
    const lowerKeyword = keyword.toLowerCase();
    
    for (const [code, law] of Object.entries(COMMON_LAWS)) {
      if (law.keyArticles) {
        for (const [article, description] of Object.entries(law.keyArticles)) {
          if (description.toLowerCase().includes(lowerKeyword)) {
            results.push({
              lawCode: code,
              article,
              description,
            });
          }
        }
      }
    }
    
    return results;
  }
}

// Export singleton instance
export const ukrainianLawService = new UkrainianLawService();


================================================================================
19. –î–°–¢–£ SERVICE (NEW)
================================================================================
FILE: packages/legal-council/services/dstu-service.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * –î–°–¢–£ 4163-2020 Service
 * Ukrainian document formatting standards and requirements
 */

export interface DstuRequirement {
  section: string;
  requirement: string;
  mandatory: boolean;
  description: string;
}

export interface DocumentTemplate {
  documentType: string;
  requiredSections: string[];
  requiredRequisites: string[];
  dstuReference: string;
}

/**
 * –î–°–¢–£ 4163-2020: –î—ñ–ª–æ–≤–æ–¥—Å—Ç–≤–æ –π –∞—Ä—Ö—ñ–≤–Ω–∞ —Å–ø—Ä–∞–≤–∞. –¢–µ—Ä–º—ñ–Ω–∏ —Ç–∞ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è
 * Document structure and formatting requirements
 */
export const DSTU_REQUIREMENTS: DstuRequirement[] = [
  // –ó–∞–≥–∞–ª—å–Ω—ñ –≤–∏–º–æ–≥–∏ –¥–æ –¥–æ–∫—É–º–µ–Ω—Ç—ñ–≤
  {
    section: '–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç—É',
    requirement: '–ù–∞–∑–≤–∞ –¥–æ–∫—É–º–µ–Ω—Ç—É',
    mandatory: true,
    description: '–ö–æ–∂–µ–Ω –¥–æ–∫—É–º–µ–Ω—Ç –ø–æ–≤–∏–Ω–µ–Ω –º–∞—Ç–∏ —á—ñ—Ç–∫—É –Ω–∞–∑–≤—É (–î–û–ì–û–í–Ü–†, –ö–û–ù–¢–†–ê–ö–¢ —Ç–æ—â–æ)',
  },
  {
    section: '–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç—É',
    requirement: '–î–∞—Ç–∞ —Å–∫–ª–∞–¥–∞–Ω–Ω—è',
    mandatory: true,
    description: '–î–∞—Ç–∞ —É —Ñ–æ—Ä–º–∞—Ç—ñ "[–î–ï–ù–¨] [–ú–Ü–°–Ø–¶–¨] [–†–Ü–ö] —Ä–æ–∫—É" (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, "15 –ª—é—Ç–æ–≥–æ 2026 —Ä–æ–∫—É")',
  },
  {
    section: '–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç—É',
    requirement: '–†–µ—î—Å—Ç—Ä–∞—Ü—ñ–π–Ω–∏–π –Ω–æ–º–µ—Ä',
    mandatory: true,
    description: '–£–Ω—ñ–∫–∞–ª—å–Ω–∏–π –Ω–æ–º–µ—Ä –¥–æ–∫—É–º–µ–Ω—Ç—É (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, "‚Ññ 123-–î–ì")',
  },
  {
    section: '–°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–æ–∫—É–º–µ–Ω—Ç—É',
    requirement: '–ú—ñ—Å—Ü–µ —Å–∫–ª–∞–¥–∞–Ω–Ω—è',
    mandatory: false,
    description: '–ù–∞—Å–µ–ª–µ–Ω–∏–π –ø—É–Ω–∫—Ç –¥–µ —É–∫–ª–∞–¥–∞—î—Ç—å—Å—è –¥–æ–≥–æ–≤—ñ—Ä (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, "–º. –ö–∏—ó–≤")',
  },
  
  // –ü—Ä–µ–∞–º–±—É–ª–∞
  {
    section: '–ü—Ä–µ–∞–º–±—É–ª–∞',
    requirement: '–ü–æ–≤–Ω–∞ –Ω–∞–∑–≤–∞ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–ü–æ–≤–Ω–µ –Ω–∞–π–º–µ–Ω—É–≤–∞–Ω–Ω—è —é—Ä–∏–¥–∏—á–Ω–∏—Ö –æ—Å—ñ–± –∞–±–æ –ü–Ü–ë —Ñ—ñ–∑–∏—á–Ω–∏—Ö –æ—Å—ñ–±',
  },
  {
    section: '–ü—Ä–µ–∞–º–±—É–ª–∞',
    requirement: '–ü—Ä–∞–≤–æ–≤–∞ —Ñ–æ—Ä–º–∞',
    mandatory: true,
    description: '–¢–û–í, –§–û–ü, –ê–¢, –§—ñ–∑–∏—á–Ω–∞ –æ—Å–æ–±–∞ —Ç–æ—â–æ',
  },
  {
    section: '–ü—Ä–µ–∞–º–±—É–ª–∞',
    requirement: '–ü—Ä–µ–¥—Å—Ç–∞–≤–Ω–∏–∫–∏ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–ü–Ü–ë —Ç–∞ –ø–æ—Å–∞–¥–∞ –æ—Å–æ–±–∏, —è–∫–∞ –ø—ñ–¥–ø–∏—Å—É—î –¥–æ–≥–æ–≤—ñ—Ä',
  },
  {
    section: '–ü—Ä–µ–∞–º–±—É–ª–∞',
    requirement: '–ü—ñ–¥—Å—Ç–∞–≤–∞ –¥—ñ–π',
    mandatory: true,
    description: '–°—Ç–∞—Ç—É—Ç, –ü–æ–ª–æ–∂–µ–Ω–Ω—è, –î–æ—Ä—É—á–µ–Ω–Ω—è —Ç–æ—â–æ',
  },
  {
    section: '–ü—Ä–µ–∞–º–±—É–ª–∞',
    requirement: '–£–º–æ–≤–Ω—ñ –Ω–∞–∑–≤–∏ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–Ü–º–µ–Ω–æ–≤–∞–Ω—ñ –Ω–∞–¥–∞–ª—ñ "–ó–∞–º–æ–≤–Ω–∏–∫" —Ç–∞ "–í–∏–∫–æ–Ω–∞–≤–µ—Ü—å" –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ',
  },
  
  // –û—Å–Ω–æ–≤–Ω–∏–π —Ç–µ–∫—Å—Ç
  {
    section: '–ü—Ä–µ–¥–º–µ—Ç –¥–æ–≥–æ–≤–æ—Ä—É',
    requirement: '–ß—ñ—Ç–∫–µ –≤–∏–∑–Ω–∞—á–µ–Ω–Ω—è –ø—Ä–µ–¥–º–µ—Ç—É',
    mandatory: true,
    description: '–ó–≥—ñ–¥–Ω–æ –¶–ö–£ —Å—Ç. 638 - —ñ—Å—Ç–æ—Ç–Ω–∞ —É–º–æ–≤–∞ –¥–æ–≥–æ–≤–æ—Ä—É',
  },
  {
    section: '–ü—Ä–∞–≤–∞ —Ç–∞ –æ–±–æ–≤\'—è–∑–∫–∏',
    requirement: '–ü—Ä–∞–≤–∞ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–ü–µ—Ä–µ–ª—ñ–∫ –ø—Ä–∞–≤ –∫–æ–∂–Ω–æ—ó —Å—Ç–æ—Ä–æ–Ω–∏ –¥–æ–≥–æ–≤–æ—Ä—É',
  },
  {
    section: '–ü—Ä–∞–≤–∞ —Ç–∞ –æ–±–æ–≤\'—è–∑–∫–∏',
    requirement: '–û–±–æ–≤\'—è–∑–∫–∏ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–ü–µ—Ä–µ–ª—ñ–∫ –æ–±–æ–≤\'—è–∑–∫—ñ–≤ –∫–æ–∂–Ω–æ—ó —Å—Ç–æ—Ä–æ–Ω–∏ –¥–æ–≥–æ–≤–æ—Ä—É',
  },
  {
    section: '–í–∞—Ä—Ç—ñ—Å—Ç—å —Ç–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫–∏',
    requirement: '–í–∞—Ä—Ç—ñ—Å—Ç—å/—Ü—ñ–Ω–∞',
    mandatory: true,
    description: '–ó–≥—ñ–¥–Ω–æ –¶–ö–£ —Å—Ç. 632 - —ñ—Å—Ç–æ—Ç–Ω–∞ —É–º–æ–≤–∞ –¥–ª—è –æ–ø–ª–∞—Ç–Ω–∏—Ö –¥–æ–≥–æ–≤–æ—Ä—ñ–≤',
  },
  {
    section: '–í–∞—Ä—Ç—ñ—Å—Ç—å —Ç–∞ —Ä–æ–∑—Ä–∞—Ö—É–Ω–∫–∏',
    requirement: '–ü–æ—Ä—è–¥–æ–∫ –æ–ø–ª–∞—Ç–∏',
    mandatory: true,
    description: '–¢–µ—Ä–º—ñ–Ω–∏, —Å–ø–æ—Å—ñ–±, —Ä–µ–∫–≤—ñ–∑–∏—Ç–∏ –¥–ª—è –æ–ø–ª–∞—Ç–∏',
  },
  {
    section: '–°—Ç—Ä–æ–∫ –¥—ñ—ó',
    requirement: '–î–∞—Ç–∞ –ø–æ—á–∞—Ç–∫—É –¥—ñ—ó',
    mandatory: true,
    description: '–ó —è–∫–æ—ó –¥–∞—Ç–∏ –¥–æ–≥–æ–≤—ñ—Ä –Ω–∞–±—É–≤–∞—î —á–∏–Ω–Ω–æ—Å—Ç—ñ',
  },
  {
    section: '–°—Ç—Ä–æ–∫ –¥—ñ—ó',
    requirement: '–î–∞—Ç–∞ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è –∞–±–æ —É–º–æ–≤–∏',
    mandatory: true,
    description: '–î–æ —è–∫–æ—ó –¥–∞—Ç–∏ –¥—ñ—î –∞–±–æ —É–º–æ–≤–∏ –ø—Ä–∏–ø–∏–Ω–µ–Ω–Ω—è',
  },
  {
    section: '–í—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å',
    requirement: '–°–∞–Ω–∫—Ü—ñ—ó –∑–∞ –ø–æ—Ä—É—à–µ–Ω–Ω—è',
    mandatory: true,
    description: '–®—Ç—Ä–∞—Ñ–∏, –ø–µ–Ω—è, –Ω–µ—É—Å—Ç–æ–π–∫–∞ –≤—ñ–¥–ø–æ–≤—ñ–¥–Ω–æ –¥–æ –¶–ö–£',
  },
  {
    section: '–í–∏—Ä—ñ—à–µ–Ω–Ω—è —Å–ø–æ—Ä—ñ–≤',
    requirement: '–ü—Ä–µ—Ç–µ–Ω–∑—ñ–π–Ω–∏–π –ø–æ—Ä—è–¥–æ–∫',
    mandatory: true,
    description: '–û–±–æ–≤\'—è–∑–∫–æ–≤–∏–π –¥–ª—è –≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–∏—Ö –¥–æ–≥–æ–≤–æ—Ä—ñ–≤',
  },
  {
    section: '–í–∏—Ä—ñ—à–µ–Ω–Ω—è —Å–ø–æ—Ä—ñ–≤',
    requirement: '–ü—ñ–¥—Å—É–¥–Ω—ñ—Å—Ç—å',
    mandatory: true,
    description: '–Ø–∫–∏–π —Å—É–¥ —Ä–æ–∑–≥–ª—è–¥–∞—î —Å–ø–æ—Ä–∏ (–≥–æ—Å–ø–æ–¥–∞—Ä—Å—å–∫–∏–π/—Ü–∏–≤—ñ–ª—å–Ω–∏–π)',
  },
  
  // –ü—ñ–¥–ø–∏—Å–∏
  {
    section: '–†–µ–∫–≤—ñ–∑–∏—Ç–∏ —Ç–∞ –ø—ñ–¥–ø–∏—Å–∏',
    requirement: '–ü–æ–≤–Ω—ñ —Ä–µ–∫–≤—ñ–∑–∏—Ç–∏ —Å—Ç–æ—Ä—ñ–Ω',
    mandatory: true,
    description: '–ê–¥—Ä–µ—Å–∞, –Ñ–î–†–ü–û–£/–†–ù–û–ö–ü–ü, —Ä/—Ä, –±–∞–Ω–∫, –ú–§–û',
  },
  {
    section: '–†–µ–∫–≤—ñ–∑–∏—Ç–∏ —Ç–∞ –ø—ñ–¥–ø–∏—Å–∏',
    requirement: '–ü—ñ–¥–ø–∏—Å–∏',
    mandatory: true,
    description: '–ü–æ—Å–∞–¥–∞, –ü–Ü–ë, –ø—ñ–¥–ø–∏—Å —É–ø–æ–≤–Ω–æ–≤–∞–∂–µ–Ω–∏—Ö –æ—Å—ñ–±',
  },
  {
    section: '–†–µ–∫–≤—ñ–∑–∏—Ç–∏ —Ç–∞ –ø—ñ–¥–ø–∏—Å–∏',
    requirement: '–ü–µ—á–∞—Ç–∫–∏',
    mandatory: false,
    description: '–ü–µ—á–∞—Ç–∫–∏ —é—Ä–∏–¥–∏—á–Ω–∏—Ö –æ—Å—ñ–± (—è–∫—â–æ —î)',
  },
];

/**
 * Document templates by type
 */
export const DOCUMENT_TEMPLATES: DocumentTemplate[] = [
  {
    documentType: '–¥–æ–≥–æ–≤—ñ—Ä_–∫—É–ø—ñ–≤–ª—ñ_–ø—Ä–æ–¥–∞–∂—É',
    requiredSections: [
      '1. –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£',
      '2. –¶–Ü–ù–ê –¢–ê –ü–û–†–Ø–î–û–ö –†–û–ó–†–ê–•–£–ù–ö–Ü–í',
      '3. –°–¢–†–û–ö–ò –ü–ï–†–ï–î–ê–ß–Ü –¢–û–í–ê–†–£',
      '4. –Ø–ö–Ü–°–¢–¨ –¢–û–í–ê–†–£ –¢–ê –ì–ê–†–ê–ù–¢–Ü–á',
      '5. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –°–¢–û–†–Ü–ù',
      '6. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –°–¢–û–†–Ü–ù',
      '7. –ü–û–†–Ø–î–û–ö –í–ò–†–Ü–®–ï–ù–ù–Ø –°–ü–û–†–Ü–í',
      '8. –§–û–†–°-–ú–ê–ñ–û–†',
      '9. –°–¢–†–û–ö –î–Ü–á –î–û–ì–û–í–û–†–£',
      '10. –ó–ê–ö–õ–Æ–ß–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '11. –†–ï–ö–í–Ü–ó–ò–¢–ò –¢–ê –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
    ],
    requiredRequisites: [
      '–î–∞—Ç–∞',
      '–ù–æ–º–µ—Ä',
      '–ú—ñ—Å—Ü–µ —É–∫–ª–∞–¥–µ–Ω–Ω—è',
      '–°—Ç–æ—Ä–æ–Ω–∏',
      '–ü—Ä–µ–¥–º–µ—Ç',
      '–¶—ñ–Ω–∞',
      '–ü—ñ–¥–ø–∏—Å–∏',
    ],
    dstuReference: '–î–°–¢–£ 4163-2020, –¶–ö–£ —Å—Ç. 700-717',
  },
  {
    documentType: '—Ç—Ä—É–¥–æ–≤–∏–π_–¥–æ–≥–æ–≤—ñ—Ä',
    requiredSections: [
      '1. –ó–ê–ì–ê–õ–¨–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '2. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –ü–†–ê–¶–Ü–í–ù–ò–ö–ê',
      '3. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –†–û–ë–û–¢–û–î–ê–í–¶–Ø',
      '4. –û–ü–õ–ê–¢–ê –ü–†–ê–¶–Ü',
      '5. –†–ï–ñ–ò–ú –†–û–ë–û–¢–ò –¢–ê –í–Ü–î–ü–û–ß–ò–ù–ö–£',
      '6. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –°–¢–û–†–Ü–ù',
      '7. –°–¢–†–û–ö –î–Ü–á –î–û–ì–û–í–û–†–£',
      '8. –ü–Ü–î–°–¢–ê–í–ò –ü–†–ò–ü–ò–ù–ï–ù–ù–Ø –î–û–ì–û–í–û–†–£',
      '9. –ó–ê–ö–õ–Æ–ß–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '10. –†–ï–ö–í–Ü–ó–ò–¢–ò –¢–ê –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
    ],
    requiredRequisites: [
      '–î–∞—Ç–∞',
      '–ù–æ–º–µ—Ä',
      '–ú—ñ—Å—Ü–µ —Ä–æ–±–æ—Ç–∏',
      '–ü–æ—Å–∞–¥–∞',
      '–î–∞—Ç–∞ –ø–æ—á–∞—Ç–∫—É —Ä–æ–±–æ—Ç–∏',
      '–ó–∞—Ä–æ–±—ñ—Ç–Ω–∞ –ø–ª–∞—Ç–∞',
      '–ü—ñ–¥–ø–∏—Å–∏',
    ],
    dstuReference: '–î–°–¢–£ 4163-2020, –ö–ó–ø–ü —Å—Ç. 21-24',
  },
  {
    documentType: '–¥–æ–≥–æ–≤—ñ—Ä_–æ—Ä–µ–Ω–¥–∏',
    requiredSections: [
      '1. –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£',
      '2. –°–¢–†–û–ö –û–†–ï–ù–î–ò',
      '3. –û–†–ï–ù–î–ù–ê –ü–õ–ê–¢–ê –¢–ê –ü–û–†–Ø–î–û–ö –†–û–ó–†–ê–•–£–ù–ö–Ü–í',
      '4. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –û–†–ï–ù–î–ê–†–Ø',
      '5. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –û–†–ï–ù–î–û–î–ê–í–¶–Ø',
      '6. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –°–¢–û–†–Ü–ù',
      '7. –ü–û–†–Ø–î–û–ö –ü–ï–†–ï–î–ê–ß–Ü –¢–ê –ü–û–í–ï–†–ù–ï–ù–ù–Ø –ú–ê–ô–ù–ê',
      '8. –ü–û–†–Ø–î–û–ö –í–ò–†–Ü–®–ï–ù–ù–Ø –°–ü–û–†–Ü–í',
      '9. –§–û–†–°-–ú–ê–ñ–û–†',
      '10. –ó–ê–ö–õ–Æ–ß–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '11. –†–ï–ö–í–Ü–ó–ò–¢–ò –¢–ê –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
    ],
    requiredRequisites: [
      '–î–∞—Ç–∞',
      '–ù–æ–º–µ—Ä',
      '–ü—Ä–µ–¥–º–µ—Ç –æ—Ä–µ–Ω–¥–∏',
      '–°—Ç—Ä–æ–∫ –æ—Ä–µ–Ω–¥–∏',
      '–û—Ä–µ–Ω–¥–Ω–∞ –ø–ª–∞—Ç–∞',
      '–ü—ñ–¥–ø–∏—Å–∏',
    ],
    dstuReference: '–î–°–¢–£ 4163-2020, –¶–ö–£ —Å—Ç. 759-786',
  },
  {
    documentType: '–¥–æ–≥–æ–≤—ñ—Ä_–ø—ñ–¥—Ä—è–¥—É',
    requiredSections: [
      '1. –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£',
      '2. –°–¢–†–û–ö–ò –í–ò–ö–û–ù–ê–ù–ù–Ø –†–û–ë–Ü–¢',
      '3. –¶–Ü–ù–ê –¢–ê –ü–û–†–Ø–î–û–ö –†–û–ó–†–ê–•–£–ù–ö–Ü–í',
      '4. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –ó–ê–ú–û–í–ù–ò–ö–ê',
      '5. –ü–†–ê–í–ê –¢–ê –û–ë–û–í\'–Ø–ó–ö–ò –ü–Ü–î–†–Ø–î–ù–ò–ö–ê',
      '6. –ó–î–ê–ß–ê –¢–ê –ü–†–ò–ô–ú–ê–ù–ù–Ø –†–û–ë–Ü–¢',
      '7. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –°–¢–û–†–Ü–ù',
      '8. –ü–û–†–Ø–î–û–ö –í–ò–†–Ü–®–ï–ù–ù–Ø –°–ü–û–†–Ü–í',
      '9. –§–û–†–°-–ú–ê–ñ–û–†',
      '10. –ó–ê–ö–õ–Æ–ß–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '11. –†–ï–ö–í–Ü–ó–ò–¢–ò –¢–ê –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
    ],
    requiredRequisites: [
      '–î–∞—Ç–∞',
      '–ù–æ–º–µ—Ä',
      '–ü—Ä–µ–¥–º–µ—Ç —Ä–æ–±—ñ—Ç',
      '–°—Ç—Ä–æ–∫–∏',
      '–¶—ñ–Ω–∞',
      '–ü—ñ–¥–ø–∏—Å–∏',
    ],
    dstuReference: '–î–°–¢–£ 4163-2020, –¶–ö–£ —Å—Ç. 837-862',
  },
  {
    documentType: 'NDA',
    requiredSections: [
      '1. –¢–ï–†–ú–Ü–ù–ò –¢–ê –í–ò–ó–ù–ê–ß–ï–ù–ù–Ø',
      '2. –ü–†–ï–î–ú–ï–¢ –î–û–ì–û–í–û–†–£',
      '3. –ó–û–ë–û–í\'–Ø–ó–ê–ù–ù–Ø –°–¢–û–†–Ü–ù',
      '4. –í–ò–ö–õ–Æ–ß–ï–ù–ù–Ø –ó –ö–û–ù–§–Ü–î–ï–ù–¶–Ü–ô–ù–û–á –Ü–ù–§–û–†–ú–ê–¶–Ü–á',
      '5. –°–¢–†–û–ö –î–Ü–á –ó–û–ë–û–í\'–Ø–ó–ê–ù–¨',
      '6. –í–Ü–î–ü–û–í–Ü–î–ê–õ–¨–ù–Ü–°–¢–¨ –ó–ê –†–û–ó–ì–û–õ–û–®–ï–ù–ù–Ø',
      '7. –ü–û–†–Ø–î–û–ö –í–ò–†–Ü–®–ï–ù–ù–Ø –°–ü–û–†–Ü–í',
      '8. –ó–ê–ö–õ–Æ–ß–ù–Ü –ü–û–õ–û–ñ–ï–ù–ù–Ø',
      '9. –†–ï–ö–í–Ü–ó–ò–¢–ò –¢–ê –ü–Ü–î–ü–ò–°–ò –°–¢–û–†–Ü–ù',
    ],
    requiredRequisites: [
      '–î–∞—Ç–∞',
      '–ù–æ–º–µ—Ä',
      '–°—Ç–æ—Ä–æ–Ω–∏',
      '–ü—Ä–µ–¥–º–µ—Ç –∫–æ–Ω—Ñ—ñ–¥–µ–Ω—Ü—ñ–π–Ω–æ—Å—Ç—ñ',
      '–°—Ç—Ä–æ–∫',
      '–ü—ñ–¥–ø–∏—Å–∏',
    ],
    dstuReference: '–î–°–¢–£ 4163-2020, –¶–ö–£ —Å—Ç. 626-629',
  },
];

class DstuService {
  /**
   * Get –î–°–¢–£ requirements by section
   */
  getRequirementsBySection(section: string): DstuRequirement[] {
    return DSTU_REQUIREMENTS.filter((req) => req.section === section);
  }

  /**
   * Get mandatory requirements
   */
  getMandatoryRequirements(): DstuRequirement[] {
    return DSTU_REQUIREMENTS.filter((req) => req.mandatory);
  }

  /**
   * Get document template by type
   */
  getTemplate(documentType: string): DocumentTemplate | null {
    return (
      DOCUMENT_TEMPLATES.find((tpl) => tpl.documentType === documentType) || null
    );
  }

  /**
   * Validate document structure against –î–°–¢–£
   */
  validateStructure(
    documentType: string,
    sections: string[]
  ): { valid: boolean; missing: string[] } {
    const template = this.getTemplate(documentType);
    if (!template) {
      return { valid: false, missing: ['Template not found'] };
    }

    const missing = template.requiredSections.filter(
      (reqSection) =>
        !sections.some((section) =>
          section.toLowerCase().includes(reqSection.toLowerCase())
        )
    );

    return {
      valid: missing.length === 0,
      missing,
    };
  }

  /**
   * Get all document types
   */
  getDocumentTypes(): string[] {
    return DOCUMENT_TEMPLATES.map((tpl) => tpl.documentType);
  }
}

export const dstuService = new DstuService();


================================================================================
20. REVIEW API ROUTE (NEXT.JS 14)
================================================================================
FILE: app/api/review/route.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * API Route: Contract Review
 * POST /api/review
 * 
 * Accepts contract text, runs 4-agent analysis, returns comprehensive report
 */

import { NextRequest, NextResponse } from 'next/server';
import { ReviewOrchestrator } from '../../../packages/legal-council/orchestrators/review-orchestrator';
import type { ContractReviewRequest } from '../../../packages/legal-council/types/review-types';

// ==========================================
// NEXT.JS 14 ROUTE SEGMENT CONFIG
// ==========================================
// Replaced deprecated `export const config = {...}` with new format

// Maximum execution time (5 minutes for complex contracts)
export const maxDuration = 300;

// Force dynamic rendering (no static generation)
export const dynamic = 'force-dynamic';

// Runtime (nodejs, not edge)
export const runtime = 'nodejs';

// ==========================================
// POST HANDLER
// ==========================================

export async function POST(request: NextRequest) {
  try {
    // Parse request body (Next.js 14 app/ routes handle large bodies automatically)
    const body = await request.json();
    
    // Validate required fields
    if (!body.contractText || typeof body.contractText !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid contractText field' },
        { status: 400 }
      );
    }

    // Build request
    const reviewRequest: ContractReviewRequest = {
      contractText: body.contractText,
      contractType: body.contractType,
      jurisdiction: body.jurisdiction || 'Ukraine',
      specificQuestions: body.specificQuestions,
      focusAreas: body.focusAreas,
    };

    console.log(`üìã Review request received (${reviewRequest.contractText.length} chars)`);

    // Initialize orchestrator
    const orchestrator = new ReviewOrchestrator({
      maxRounds: 3,
      maxSeverityThreshold: 3,
      minConfidence: 0.85,
      enableAuditTrail: true,
    });

    // Run analysis
    const startTime = Date.now();
    const result = await orchestrator.analyze(reviewRequest);
    const duration = Date.now() - startTime;

    console.log(`‚úÖ Review complete in ${(duration / 1000).toFixed(1)}s`);
    console.log(`   Cost: $${result.metadata.totalCost.toFixed(4)}`);
    console.log(`   Confidence: ${(result.confidence * 100).toFixed(0)}%`);

    // Return response
    return NextResponse.json({
      success: true,
      data: result,
      metadata: {
        processingTimeMs: duration,
        timestamp: new Date().toISOString(),
      },
    });

  } catch (error) {
    console.error('‚ùå Review API error:', error);

    // Handle specific error types
    if (error instanceof Error) {
      // API key errors
      if (error.message.includes('API key')) {
        return NextResponse.json(
          { error: 'Invalid API configuration. Please check environment variables.' },
          { status: 500 }
        );
      }

      // Rate limit errors
      if (error.message.includes('rate limit')) {
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please try again later.' },
          { status: 429 }
        );
      }

      // Generic error
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    // Unknown error
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}


================================================================================
21. GENERATE API ROUTE (NEXT.JS 14)
================================================================================
FILE: app/api/generate/route.ts
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

/**
 * API Route: Document Generation
 * POST /api/generate
 * 
 * Accepts requirements, generates –î–°–¢–£-compliant Ukrainian contract
 */

import { NextRequest, NextResponse } from 'next/server';
import { GenerationOrchestrator } from '../../../packages/legal-council/orchestrators/generation-orchestrator';
import type { DocumentGenerationRequest } from '../../../packages/legal-council/types/generation-types';

// ==========================================
// NEXT.JS 14 ROUTE SEGMENT CONFIG
// ==========================================
// Replaced deprecated `export const config = {...}` with new format

// Maximum execution time (5 minutes for complex document generation)
export const maxDuration = 300;

// Force dynamic rendering (no static generation)
export const dynamic = 'force-dynamic';

// Runtime (nodejs, not edge)
export const runtime = 'nodejs';

// ==========================================
// POST HANDLER
// ==========================================

export async function POST(request: NextRequest) {
  try {
    // Parse request body (Next.js 14 app/ routes handle large bodies automatically)
    const body = await request.json();
    
    // Validate required fields
    if (!body.documentType || typeof body.documentType !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid documentType field' },
        { status: 400 }
      );
    }

    if (!body.requirements || typeof body.requirements !== 'string') {
      return NextResponse.json(
        { error: 'Missing or invalid requirements field' },
        { status: 400 }
      );
    }

    // Build request
    const generationRequest: DocumentGenerationRequest = {
      documentType: body.documentType,
      requirements: body.requirements,
      jurisdiction: body.jurisdiction || 'Ukraine',
      parties: body.parties,
      specificClauses: body.specificClauses,
      template: body.template || 'balanced',
    };

    console.log(`üìù Generation request received: ${generationRequest.documentType}`);

    // Initialize orchestrator
    const orchestrator = new GenerationOrchestrator({
      maxRevisions: 2,
      enableAuditTrail: true,
    });

    // Run generation
    const startTime = Date.now();
    const result = await orchestrator.generate(generationRequest);
    const duration = Date.now() - startTime;

    console.log(`‚úÖ Generation complete in ${(duration / 1000).toFixed(1)}s`);
    console.log(`   Cost: $${result.metadata.totalCost.toFixed(4)}`);
    console.log(`   Quality: ${result.qualityMetrics.overall}%`);

    // Return response
    return NextResponse.json({
      success: true,
      data: result,
      metadata: {
        processingTimeMs: duration,
        timestamp: new Date().toISOString(),
      },
    });

  } catch (error) {
    console.error('‚ùå Generation API error:', error);

    if (error instanceof Error) {
      // API key errors
      if (error.message.includes('API key')) {
        return NextResponse.json(
          { error: 'Invalid API configuration. Please check environment variables.' },
          { status: 500 }
        );
      }

      // Rate limit errors
      if (error.message.includes('rate limit')) {
        return NextResponse.json(
          { error: 'Rate limit exceeded. Please try again later.' },
          { status: 429 }
        );
      }

      // Validation errors
      if (error.message.includes('Invalid') || error.message.includes('Missing')) {
        return NextResponse.json(
          { error: error.message },
          { status: 400 }
        );
      }

      // Generic error
      return NextResponse.json(
        { error: error.message },
        { status: 500 }
      );
    }

    // Unknown error
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}


================================================================================
22. ENVIRONMENT VARIABLES
================================================================================
FILE: .env.example
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

# Legal Council - Environment Variables
# Copy this file to .env and fill in your actual values

# ==========================================
# LLM API KEYS (Required)
# ==========================================

# Anthropic Claude API Key
# Get from: https://console.anthropic.com/
ANTHROPIC_API_KEY=sk-ant-api03-xxx

# OpenAI GPT API Key
# Get from: https://platform.openai.com/api-keys
OPENAI_API_KEY=sk-xxx

# Google Gemini API Key
# Get from: https://aistudio.google.com/apikey
GOOGLE_API_KEY=AIzaXXX

# ==========================================
# ENVIRONMENT MODE
# ==========================================

# Options: production | testing | development
# - production: Best quality, highest cost (Opus as Expert)
# - testing: Good quality, 70% cheaper (Sonnet as Expert) ‚Üê RECOMMENDED for MVP
# - development: Max savings (Gemini where possible)
LEGAL_COUNCIL_ENV=testing

# ==========================================
# NEXT.JS CONFIGURATION
# ==========================================

# Application URL (for CORS, webhooks, etc.)
NEXT_PUBLIC_APP_URL=http://localhost:3000

# Node environment
NODE_ENV=development

# ==========================================
# OPTIONAL: DATABASE (Future)
# ==========================================

# PostgreSQL connection (if using database for audit logs)
# DATABASE_URL=postgresql://user:password@localhost:5432/legal_council

# ==========================================
# OPTIONAL: MONITORING (Future)
# ==========================================

# Sentry DSN for error tracking
# SENTRY_DSN=https://xxx@sentry.io/xxx

# ==========================================
# COST LIMITS (Optional Safety)
# ==========================================

# Maximum cost per query in USD (safety limit)
# MAX_COST_PER_QUERY=1.00

# Daily cost limit in USD
# DAILY_COST_LIMIT=50.00

# ==========================================
# FEATURE FLAGS (Optional)
# ==========================================

# Enable audit trail logging (true | false)
ENABLE_AUDIT_TRAIL=true

# Enable cost tracking (true | false)
ENABLE_COST_TRACKING=true

# ==========================================
# NOTES
# ==========================================

# 1. NEVER commit .env to Git (it's in .gitignore)
# 2. Keep .env.example up to date when adding new variables
# 3. For production deployment:
#    - Set LEGAL_COUNCIL_ENV=production
#    - Use environment variables in hosting platform (Vercel, Railway, etc.)
#    - Rotate API keys regularly
# 4. Cost estimates (testing mode):
#    - Contract Review: ~$0.14 per query
#    - Document Generation: ~$0.18 per query
#    - 100 queries/day = ~$16/day = ~$500/month


================================================================================
END OF FILE
================================================================================

–í–µ—Ä—Å—ñ—è: 1.1.0
–î–∞—Ç–∞: 12 –ª—é—Ç–æ–≥–æ 2026
–¢–µ—Å—Ç—ñ–≤ –ø—Ä–æ–π–¥–µ–Ω–æ: 3/3 (100%)
–°—Ç–∞—Ç—É—Å: ‚úÖ Fully Operational

